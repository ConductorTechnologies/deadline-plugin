// ===============================================================================================================
// Submit a Maya job to the deadline system.
// Install this in the Deadline Repository.
//
// Copyright (c) Thinkbox Software Inc
// All rights reserved.
// ===============================================================================================================

// ===============================================================================================================
// Adds Thinkbox shelf and button to Maya UI if necessary.
// ===============================================================================================================

// Only update the Maya UI if we're not in batch mode.
int $batchMode = `about -batch`;
if( $batchMode )
{
	string $newName = "Deadline";
	string $newButtonName = "DeadlineButton";
	string $fileName = ( `internalVar -userShelfDir` + "shelf_" + $newName + ".mel" );

	int $addShelf = true;
	if( `file -q -exists $fileName` )
		$addShelf = false;
	else
	{
		// Check for existing shelves in optionVars.
		string $shelfName;
		int $shelfCount = `optionVar -q numShelves`;
		for( $i = 1; $i <= $shelfCount; $i++ )
		{
			$varName = "shelfName" + $i;
			$shelfName = `optionVar -q $varName`;
			if( $shelfName == $newName )
			{
				$addShelf = false;
				break;
			}
		}
		
		// Add the shelf if necessary.
		if( $addShelf )
			addNewShelfTab $newName;
	}

	int $addButton = true;
	
	string $imagePath = CheckSlashes( CallDeadlineCommand( "-GetRepositoryFilepath submission/Maya/Main/Submit.png", false ) );
	string $buttonArray[] = `shelfLayout -q -childArray $newName`;
	for( $cnt = 0; $cnt < size( $buttonArray ); $cnt++ )
	{
		$buttonAnnotation = `shelfButton -q -annotation $buttonArray[$cnt]`;
		if( $buttonAnnotation == "Submit To Deadline" )
		{
			$addButton = false;
			shelfButton -e -image1 $imagePath $buttonArray[$cnt];
			break;
		}
	}

	if( $addButton )
	{
		shelfButton -parent $newName -annotation "Submit To Deadline" -image1 $imagePath -command ("SubmitJobToDeadline") $newButtonName;
	}
}

// ===============================================================================================================
// Globals
// ===============================================================================================================

global string $DeadlineSubmitterWindow;
global string $ProjectPathGrp;
global string $ImageOutputPathGrp;
global string $StartupScriptPathGrp;
global string $MentalRayFilenameGrp;
global string $VRayFilenameGrp;
global string $LimitGroupGrp;
global string $DependenciesGrp;
global string $MachineListGrp;
global string $JobNameGrp;

global string $MayaRenderOptionsRollout;
global string $MayaRenderOptionsArnoldRollout;
global string $MayaRenderOptionsMentalRayRollout;
global string $MayaRenderOptionsRedshiftRollout;
global string $MayaRenderOptionsIRayRollout;
global string $MayaRenderOptionsVRayRollout;
global string $MayaRenderOptionsTileRollout;
global string $MayaRenderOptionsJigsawRollout;
global string $MentalRayExportRollout;
global string $MentalRayExportRenderJobRollout;
global string $VrayExportRollout;
global string $VrayExportRenderJobRollout;
global string $VrayExportVrimgJobRollout;
global string $RendermanExportRollout;
global string $RendermanExportRenderJobRollout;
global string $ArnoldExportRollout;
global string $ArnoldExportRenderJobRollout;
global string $RedshiftExportRollout;
global string $RedshiftExportRenderJobRollout;

global string $OverrideLayerSettingsDialog;


global int $MayaRenderJobType = 1;
global int $MentalRayExportJobType = 2;
global int $VRayExportJobType = 3;
global int $RendermanExportJobType = 4;
global int $ArnoldExportJobType = 5;
global int $MaxwellExportJobType = 6;
global int $BifrostSimulationJobType = 7;
global int $AlembicExportJobType = 8;
global int $MayaScriptJobType = 9;
global int $FluidCachingJobType = 10;
global int $GeometryCachingJobType = 11;
global int $RedshiftExportJobType = 12;

global int $JigsawRegionRenderType = 1;
global int $TileRegionRenderType = 2;

global int $BlankImageCompType = 1;
global int $PreviousImageCompType = 2;
global int $SelectedImageCompType = 3;

//Vray
global string $VrayLimitGroupGrp;
global string $VrayMachineListGrp;

//Mental Ray
global string $MentalLimitGroupGrp;
global string $MentalMachineListGrp;

//Renderman
global string $RendermanLimitGroupGrp;
global string $RendermanMachineListGrp;

//Arnold
global string $ArnoldLimitGroupGrp;
global string $ArnoldMachineListGrp;

//Maxwell
global string $MaxwellLimitGroupGrp;
global string $MaxwellMachineListGrp;
global string $MaxwellOutputScriptListGrp;

//Redshift
global string $RedshiftLimitGroupGrp;
global string $RedshiftMachineListGrp;

//=================================================================
// SHOTGUN / FTRACK / NIM / Draft

global string $IntegrationInfoKeys[];
global string $IntegrationInfoValues[];
global string $PipelineToolStatusLabel;

//=================================================================

//--------------------------------------------------------
// Browsing functions that call Deadline command.
//--------------------------------------------------------

global proc dlSetDirectory( string $uiElement )
{
	string $newdir = CallDeadlineCommand( "-getdirectory \"" + `textFieldButtonGrp -q -text $uiElement` + "\"", false );
	if( $newdir != "" )
		textFieldButtonGrp -e -text $newdir $uiElement;
	
	SavePersistentDeadlineOptions();
}

global proc dlSetLoadFilename( string $uiElement, string $filter )
{
	string $newpath = CallDeadlineCommand( "-SelectFilenameLoad \"" + `textFieldButtonGrp -q -text $uiElement` + "\" \""+$filter+"\"", false );
	if( $newpath != "" )
		textFieldButtonGrp -e -text $newpath $uiElement;
	
	SavePersistentDeadlineOptions();
}

global proc dlSetSaveFilename( string $uiElement, string $filter )
{
	string $newFilename = CallDeadlineCommand( "-selectfilenamesave \"" + `textFieldButtonGrp -q -text $uiElement` + "\" \""+ $filter+"\"", false );
	if( $newFilename != "" )
		textFieldButtonGrp -e -text $newFilename $uiElement;

	SavePersistentDeadlineOptions();
}

// Set the limit groups in the limit group field.
global proc dlSetLimitGroups( string $uiElement )
{
	string $newLimitGroups = CallDeadlineCommand( "-selectlimitgroups \"" + `textFieldButtonGrp -q -text $uiElement` + "\"", false );
	if( $newLimitGroups != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newLimitGroups $uiElement;
	
	SavePersistentDeadlineOptions();
}

global proc dlSetDependencies( string $uiElement )
{
	string $newDependencies = CallDeadlineCommand( "-selectdependencies \"" + `textFieldButtonGrp -q -text $uiElement` + "\"", false );
	if( $newDependencies != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newDependencies $uiElement;
	
	SavePersistentDeadlineOptions();
}

global proc dlSetMachineList( string $uiElement )
{
	string $newMachineList = CallDeadlineCommand( "-selectmachinelist \"" + `textFieldButtonGrp -q -text $uiElement` + "\"", false );
	if( $newMachineList != "Action was cancelled by user" )
		textFieldButtonGrp -e -text $newMachineList $uiElement;
	
	SavePersistentDeadlineOptions();
}

// Set the pipeline tool status field
global proc SetPipelineToolStatus( string $statusMessage)
{

	$statusLines = stringToStringArray( $statusMessage, "\n" );
	$status = $statusLines[0];
	if( $status != "")
	{
		if(startsWith($status, "Error"))
		{
			print($statusMessage);
			$status = "Pipeline Tools Error";
		}

		global string $PipelineToolStatusLabel;
		text -e -label $status $PipelineToolStatusLabel;
	}

}

// Set the job name to be the scene name.
global proc SetJobName()
{
	global string $JobNameGrp;
	string $newJobName = GetStrippedSceneFileName();
	textFieldButtonGrp -e -text $newJobName $JobNameGrp;
	
	SavePersistentDeadlineOptions();
}

//=================================================================

//---------------------------------------------------------
// Maya Helper Functions
//---------------------------------------------------------

// Returns the current version of Maya.
global proc float MayaVersion()
{
	float $version = getApplicationVersionAsFloat();
	if( $version < 2014 || $version == 2016 )
	{
		// Before 2014, getApplicationVersionAsFloat would parse `about -v`, which wouldn't include the .5 at the end of the Maya 2011.5 or 2013.5 releases.
		// This was fixed in 2014 by parsing `about -apiVersion`, so that's what we're doing here.
		int $apiVersion = `about -apiVersion`;
		$version = float($apiVersion) / 100.0;
	}
	return $version;
}

// Returns the current version of Maya as an integer.
global proc int IntMayaVersion()
{
	float $version = MayaVersion();
	return floor( $version );
}

// Returns the Major.Minor version of V-Ray as a float. ie. Version 3.60.02 will give us 3.6
global proc float GetVRayVersion()
{
	float $version = 2.0;
	string $versionString = "";

	if( !catchQuiet( $versionString = `vray version` ) )
	{
		// Warning: Converting string "3.60.02" to a float value of 3.6. //
		catchQuiet( $version = (float)$versionString );
	}
	
	return $version;
}

// Returns the Major version of any given plugin name as an integer.
global proc int GetPluginMajorVersion( string $pluginName )
{
	int $version = 0;
	string $versionString = "";

	if( !catchQuiet( $versionString = `pluginInfo -q -v $pluginName` ) )
	{
		catchQuiet( $version = (int)$versionString );
	}

	return $version;
}

//Returns whether the global preferences "Include all lights in each render layer by default" is enabled or not taking into account the Environment variable override.
proc int GetRenderSetupIncludeLights()
{
	int $includeLights = 1;
	
	if( !catchQuiet( python("import maya.app.renderSetup.model.renderSetupPreferences as renderSetupPrefs") ) )
	{
		if( !catchQuiet( python("includeLights = renderSetupPrefs.IncludeAllLightsSetting") ) )
		{
			$includeLights= python("includeLights.isEnabled()");
		}
	}
	
	return $includeLights;
	
}

// Translates two version strings and performs a python tuple comparison. ie. "2.6.13" compared to "2.6.12" is tuple(2,6,13) >= tuple(2,6,12)
// Returns true if the first version is greater or equal to the second version. Useful for comparing more than just Major.Minor (ie. .BuildNum)
global proc int isVersionGreaterOrEqual( string $version1, string $version2, string $separator )
{
	return python( 
		"tuple( int(num) for num in '" + $version1 + "'.split('" + $separator + "') ) >=" +
		"tuple( int(num) for num in '" + $version2 + "'.split('" + $separator + "') )" );
}

global proc string ForceRenderLayerToken( string $filePath )
{
	if( IsRenderLayersOn() && !python( "import re; match = re.search(r'<Layer>|<layer>|%l', '" + $filePath + "'); bool(match)" ) )
	{
		string $directory = dirname( $filePath ) + "/";
		string $filename = basenameEx( $filePath );
		string $extension = fileExtension( $filePath );

		// Force the path to have a layer token
		$filePath = $directory + $filename+  "_<Layer>." + $extension;
	}

	return $filePath;
}

// Returns the current renderer.
global proc string GetCurrentRenderer()
{
	string $renderer = currentRenderer();
	if( $renderer == "_3delight" )
		$renderer = "3delight";
	//In renderman version 22 the renderer name changed from renderMan to renderman while also updating other logic.
	//In the Deadline plugin we are doing case insensitve checks in the submitter we are not so we must make it unique.
	if( $renderer == "renderman" )
		$renderer = "renderman22";
		
	return $renderer;
}

// Returns if we're using an older version of vray
global proc string IsOldVray()
{
	// This function contains 3 parameters in the new version, so if this eval
	// returns an error (ie: 1), then we know it's an old version of Vray.
	return catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\" )" ) );
}
//Returns the current output directory without evaluating any tokens
global proc string GetBaseOutputDirectory( string $renderer )
{
	string $outputDirectory = "";
	if( $renderer == "renderman22" )
	{
		$outputDirectory = python( "dlRenderman.get_output_directory()");
	}
	else
	{
		$outputDirectory = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	}
	return $outputDirectory;
}

//Returns the current output prefix without evaluating any tokens
global proc string GetBaseOutputPrefix( string $renderer, string $camera, string $layer )
{
	string $outputPrefix = "";
	if( $renderer == "renderman22" )
	{
		$outputPrefix = python( "dlRenderman.get_output_prefix()");
	}
	else
	{
		$outputPrefix = GetMayaOutputPrefix( $camera, $layer );
	}
	return $outputPrefix;
}

//Returns the output image type (format) from the specified renderer and render element
global proc string GetImageType( string $renderer, string $renderElement )
{
	if( $renderer == "renderman22" )
	{
		return python( "dlRenderman.get_image_type( '"+$renderElement+"' )");
	}
	
	return getImfImageType();
}

//Takes a string and evaluates all renderman tokens in the string based off tokens specified.
global proc string EvaluateRendermanTokens( string $baseValue, string $tokens[] )
{
	if (size($tokens)%2 != 0)
		error -showLineNumber "Mismatched Tokens";
		
	string $tokenString = "";
	for( $i = 0; $i < size( $tokens ); $i+=2 )
	{
		$tokenString += ", " + $tokens[$i] + "='" + $tokens[$i+1] + "'";
	}
	
	return python( "dlRenderman.StringConverter.evaluateString( '" + $baseValue + "'" + $tokenString + " )");
}

//Returns Rendermans Export Directory after evaluating all tokens.
global proc string GetRendermanRibDirectory( string $layer, string $cameraName )
{
	string $base_dir = python( "dlRenderman.get_rib_directory()" );
	string $prefixString = EvaluateRendermanTokens( $base_dir, { "layer", $layer, "camera", $cameraName } );
	return CheckSlashes($prefixString);
}

//Returns Rendermans Export Prefix after evaluating all tokens.
global proc string GetRendermanRibPrefix( string $layer, string $cameraName )
{
	string $base_prefix = python( "dlRenderman.get_rib_prefix()" );
	string $prefixString = EvaluateRendermanTokens( $base_prefix, { "layer", $layer, "camera", $cameraName } );
	return CheckSlashes($prefixString);
}

//Returns Rendermans Output Directory after evaluating all tokens.
global proc string GetRendermanOutputPrefix( string $layer, string $cameraName, string $renderElement )
{
	string $base_prefix = python( "dlRenderman.get_output_prefix()" );
	string $prefixString = EvaluateRendermanTokens( $base_prefix, { "layer", $layer, "camera", $cameraName, "display", $renderElement } );
	return CheckSlashes($prefixString);
}

//Returns Rendermans Output Prefix after evaluating all tokens.
global proc string GetRendermanOutputDirectory( string $layer, string $cameraName, string $renderElement )
{
	string $base_dir = python( "dlRenderman.get_output_directory()" );
	string $outputDirectory = EvaluateRendermanTokens( $base_dir, { "layer", $layer, "camera", $cameraName, "display", $renderElement } );
	return CheckSlashes($outputDirectory);
}

//Returns an array of strings containing all Render elements that are renderable from Renderman.
global proc string[] getRendermanElements()
{
	return python( "dlRenderman.get_render_elements()");
}


// Returns the output prefix as is shown in the Render Globals, except that the frame
// number is replaced with '?' padding.
//global proc string GetOutputPrefix( int $replaceFrameNumber, int $newFrameNumber )
global proc string GetOutputPrefix( int $replaceFrameNumber, int $newFrameNumber, string $layerName, string $cameraName, string $renderElement )
{
	string $outputPrefix = "";
	string $paddingString = "";
	
	string $renderer = GetCurrentRenderer();
	
	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	
	
	if( $renderer == "vray" )
	{
		$outputPrefix = DeadlineGetVrayOutputPrefix( $multipleRenderableCams, $cameraName, $renderElement );
		
		// In V-Ray's representation, each hash character (#) represents a padded frame number
		// according to the scene's frame number padding setting.
		//
		// In Deadline's representation, a contiguous sequence of hash characters represents a
		// frame number with padding equivalent to the number of hash characters.
		// Padding String is also used for Replacing frame numbers if that is enabled.
		$paddingString = GetVRayDeadlinePaddingString();
		$outputPrefix = `substituteAllString $outputPrefix "#" $paddingString`;
	}
	else
	{
		int $paddingFound = 0;
		string $currentPrefix = `getAttr defaultRenderGlobals.imageFilePrefix`;

		// Get the first output prefix.
		string $prefixString = "";
		if( $renderer == "renderMan" || $renderer == "renderManRIS" )
		{
			//$prefixString = `rmanGetImageName 1`;
			if( $cameraName == "" || ( `checkBox -q -en frw_disableAutoCameraTag` && `checkBox -q -v frw_disableAutoCameraTag` ) )
			{
				string $pat = rmanGetImagenamePattern(1);
				string $ftext = rmanGetImageExt("");
				$prefixString= rman("assetref",
										"-cls", "Final",
										"-assetnmpat", $pat,
										"-ref", "$ASSETNAME",
										"-LAYER", $layerName,
										"-EXT", $ftext,
										"-DSPYID", "",
										"-DSPYCHAN", "");
			}
			else
			{
				string $cameraRelatives[] = `listRelatives -s $cameraName`;
			
				string $camera = $cameraRelatives[0];
				string $pat = rmanGetImagenamePattern(1);
				string $ftext = rmanGetImageExt("");
				$prefixString= rman("assetref",
										"-cls", "Final",
										"-assetnmpat", $pat,
										"-ref", "$ASSETNAME",
										"-LAYER", $layerName,
										"-CAMERA", $camera,
										"-EXT", $ftext,
										"-DSPYID", "",
										"-DSPYCHAN", "");
			}
		}
		else if($renderer == "MayaKrakatoa")
		{
			//string $prefixes[] = `renderSettings -fin`;
			string $prefixes[] = `renderSettings -fin -lyr $layerName -cam $cameraName`;

			$prefixString = $prefixes[0];

			int $forceEXROutput = `getAttr "MayaKrakatoaRenderSettings.forceEXROutput"`;
			if($forceEXROutput == 1)
			{
				string $tokens[];
				tokenize $prefixString "." $tokens;
				string $result = "";
				int $i;
				
				for($i = 0; $i<size($tokens)-1; $i++)
				{
					$result += $tokens[$i] + ".";
				}
				$prefixString = $result + "exr";
			}
		}
		else if( $renderer == "renderman22" )
		{
			string $base_prefix = python( "dlRenderman.get_output_prefix()" );
			$prefixString = EvaluateRendermanTokens( $base_prefix, { "layer", $layerName, "camera", $cameraName, "display", $renderElement } );
		}
		else
		{
			string $newPrefix = $currentPrefix;
			if( $newPrefix == "" )
			{
				$newPrefix = GetStrippedSceneFileName();
			}
			
			if( $renderer == "arnold" && `match "<RenderPass>" $newPrefix`== ""  )
			{
				$elements = getArnoldElementNames();
				
				if( $elements[0] != "" )
				{
					$newPrefix = "<RenderPass>/" + $newPrefix;
				}
			}
			
			if( $renderer == "mentalRay" && `match "<RenderPass>" $newPrefix`== ""  )
			{
				$elements = getMentalRayElementNames( $layerName );
				if( $elements[0] != "" )
				{
					$newPrefix = "<RenderPass>/" + $newPrefix;
				}
			}
			
			if( $multipleRenderableCams && ( `match "<Camera>" $newPrefix`== "" ) && ( `match "%c" $newPrefix`== "" ) )
			{
				$newPrefix = "<Camera>/" + $newPrefix;
			}
			
			if( IsRenderLayersOn() && ( `match "<RenderLayer>" $newPrefix`== "" ) && ( `match "<Layer>" $newPrefix`== "" ) && ( `match "%l" $newPrefix`== "" ) )
			{
				$newPrefix = "<RenderLayer>/" + $newPrefix;
			}
			
			//If the OutputPrefix already has a RenderPass token we want to resolve the beauty pass properly but we do not want to add a new token.
			if( $renderElement == "" && $renderer == "arnold" )
			{
				$renderElement = "beauty";
			}
			
			setAttr "defaultRenderGlobals.imageFilePrefix" -type "string" $newPrefix;
			
			//string $prefixes[] = `renderSettings -fin`;
			string $prefixes[] = `renderSettings -fin -lyr $layerName -cam $cameraName -cts ("RenderPass=" + $renderElement )`;
			$prefixString = $prefixes[0];

			setAttr "defaultRenderGlobals.imageFilePrefix" -type "string" $currentPrefix;
		}

		// Maya will automatically add a camera to the prefix, so remove it if it isn't supposed to be there
		if( $renderer != "renderMan" && $renderer != "renderManRIS" && $multipleRenderableCams && `checkBox -q -en frw_disableAutoCameraTag` && `checkBox -q -v frw_disableAutoCameraTag` && `match "<Camera>" $currentPrefix` == "" && `match "%c" $currentPrefix` == "" )
		{
			$prefixString = substituteAllString( $prefixString, $cameraName + "/", "" );
		}

		// Go through each letter of the prefix and create a new prefix with each letter
		// separated by colons, ie: f:i:l:e:n:a:m:e:.:e:x:t:
		string $prefixWithColons = "";
		for( $i = 1; $i <= size( $prefixString ); $i++ )
			$prefixWithColons += substring( $prefixString, $i, $i ) + ":";

		// Now split up the new prefix into an array, which removes all the colons and
		// places one letter in each index. Then count backwards and replace the first
		// group of numbers with the padding characters.
		string $prefix[] = stringToStringArray( $prefixWithColons, ":" );
		
		if( IsAnimatedOn() )
		{
			for( $i = size( $prefix ); $i > 0; $i-- )
			{
				if( match( "[0-9]", $prefix[$i] ) != "" )
				{
					$prefix[$i] = "#";
					$paddingString = $paddingString + "#";
					$paddingFound = 1;
				}
				else if( $paddingFound )
				{
					if( $prefix[$i] == "-" )
					{
						$prefix[$i] = "#";
						$paddingString = $paddingString + "#";
					}
					break;
				}
			}
		}
	
		// Finally, convert the prefix array back to a string.
		$outputPrefix = stringArrayToString( $prefix, "" );
		
		if( $renderer == "maxwell" && $renderElement != "" )
		{
			string $prefixParts[] = stringToStringArray( $outputPrefix, "." );
			int $numParts = size( $prefixParts );
			int $mainPart = $numParts -2;
			if( IsAnimatedOn() )
				$mainPart -= 1;
			
			$prefixParts[ $mainPart ] = $prefixParts[ $mainPart ] + "_" + $renderElement;
			
			int $extNumber = 0;			
			if( $renderElement == "zbuffer"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.depthChannelFormat`;
			}
			else if( $renderElement == "object"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.objIDChannelFormat`;
			}
			else if( $renderElement == "material"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.matIDChannelFormat`;
			}
			else if( $renderElement == "motion"  )
			{
				$extNumber = `getAttr maxwellRenderOptions.motionVectorChannelFormat`;
			}
			else if ( startsWith($renderElement, "customAlpha_") )
			{
				$extNumber = `getAttr maxwellRenderOptions.customAlphaChannelFormat`;
			}
			else
			{
				$extNumber = `getAttr( "maxwellRenderOptions." + $renderElement + "ChannelFormat")`;
			}
			$prefixParts[ $numParts -1 ] = getMaxwellChannelExtension($extNumber, true);
			$outputPrefix = stringArrayToString($prefixParts, ".");
		}
		else if( $renderer == "maxwell")
		{
			int $format = `getAttr defaultRenderGlobals.imageFormat`;
			
			$outputPrefix = `substring $outputPrefix 1 (size($outputPrefix)-3)`;
			$outputPrefix =  $outputPrefix + getMaxwellChannelExtension($format, false);
			
		}
	
	}
	
	if( IsAnimatedOn() && $replaceFrameNumber )
	{
		string $paddedFrame = "" + $newFrameNumber;
		while( size($paddedFrame) < size($paddingString) )
			$paddedFrame = "0" + $paddedFrame;
		$outputPrefix = substituteAllString( $outputPrefix, $paddingString, $paddedFrame );
	}
	
	return $outputPrefix;
}

global proc string DeadlineGetVrayOutputPrefix( int $multipleRenderableCams, string $cameraName, string $renderElement )
{
	string $outputPrefix = "";
	// Need to special case vray, because they like to do things differently.
	global string $g_vrayImgExt[];
	
	string $ext = "";
	if (`optionMenuGrp -exists vrayImageFormatMenu`)
		$ext = `optionMenuGrp -q -v vrayImageFormatMenu`;
	else
		$ext = `getAttr vraySettings.imageFormatStr`;
		if ($ext == "")
			$ext = "png";//for some reason this happens if you have not changed the format
			
	// VRay can append this to the end of the render settings display, but we don't want it in the file name.
	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	if( endsWith( $ext, $multichannel ) )
	{
		$ext = substring( $ext, 1, size( $ext ) - size( $multichannel ) );
		$isMultichannelExr = true;
	}
	
	float $version = GetVRayVersion();
	
	// We need to use eval because the definition of vrayTransformFilename is different for
	// different versions of vray, and this is the only way to get around the "incorrect
	// number of arguments" error.
	string $prefix = `getAttr vraySettings.fileNamePrefix`;
	$prefix = CheckSlashes($prefix);
	
	int $separateFolders = `getAttr "vraySettings.relements_separateFolders"`;
	
	int $separateRGBA = 0;
	if( !catchQuiet( `getAttr "vraySettings.relements_separateRGBA"` ) )
	{
		 $separateRGBA = `getAttr "vraySettings.relements_separateRGBA"`;
	}
	
	if( $prefix == "" )
	{
		$prefix = GetStrippedSceneFileName();
	}
	
	if( $renderElement != "" && $separateFolders )
	{
		string $tempPrefix = `dirname($prefix)`;
		if( $tempPrefix != "" )
		{
			$tempPrefix = $tempPrefix+ "/";
		}
		$prefix = $tempPrefix + $renderElement + "/" + basename($prefix,"");
	}
	else if( $renderElement == "" && $separateFolders && $separateRGBA  )
	{
		string $tempPrefix = `dirname($prefix)`;
		if( $tempPrefix != "" )
		{
			$tempPrefix = $tempPrefix+ "/";
		}
		$prefix = $tempPrefix + "rgba/" + basename($prefix,"");
	}
	
	if( $multipleRenderableCams && ( !`checkBox -q -en frw_disableAutoCameraTag` || !`checkBox -q -v frw_disableAutoCameraTag` ) && ( `match "<Camera>" $prefix`== "" ) && ( `match "<camera>" $prefix`== "" ) && ( `match "%c" $prefix`== "" ) )
	{
		$prefix = "<Camera>/" + $prefix;
	}
	
	if( IsRenderLayersOn() && ( `match "<Layer>" $prefix`== "" ) && ( `match "<layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
	{
		$prefix = "<Layer>/" + $prefix;
	}
	
	
	// Don't transform if the prefix is blank, so we can just default to the scene file name.
	if( $prefix != "" )
	{
		if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\", 0, 0, 0 )" ) ) )
		{
			// Vray strips off all extensions in the scene name when replacing the <Scene> tag.
			string $sceneName = GetStrippedSceneFileName();
			
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"" + $cameraName + "\", \"" + $sceneName + "\", 0, 0, 0 )" );
		}
		else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\", 0, 0 )" ) ) )
		{
			// Vray strips off all extensions in the scene name when replacing the <Scene> tag.
			string $sceneName = GetStrippedSceneFileName();
			
			if( $version <= 3.0 )
			{
				$sceneName = `basenameEx $sceneName`;
			}
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"" + $cameraName + "\", \"" + $sceneName + "\", 0, 0 )" );
		}
		else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\", 0 )" ) ) )
		{
			// Vray strips off all extensions in the scene name when replacing the <Scene> tag.
			string $sceneName = GetStrippedSceneFileName();
			if( $version <= 3.0 )
			{
				$sceneName = `basenameEx $sceneName`;
			}
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"" + $cameraName + "\", \"" + $sceneName + "\", 0 )" );
		}
		else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\", \"\" )" ) ) )
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\", \"\" )" );
		else if( !catchQuiet( eval( "vrayTransformFilename( \"\", \"\" )" ) ) )
			$prefix = eval( "vrayTransformFilename( \"" + $prefix + "\", \"\" )" );
		else
			print( "Could not evaluate output path using vrayTransformFilename, please contact Deadline support and include the version of vray you are using\n" );
	}
	
	if( $renderElement != "" && $isMultichannelExr == 0 )
	{			
		$prefix = $prefix + (`getAttr "vraySettings.fileNameRenderElementSeparator"`) + $renderElement;			
	}
	else if ( $renderElement == "" && $separateFolders && $separateRGBA && $isMultichannelExr == 0 )
	{
		$prefix = $prefix + (`getAttr "vraySettings.fileNameRenderElementSeparator"`) + "rgba";	
	}
	
	$outputPrefix = $prefix + "." + $ext;
	if( IsAnimatedOn() )
	{
		// Only add padding when not already present in the output path
		if( !`isValidString $prefix ".*#.*"` )
		{
			// When rendering to a non-raw format, vray places a period before the padding, even though it
			// doesn't show up in the render globals filename.
			if( ($ext == "vrimg" && $version < 3.6) || ($isMultichannelExr && $version < 3) )
				$outputPrefix = $prefix + "#." + $ext;
			else
				$outputPrefix = $prefix + ".#." + $ext;
		}
	}
	return $outputPrefix;
}

global proc string GetVRayDeadlinePaddingString()
{
	// Returns a Deadline style frame padding string (one hash character per frame padding)
	// based on the VRay render settings
	float $version = GetVRayVersion();
	string $paddingString = "";
	int $i;
	int $padding;

	// There was a bug in VRay before v3 where no matter what, VRay would use 4 digits
	// for padding.
	if( $version >= 3 )
		$padding = `getAttr vraySettings.fileNamePadding`;
	else
		$padding = 4;

	for( $i = 0; $i < $padding; $i ++ )
		$paddingString = $paddingString + "#";

	return $paddingString;
}

global proc string TxVrimg2exrDeadlineFilename( string $dlFilename )
{
	// Transforms a Deadline style output path pattern (using hash characters for frame padding)
	// into the format expected by the Vrimg2exr plugin when parsing the InputFile plugin info
	// option.
	//
	// Vrimg2exr detects the frame number as the right-most sequence of digits that appear before a period
	//
	// Sample inputs:
	//	TxVrimg2exrDeadlineFilename( "C:\\path\\to\\render_####.png" ) -> "C:\\path\\to\\render_0000.png"

	int $i;
	int $replacing = 0;
	int $n = size( $dlFilename );
	string $last = "";
	string $char;
	string $result = $dlFilename;

	for( $i = $n; $i > 0; $i -- )
	{
		$char = substring( $result, $i, $i );
		if( !$replacing )
		{
			if( $last == "." && $char == "#" )
				$replacing = 1;
		}
		if( $replacing )
		{
			if( $char == "#" )
				$result = substring( $result, 1, $i - 1 ) + "0" + substring( $result, $i + 1, $n );
			else
				break;
		}
		$last = $char;
	}

	return $result;
}

global proc string GetDeadlineUUID( int $length )
{
	// Generate a random UUID. Length must be between 0 and 32
	if( $length < 1 || $length > 32 )
	{
		print("Requested UUID length is less than 1 or greater than 32. Generating UUID of length 32.");
		$length = 32;
	}

	return python( "import uuid; uuid.uuid4().hex[:" + $length + "]" );
}

global proc string CreateArgumentsFile( string $argumentList[], string $jobUUID )
{
	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";
	// Submit the job to Deadline
	string $submissionCommandFile = CheckSlashes( $tempDir + "/maya_submission_" + $jobUUID + ".txt" );
	$fileId = `fopen $submissionCommandFile "w"`;
	for($argument in $argumentList)
	{
		fprint $fileId ( $argument + "\n" );
	}
	
	fclose $fileId;
	return $submissionCommandFile;
}

global proc string GetJigsawOutputPrefix(string $outputPrefix, int $region, string $renderer)
{
	string $path = dirname( $outputPrefix );
	if( $path != "" )
		$path = $path + "/";
	
	string $base = basename( $outputPrefix, "" );
	
	string $tile = "region_"+$region+"_";
	if( $renderer != "renderMan" && $renderer != "renderManRIS" )
	{
		$tile = "_" + $tile;
	}
	return $path+$tile+$base;
}

// Creates a tile prefix from the given prefix by placing the tile part at the
// beginning of the filename. It's placed at the beginning to try and avoid as
// many conflicts as possible with Maya's prefix shortcuts.
global proc string GetTileOutputPrefix( string $outputPrefix, int $x, int $y, int $xCount, int $yCount, string $renderer )
{
	string $path = dirname( $outputPrefix );
	if( $path != "" )
		$path = $path + "/";
	
	string $base = basename( $outputPrefix, "" );
	string $tile = "tile_" + $x + "x" + $y + "_" + $xCount + "x" + $yCount + "_";
	if( $renderer != "renderMan" && $renderer != "renderManRIS" )
	{
		$tile = "_" + $tile;
	}
	return $path + $tile + $base;
}

global proc string OutputPrefixAddHiddenTokens( string $layer, string $prefix )
{
	string $renderer = GetCurrentRenderer();
	
	if( $prefix == "" )
	{
		$prefix = GetStrippedSceneFileName();
	}	
	else
	{
		$prefix = CheckSlashes($prefix);
	}
	
	if( $renderer == "arnold" && `match "<RenderPass>" $prefix`== ""  )
	{
		$elements = getArnoldElementNames();
		
		if( $elements[0] != "" )
		{
			$prefix = "<RenderPass>/" + $prefix;
		}
	}
	
	if( $renderer == "mentalRay" && `match "<RenderPass>" $prefix`== ""  )
	{
		$elements = getMentalRayElementNames( $layer );
		if( $elements[0] != "" )
		{
			$prefix = "<RenderPass>/" + $prefix;
		}
	}
	
	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	//Redshift does not work with multiple renderable cameras so we need to node add <camera>
	if( $multipleRenderableCams )
	{
		// vray accepts <camera> as a token, whereas no one else does
		if( ( !`checkBox -q -en frw_disableAutoCameraTag` || !`checkBox -q -v frw_disableAutoCameraTag` ) && ( `match "<Camera>" $prefix`== "" ) && ( `match "%c" $prefix`== "" ) && $renderer != "redshift" && ( $renderer != "vray" || `match "<camera>" $prefix`== "" ) )
		{
			$prefix = "<Camera>/" + $prefix;
		}
	}
	
	if( IsRenderLayersOn() )
	{
		if( $renderer == "vray" && ( `match "<Layer>" $prefix`== "" ) && ( `match "<layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
		{
			$prefix = "<Layer>/" + $prefix;
		}
		else if($renderer != "vray" && ( `match "<RenderLayer>" $prefix`== "" ) && ( `match "<Layer>" $prefix`== "" ) && ( `match "%l" $prefix`== "" ) )
		{
			$prefix = "<RenderLayer>/" + $prefix;
		}
	}
	
	return $prefix;
	
}


global proc string GetMayaOutputPrefix( string $currCamera, string $layer )
{
	
	string $prefix = "";
	string $renderer = GetCurrentRenderer();
	
	// Source a CustomOutputPrefix.mel file, if it exists.
	string $outputPrefixPath = `getAttr defaultRenderGlobals.DeadlineMayaRepoPath` + "/CustomOutputPrefix.mel";	

	if( `file -q -exists $outputPrefixPath` )
	{
		print( "sourcing custom outputprefix file: " + $outputPrefixPath + "\n" );
		eval( "source \"" + $outputPrefixPath + "\";" );
		$prefix = GetCustomMayaOutputPrefix( $currCamera );
	}
	else
	{
		if( $renderer != "vray" )
			$prefix = `getAttr defaultRenderGlobals.imageFilePrefix`;
		else
			$prefix = `getAttr vraySettings.fileNamePrefix`;
	}
	
	return OutputPrefixAddHiddenTokens( $layer, $prefix );
	
}

// Gets the image directory for Maya.
global proc string GetImageDirectory()
{
	string $imageDir = "";
	
	// The -renderType flag is obsolete in 2013 and later.
	if( IntMayaVersion() <= 2012 )
	{
		// Relative path, get the project's image directory.
		string $fileRules[] = `workspace -q -renderType`;
		
		for( $i = 0; $i < size( $fileRules ); $i += 2 )
		{
			if( $fileRules[$i] == "images" )
			{
				$imageDir = $fileRules[$i+1];
				break;
			}
		}
	}
	else
	{
		// Relative path, get the project's image directory.
		$imageDir = `workspace -q -fileRuleEntry "images"`;
	}

	string $path = `workspace -q -fullName`;
	if( substring( $path, size( $path ), size( $path ) ) != "\\" && substring( $path, size( $path ), size( $path ) ) != "/" )
		$path = $path + "/";

	if( $imageDir == "" )
		return $path;

	if( substring( $imageDir, size( $imageDir ), size( $imageDir ) ) != "\\" && substring( $imageDir, size( $imageDir ), size( $imageDir ) ) != "/" )
		$imageDir = $imageDir + "/";
	
	// Check for an absolute path in the image directory.
	if( substring( $imageDir, 1, 1 ) == "/" || substring( $imageDir, 1, 1 ) == "\\" || substring( $imageDir, 2, 2 ) == ":" )
		$path = $imageDir;
	else
		$path = $path + $imageDir;
		
	return $path;
}

global proc int DeadlineGetRenderHalfFrames()
{
	int $halfFrames = 0;
	if( IsAnimatedOn() )
	{
		$halfFrames = (`getAttr defaultRenderGlobals.byFrameStep` == 0.5);
	}
	return $halfFrames;
}

global proc string DeadlineGetFrameList()
{
	string $renderer = GetCurrentRenderer();
	string $frameList = "";
			
	if( IsAnimatedOn() )
	{
		if( $renderer == "vray" )
		{
			int $vrayAnim = 0;
			catchQuiet( $vrayAnim = `getAttr vraySettings.animType` );
			if( $vrayAnim == 2 )
			{
				//V-Ray frame list format = "from - to, increment; from-to, increment;..."
				//Deadline frame list format = "from - to x increment, from - to x increment,;..."
				$frameList = `getAttr vraySettings.animFrames`;
				$frameList = substituteAllString($frameList, ",", "x");
				$frameList = substituteAllString($frameList, ";", ",");
				return $frameList;
			}
		}

		int $fromFrame = `getAttr defaultRenderGlobals.startFrame`;
		int $toFrame = `getAttr defaultRenderGlobals.endFrame`;
		int $byFrame = `getAttr defaultRenderGlobals.byFrameStep`;
		
		$frameList = $fromFrame;
		if( $fromFrame != $toFrame )
		{
			$frameList = $frameList + "-" + $toFrame;
			if( $byFrame > 1 )
			{
				$frameList = $frameList + "x" + $byFrame;
			}
		}
	}
	else
	{
		$frameList = `currentTime -q`;
	}

	return $frameList;
}

// Returns global resolution.
global proc int[] GetGlobalsResolution()
{
	int	$res[2] = { 320, 240 };
	
	string $renderer = GetCurrentRenderer();
	if( $renderer != "vray" )
	{
		string $globals[] = `ls -renderGlobals`;
		if( size( $globals[0] ) > 0 )
		{
			string $connect[] = `listConnections ($globals[0] + ".resolution")`;
			if( size( $connect[0] ) > 0 )
			{
				$res[0] = `getAttr ( $connect[0] + ".width" )`;
				$res[1] = `getAttr ( $connect[0] + ".height" )`;
			}
		}
	}
	else
	{
		$res[0] = `getAttr vraySettings.width`;
		$res[1] = `getAttr vraySettings.height`;
	}
	
	return $res;
}

// Returns if animation is enabled.
global proc int IsAnimatedOn()
{
	string $renderer = GetCurrentRenderer();
	
	int $anim = false;
	/*
	if( $renderer == "vray" )
	{
		if( IsOldVray() )
			$anim = `getAttr vraySettings.animation`;
		else
			$anim = `getAttr defaultRenderGlobals.animation`;
	}
	else
	*/
		$anim = `getAttr defaultRenderGlobals.animation`;
	
	return $anim;
}

// Returns if motion blur is enabled.
global proc int GetMotionBlur()
{
	string $renderer = GetCurrentRenderer();
	
	int $mb = false;
	if( $renderer == "mentalRay" )
		$mb = `getAttr miDefaultOptions.motionBlur`;
	else if( $renderer == "mayaHardware" || $renderer == "mayaHardware2" )
		$mb = `getAttr hardwareRenderGlobals.enableMotionBlur`;
	else if( $renderer == "mayaVector" )
		$mb = false;
	else if( $renderer == "turtle" )
		$mb = `getAttr TurtleRenderOptions.motionBlur`;
	else if( $renderer == "renderMan" || $renderer == "renderManRIS" )
		$mb = `getAttr renderManGlobals.rman__torattr___motionBlur`;
	else if( $renderer == "finalRender" )
		$mb = `getAttr defaultFinalRenderSettings.motionBlur`;
	else if( $renderer == "vray" )
		$mb = `getAttr vraySettings.cam_mbOn`;
	else
		$mb = `getAttr defaultRenderGlobals.motionBlur`;
	
	return $mb;
}

// Returns if render layers is on.
global proc int IsRenderLayersOn()
{
	string $renderLayers[] = `listConnections renderLayerManager.renderLayerId`;
	return ( size($renderLayers) > 1);
}

global proc string[] getRenderableRenderLayers()
{
	string $renderLayerList[] = `listConnections renderLayerManager.renderLayerId`;
	// Loop through the render layer if the checkbox is on
	string $renderableLayers[] = {};

	for( $layer in $renderLayerList )
	{
		// Only get output if the renderable attribute is on
		int $renderable = `getAttr( $layer + ".renderable" )`;
		
		if( $renderable )
		{
			
			int $isReferenceLayer = `referenceQuery -inr $layer`;
			
			if( $isReferenceLayer )
			{
				string $buffer[];
				int $numTokens = tokenize($layer, $buffer);
				if ($buffer[ $numTokens - 1 ] != "defaultRenderLayer")
				{
					stringArrayInsertAtIndex(size( $renderableLayers ), $renderableLayers, $layer );
				}
				
			}
			else
			{
				stringArrayInsertAtIndex(size($renderableLayers), $renderableLayers, $layer );
			}
		}
	}
	
	return $renderableLayers;
}

proc int ArnoldSubmitEachLayer()
{
	int $selectedIndex = `optionMenuGrp -q -select frw_deadlineArnoldRenderLayers`;
	// Maya menu group selection index is 1-based. We want 0 to be don't submit all render layers
	return $selectedIndex - 1;
}

global proc string[] deadlineGetRenderableCameras( int $ignoreDefaultCameras )
{
	string $cameraNames[] = `listTransforms -cameras`;
	string $renderableCameras[] = {};

	for( $cameraName in $cameraNames )
	{
		if( IsCameraRenderable( $cameraName ) )
		{
			string $relatives[] = `listRelatives -s $cameraName`;
			string $cameraShape = $relatives[0];
			// Only submit default cameras if the setting to ignore them is disabled.
			if( !$ignoreDefaultCameras || !IsDefaultCamera( $cameraShape ) )
			{
		
				stringArrayInsertAtIndex(size( $renderableCameras ), $renderableCameras, $cameraName );
			}
		}
	}
	
	return $renderableCameras;
}

global proc int IsDefaultCamera( string $cameraName )
{
	if( $cameraName == "frontShape" || $cameraName == "perspShape" || $cameraName == "sideShape" || $cameraName == "topShape" )
		return true;
	else if( $cameraName == "front" || $cameraName == "persp" || $cameraName == "side" || $cameraName == "top" )
		return true;
	else
		return false;
}

global proc int IsCameraRenderable( string $cameraName )
{
	//print( "Checking if camera is renderable: " + $cameraName + "\n" );
	
	string $relatives[] = `listRelatives -s $cameraName`;
	string $cameraShape = $relatives[0];
	
	int $cameraRenderable = 0;
	
	// Getting the renderable attribute can throw an error if there are duplicate camera shape names.
	// The catch blocks are to prevent these erros so that the submission can continue.
	if( !catch(`attributeExists "renderable" $cameraShape`) )
		catch($cameraRenderable = `getAttr( $cameraShape + ".renderable" )`);
	
	return $cameraRenderable;
}

// Returns if the renderer supports region rendering.
global proc int SupportsRegionRendering( string $renderer )
{ 
	return ( $renderer == "arnold" || $renderer == "mayaSoftware" ||  $renderer == "mentalRay" || $renderer == "renderman22" ||  $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "finalRender" || $renderer == "turtle" || $renderer == "vray"  || $renderer == "ifmIrayPhotoreal" || $renderer == "redshift" );
}

global proc int RegionsHaveSeparatePrefixes( string $renderer )
{
	if( $renderer == "redshift" )
		return true;
	return false;
}

global proc int TilesAreCropped( string $renderer, string $imfType )
{
	if( $renderer == "mentalRay" || $renderer == "vray" || $renderer == "ifmIrayPhotoreal" || $renderer == "redshift" || ( ( $renderer == "arnold" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "renderman22" ) && ( $imfType == "exr" || $imfType == "deepexr" ) ) )
		return true;
	return false;
}

// Returns if the y-axis for region rendering is inverted for the given renderer when compared to Jigsaw. Jig-saw's origin is "top-left"
global proc int IsRegionRenderingInverted( string $renderer )
{
	// Jigsaw has an origin of "top-left", so "bottom-left" is y-axis inversion
	return getRenderOriginLocation( $renderer ) == "bottom-left";
}

// Returns the location of the origin for the use in region rendering.
global proc string getRenderOriginLocation( string $renderer )
{
	if( $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "renderman22" || $renderer == "arnold" || $renderer == "ifmIrayPhotoreal" )
	{
		return "top-left";
	}
	else
	{
		return "bottom-left";
	}
}

global proc int getRenderExclusiveRanges( string $renderer )
{
	return ( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "renderman22" || $renderer == "ifmIrayPhotoreal" || $renderer == "ifmIrayPhotoreal" );
}

// Returns if the renderer supports the CPU option.
global proc int EnableCpuOption( string $renderer )
{
	if( IsRenderLayersOn() )
		return true;
	else
	{
		if( $renderer == "mayaSoftware" || $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "finalRender" || $renderer == "gelato" || $renderer == "maxwell" || $renderer == "vray" || $renderer == "arnold" )
			return true;
	}
	
	return false;
}

global proc CreateOptionsNode( string $renderer )
{
	if( $renderer == "arnold" )
	{
		catchQuiet(`python( "import mtoa; mtoa.core.createOptions()" )`);
	}
	else if( $renderer == "redshift" )
	{
		//The options node might not have been created yet and if it has not been created then redshiftGetAovImageName will throw an error
		catchQuiet(`redshiftGetRedshiftOptionsNode( 1 )`);
	}
}

// Returns the cpu count selected for the current render (if any).
global proc int GetCpuSetting( string $renderer )
{
	if( $renderer == "mayaSoftware" )
	{
		int $cpus = `getAttr "defaultRenderGlobals.numCpusToUse"`;
		if( $cpus > 0 )
			return $cpus;
	}
	else if( $renderer == "maxwell" )
	{
		int $cpus = `getAttr "maxwellRenderOptions.numThreads"`;
		if( $cpus > 0 )
			return $cpus;
	}
	else if( $renderer == "vray" )
	{
		int $cpus = `getAttr "vraySettings.sys_max_threads"`;
		if( $cpus > 0 )
			return $cpus;
	}
	else if( $renderer == "arnold" )
	{
		if ( `getAttr "defaultArnoldRenderOptions.threads_autodetect"` == 0 )
		{
			return `getAttr "defaultArnoldRenderOptions.threads"`;
		}
	}
	
	return 0;
}

// Returns if the renderer supports half frame rendering.
global proc int ShowHalfFramesOption( string $renderer )
{
	if( !IsRenderLayersOn() )
	{
		if( $renderer == "renderman" || $renderer == "renderManRIS" || $renderer == "renderman22" || $renderer == "vray" )
			return false;
	}
	
	return true;
}

// Opens the mental ray export settings dialog.
global proc OpenExportSettings()
{
	fileOptions "ExportAll" "projectViewer ExportAll";
}

// Launches the Maya online help
global proc OnlineHelp()
{
	CallDeadlineCommand( "-startprocess http://www.thinkboxsoftware.com/support/", false );
}

//--------------------------------------------------------
// Utility Functions
// --------------------------------------------------------

// Waits for a fixed amount of time (in milliseconds)
global proc Wait( int $waitTime )
{
	$startTime = `timerX`;
	
	while (`timerX -startTime $startTime` * 1000 < $waitTime )
	{ /* Do nothing... weeeee! */ }
}

// Returns the filename with the path and extension stripped off.
global proc string StripPathAndExt( string $fullFileName )
{
	string $fileNameNoPath = match( "[^/\\]*$", $fullFileName );
	string $fileNameOnly = match( "[^\.]*", $fileNameNoPath );
	
	return $fileNameOnly;
}

global proc string GetStrippedSceneFileName()
{
	string $fileName =`file -q -sceneName`;
	$fileName = `basename $fileName ".mb"`;
	$fileName = `basename $fileName ".ma"`;
	
	return $fileName;
}

// Ensures that all slashes are consistent throughout the filename.
global proc string CheckSlashes( string $filename )
{
	//string $result = substituteAllString( $filename, "\\", "/" ); // switch from '\' to '/'
	//$result = substituteAllString( $result, "//", "/" ); // replace double '/' where paths may have been combined
	//if( startsWith( $result, "/" ) )
	//	$result = "/" + $result;
	//return $result;
	
	string $result = $filename;
	string $newResult;
	$newResult = `substitute "\\\\" $result "/"`;
	while( $newResult != $result )
	{
		$result = $newResult;
		$newResult = `substitute "\\\\" $result "/"`;
	}
	
	$result = $newResult;
	$newResult = `substitute "//" $result "/"`;
	while( $newResult != $result )
	{
		$result = $newResult;
		$newResult = `substitute "//" $result "/"`;
	}
	
	if( `about -ntOS` )
	{
		if( startsWith( $newResult, "/" ) )
			$newResult = "/" + $newResult;
	}
	
	return $newResult;
}

// Returns true if the path is on the c:, d:, or e:.
global proc int IsLocalDrive( string $path )
{
	if( size( $path ) > 0 )
	{
		if( ( substring( $path, 1, 1) == "C" || substring( $path, 1, 1) == "c" ) ||
			( substring( $path, 1, 1) == "D" || substring( $path, 1, 1) == "d" ) ||
			( substring( $path, 1, 1) == "E" || substring( $path, 1, 1) == "e" ) )
		{
			return true;
		}
	}

	return false;
}

global proc string getDeadlineCommand()
{
	string $deadlineBin = `getenv "DEADLINE_PATH"`;
	string $deadlineCommand = "";
		
	if( $deadlineBin == "" && `about -macOS`)
	{	
		string $deadlineBinPath = "/Users/Shared/Thinkbox/DEADLINE_PATH";
		if( $deadlineBin == "" &&`filetest -f $deadlineBinPath` )
		{
			int $fileId = fopen( $deadlineBinPath, "r" );
			string $s;
			$deadlineBin = fread( $fileId, $s );
			fclose( $fileId );
		}
		
		$deadlineBin = strip( $deadlineBin );
	}
	
	if( $deadlineBin != "" )
	{
		$deadlineBin =  $deadlineBin +"/";
	}
	
	if( `about -nt` )
	{	
		$deadlineCommand = $deadlineBin + "deadlinecommand.exe";
	}
	else
	{
		$deadlineCommand = $deadlineBin + "deadlinecommand";
	}
	
	return $deadlineCommand;
}

// Calls deadlinecommand and returns the output from the command.
global proc string CallDeadlineCommand( string $command, int $showProgress )
{
	string $result = "";
	
	if( $showProgress )
		waitCursor -state on;
	
	print( "running deadline command: " + $command + "\n" );
	
	//sets the progress bar to 33%... since we can't really adjust the bar while it's loading
	if( $showProgress && `progressBar -exists frw_progBar` )
		progressBar -edit -progress (`progressBar -query -maxValue frw_progBar` / 3) frw_progBar;
	
	string $deadlineCommand = getDeadlineCommand();
	string $deadlineCommandString = "";
	
	string $prevPath = "";
	if( `about -macOS` )
	{
		$deadlineCommandString = "\""+$deadlineCommand + "\" 2> /dev/null";
		$deadlineCommandString = $deadlineCommandString + " " + $command;
	}
	else if( `about -nt` )
	{
		$deadlineBin = `getenv "DEADLINE_PATH"`;
		$deadlineCommandString = "call \"" + $deadlineCommand + "\" " + $command + " 2> nul";
		
		//Need to set the PATH, cuz windows 8 seems to load DLLs from the PATH earlier that cwd....
		$prevPath = `getenv "PATH"`;
		string $newPath = dirname( $deadlineCommand )+ ";" + $prevPath;
		putenv "PATH" $newPath;
	}
	else
	{
		$deadlineCommandString = "\"" + $deadlineCommand+ "\" " + $command + " 2> /dev/null";
	}
	
	$result = system( $deadlineCommandString );
	
	if( `about -nt` )
	{
		//restore the old PATH
		putenv "PATH" $prevPath;
	}
	
	$result = substituteAllString( $result, "\r", "" );
	
	//sets the progress bar to max (since we finished)
	if( $showProgress && `progressBar -exists frw_progBar` )
		progressBar -edit -progress `progressBar -query -maxValue frw_progBar` frw_progBar;
	
	string $resultArray[];
	$resultArray = stringToStringArray( $result, "\n" );
	//if( size($resultArray) > 2 && startsWith( $resultArray[2], "UNC paths are not supported." ) )
	if( size($resultArray) > 2 && ( startsWith( $resultArray[0], "'\\\\" ) || startsWith( $resultArray[0], "'//" ) ) )
	{
		int $tempResultArraySize = size($resultArray) - 3;
		string $tempResultArray[];
		for( $i = 0; $i < $tempResultArraySize; $i++ )
			$tempResultArray[$i] = $resultArray[$i+3];
		$result = stringArrayToString( $tempResultArray, "\n" );
	}
	
	if( endsWith( $result, "\n" ) )
		$result = substring( $result, 1, size( $result ) - 1 );
	
	if( $showProgress )
		waitCursor -state off;
	
	return $result;
}

// Quickly finds the intersection of two string arrays
global proc string[] IntersectTwoStringArray(string $firstArr[], string $secondArr[] )
{
	string $getSelection = `stringArrayIntersector`;
	stringArrayIntersector -edit -intersect $firstArr $getSelection;
	stringArrayIntersector -edit -intersect $secondArr $getSelection;

	string $intersect[] = (`stringArrayIntersector -query $getSelection`); // This is all of the selected *Geometry*
	deleteUI $getSelection;

	return $intersect;
}

global proc string GetRenderLayerDisplayName( string $layer )
{
	string $renderLayerName = $layer;
	
	if( $layer == "defaultRenderLayer" )
	{
		$renderLayerName = "masterLayer";
	}
	
	if( `exists renderLayerDisplayName`)
	{
		$renderLayerName = `renderLayerDisplayName $layer`;
	}
	
	return $renderLayerName;
}

//---------------------------------------------------------
// Functions for saving submission dialog options.
//---------------------------------------------------------

// Adds a string attribute.
global proc AddStringAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -dt "string" defaultRenderGlobals;
}

// Adds a long attribute.
global proc AddLongAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -at long defaultRenderGlobals;
}

// Adds a long attribute.
global proc AddFloatAttribute( string $attrName )
{
	if( ! `attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -at "float" defaultRenderGlobals;
}

//Adds a string array attribute
global proc AddStrArrayAttribute( string $attrName )
{
	if( !`attributeExists $attrName defaultRenderGlobals` )
		addAttr -shortName $attrName -longName $attrName -dt stringArray defaultRenderGlobals;
}

// Saves the persistent deadline options in the scene.
global proc SavePersistentDeadlineOptions()
{
	global string $ProjectPathGrp;
	global string $ImageOutputPathGrp;
	global string $StartupScriptPathGrp;
	global string $CompositeNamePathGrp;
	global string $MentalRayFilenameGrp;
	global string $VRayFilenameGrp;
	global string $LimitGroupGrp;
	global string $DependenciesGrp;
	global string $MachineListGrp;
	global string $JobNameGrp;
	
	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;
	
	global int $BlankImageCompType;
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	
	global int $deadlineGPUsPerTask;
	global int $deadlineGPUsSelectDevices;
	
	global int $irayUseCPUs;
	global float $irayCPULoad;

	global string $PipelineToolStatusLabel;
	
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	int $compType = `optionMenuGrp -q -select frw_compositeType`;
	
	string $renderer = GetCurrentRenderer();
	int $renderLayersEnabled = IsRenderLayersOn();

	AddStringAttribute( "deadlineJobName" );
	setAttr defaultRenderGlobals.deadlineJobName -type "string" `textFieldGrp -q -text frw_JobName`;
	
	AddStringAttribute( "deadlineJobComment" );
	setAttr defaultRenderGlobals.deadlineJobComment -type "string" `textFieldGrp -q -text frw_JobComment`;
	
	AddStringAttribute( "deadlineDepartment" );
	setAttr defaultRenderGlobals.deadlineDepartment -type "string" `textFieldGrp -q -text frw_Department`;

	AddStringAttribute( "deadlineGroup" );
	setAttr defaultRenderGlobals.deadlineGroup -type "string" `optionMenuGrp -q -value frw_Group`;
	
	AddStringAttribute( "deadlineJobPool" );
	setAttr defaultRenderGlobals.deadlineJobPool -type "string" `optionMenuGrp -q -value frw_deadlinePool`;
	
	AddStringAttribute( "deadlineJobSecondaryPool" );
	setAttr defaultRenderGlobals.deadlineJobSecondaryPool -type "string" `optionMenuGrp -q -value frw_deadlineSecondaryPool`;
	
	//AddLongAttribute( "deadlineUseOnlyPool" );
	//setAttr defaultRenderGlobals.deadlineUseOnlyPool `checkBox -q -v frw_poolMachinesOnly`;
	
	AddLongAttribute( "deadlineJobPriority" );
	setAttr defaultRenderGlobals.deadlineJobPriority `intSliderGrp -q -v frw_JobPriority`;
	
	AddLongAttribute( "deadlineLimitCount" );
	setAttr defaultRenderGlobals.deadlineLimitCount `intSliderGrp -q -v frw_LimitCount`;
	
	AddLongAttribute( "deadlineConcurrentTasks" );
	setAttr defaultRenderGlobals.deadlineConcurrentTasks `intSliderGrp -q -v frw_ConcurrentTasks`;
	
	AddLongAttribute( "deadlineSlaveTimeout" );
	setAttr defaultRenderGlobals.deadlineSlaveTimeout `intSliderGrp -q -v frw_SlaveTimeout`;
	
	AddLongAttribute( "deadlineMinSlaveTimeout" );
	setAttr defaultRenderGlobals.deadlineMinSlaveTimeout `intSliderGrp -q -v frw_MinSlaveTimeout`;	

	AddLongAttribute( "deadlineAutoTaskTimeout" );
	setAttr defaultRenderGlobals.deadlineAutoTaskTimeout `checkBox -q -v frw_AutoTaskTimeout`;
	
	AddStringAttribute( "deadlineLimitGroups" );
	setAttr defaultRenderGlobals.deadlineLimitGroups -type "string" `textFieldGrp -q -text frw_limitGroups`;
	
	AddStringAttribute( "deadlineMachineList" );
	setAttr defaultRenderGlobals.deadlineMachineList -type "string" `textFieldGrp -q -text frw_machineList`;
	
	AddLongAttribute( "deadlineIsBlacklist" );
	setAttr defaultRenderGlobals.deadlineIsBlacklist `checkBox -q -v frw_isBlacklist`;
	
	AddLongAttribute( "deadlineSubmitAsSuspended" );
	setAttr defaultRenderGlobals.deadlineSubmitAsSuspended `checkBox -q -v frw_submitAsSuspended`;
	
	AddLongAttribute( "deadlineCloseOnSubmission" );
	setAttr defaultRenderGlobals.deadlineCloseOnSubmission `checkBox -q -v frw_closeOnSubmission`;

	AddLongAttribute( "deadlinePrecacheAssetsForAWS" );
	setAttr defaultRenderGlobals.deadlinePrecacheAssetsForAWS `checkBox -q -v frw_precacheAssetsForAWS`;
	
	AddLongAttribute( "deadlineConductorDepScan" );
	setAttr defaultRenderGlobals.deadlineConductorDepScan `checkBox -q -v frw_conductorDepScan`;
	
	//AddLongAttribute( "deadlineDeleteOnComplete" );
	//setAttr defaultRenderGlobals.deadlineDeleteOnComplete `checkBox -q -v frw_deleteOnComplete`;
	
	AddLongAttribute( "deadlineChunkSize" );
	setAttr defaultRenderGlobals.deadlineChunkSize `intSliderGrp -q -v frw_FrameGroup`;
	
	//AddStringAttribute( "deadlineOutputFilePath" );
	//setAttr defaultRenderGlobals.deadlineOutputFilePath -type "string" `textFieldButtonGrp -q -fiame $ImageOutputPathGrp`;
	
	AddLongAttribute( "deadlineSubmitMayaScene" );
	setAttr defaultRenderGlobals.deadlineSubmitMayaScene `checkBox -q -v frw_submitMayaScene`;
	
	//AddStringAttribute( "deadlineProjectPathOverride" );
	//setAttr defaultRenderGlobals.deadlineProjectPathOverride -type "string" `textFieldButtonGrp -q -text $ProjectPathGrp`;
	
	AddLongAttribute( "deadlineNumCPUs" );
	if( EnableCpuOption( $renderer ) )
		setAttr defaultRenderGlobals.deadlineNumCPUs `intSliderGrp -q -v frw_MaxCPUs`;
	
	AddLongAttribute( "deadlineSubmitEachRenderLayer" );
	if( $renderLayersEnabled )
		setAttr defaultRenderGlobals.deadlineSubmitEachRenderLayer `checkBox -q -v frw_submitEachRenderLayer`;
	
	AddLongAttribute( "deadlineOverrideLayerSettings" );
	if( $renderLayersEnabled )
		setAttr defaultRenderGlobals.deadlineOverrideLayerSettings `checkBox -q -v frw_overrideLayerSettings`;
	
	AddLongAttribute( "deadlineSubmitEachCamera" );
	setAttr defaultRenderGlobals.deadlineSubmitEachCamera `checkBox -q -v frw_submitEachCamera`;
	
	AddLongAttribute( "deadlineIgnoreDefaultCameras" );
	setAttr defaultRenderGlobals.deadlineIgnoreDefaultCameras `checkBox -q -v frw_ignoreDefaultCameras`;
	
	AddLongAttribute( "deadlineUseMayaBatchPlugin" );
	setAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin `checkBox -q -v frw_useMayaBatchPlugin`;

	AddLongAttribute( "deadlineUseLocalAssetCaching" );
	setAttr defaultRenderGlobals.deadlineUseLocalAssetCaching `checkBox -q -v frw_useLocalAssetCaching`;
	
	AddLongAttribute( "deadlineStrictErrorChecking" );
	setAttr defaultRenderGlobals.deadlineStrictErrorChecking `checkBox -q -v frw_strictErrorChecking`;
	
	AddLongAttribute( "deadlineLocalRendering" );
	setAttr defaultRenderGlobals.deadlineLocalRendering `checkBox -q -v frw_localRendering`;
	
	AddStringAttribute( "deadlineStartupScript" );
	setAttr defaultRenderGlobals.deadlineStartupScript -type "string" `textFieldGrp -q -text frw_startupScript`;
	
	AddStringAttribute( "deadlineMayaArgs" );
	setAttr defaultRenderGlobals.deadlineMayaArgs -type "string" `textFieldGrp -q -text frw_mayaArgs`;
	
	AddLongAttribute( "deadlineTilesInX" );
	setAttr defaultRenderGlobals.deadlineTilesInX `intSliderGrp -q -v frw_tilesInX`;
	
	AddLongAttribute( "deadlineTilesInY" );
	setAttr defaultRenderGlobals.deadlineTilesInY `intSliderGrp -q -v frw_tilesInY`;
	
	AddLongAttribute( "deadlineTileSingleJob" );
	setAttr defaultRenderGlobals.deadlineTileSingleJob `checkBox -q -v frw_submitTileSingleJob`;
	
	AddLongAttribute( "deadlineTileDependentJob" );
	setAttr defaultRenderGlobals.deadlineTileDependentJob `checkBox -q -v frw_submitTileDependentJob`;
	
	AddLongAttribute( "deadlineTileCleanupJob" );
	setAttr defaultRenderGlobals.deadlineTileCleanupJob `checkBox -q -v frw_submitTileCleanupJob`;
	
	AddLongAttribute( "deadlineTileErrorOnMissing" );
	setAttr defaultRenderGlobals.deadlineTileErrorOnMissing `checkBox -q -v frw_submitTileErrorOnMissing`;
	
	AddLongAttribute( "tileMissingBackground" );
	setAttr defaultRenderGlobals.tileMissingBackground `checkBox -q -v frw_submitTileErrorOnMissingBackground`;
	
	AddStringAttribute( "deadlineMentalRayFilename" );
	setAttr defaultRenderGlobals.deadlineMentalRayFilename -type "string" `textFieldButtonGrp -q -text $MentalRayFilenameGrp`;
	
	AddLongAttribute( "deadlineSubmitMentalRayJob" );
	setAttr defaultRenderGlobals.deadlineSubmitMentalRayJob `checkBox -q -v frw_submitMentalRayJob`;
	
	AddLongAttribute( "deadlineMentalRayThreads" );
	setAttr defaultRenderGlobals.deadlineMentalRayThreads `intSliderGrp -q -v frw_mentalRayThreads`;
	
	AddLongAttribute( "deadlineMentalRayOffset" );
	setAttr defaultRenderGlobals.deadlineMentalRayOffset `intSliderGrp -q -v frw_mentalRayOffset`;
	
	AddLongAttribute( "deadlineMentalRayLocalRendering" );
	setAttr defaultRenderGlobals.deadlineMentalRayLocalRendering `checkBox -q -v frw_mentalRayLocalRendering`;
	
	AddStringAttribute( "deadlineMentalRayArgs" );
	setAttr defaultRenderGlobals.deadlineMentalRayArgs -type "string" `textFieldGrp -q -text frw_mentalRayArgs`;
	
	AddStringAttribute( "deadlineVRayFilename" );
	setAttr defaultRenderGlobals.deadlineVRayFilename -type "string" `textFieldButtonGrp -q -text $VRayFilenameGrp`;
	
	AddLongAttribute( "deadlineSubmitVRayJob" );
	setAttr defaultRenderGlobals.deadlineSubmitVRayJob `checkBox -q -v frw_submitVRayJob`;
	
	AddLongAttribute( "deadlineVRayThreads" );
	setAttr defaultRenderGlobals.deadlineVRayThreads `intSliderGrp -q -v frw_vrayThreads`;
	
	AddLongAttribute( "deadlineSubmitVrimg2ExrJob" );
	setAttr defaultRenderGlobals.deadlineSubmitVrimg2ExrJob `checkBox -q -v frw_submitVrimg2ExrJob`;
	
	AddLongAttribute( "deadlineDeleteVrimgFiles" );
	setAttr defaultRenderGlobals.deadlineDeleteVrimgFiles `checkBox -q -v frw_deleteVrimgFiles`;
	
	AddLongAttribute( "deadlineExportRenderManThreads" );
	setAttr defaultRenderGlobals.deadlineExportRenderManThreads `intSliderGrp -q -v frw_exportRenderManThreads`;
	
	AddLongAttribute( "deadlineRenderRenderManWithRis" );
	setAttr defaultRenderGlobals.deadlineExportRenderManThreads `checkBox -q -v frw_renderRenderManWithRis`;
	
	AddLongAttribute( "deadlineSubmitRenderManJob" );
	setAttr defaultRenderGlobals.deadlineSubmitRenderManJob `checkBox -q -v frw_submitRenderManJob`;

	AddLongAttribute( "deadlineRenderManFrameDependent" );
	setAttr defaultRenderGlobals.deadlineRenderManFrameDependent `checkBox -q -v frw_renderManFrameDependent`;
	
	AddLongAttribute( "deadlineRenderManThreads" );
	setAttr defaultRenderGlobals.deadlineRenderManThreads `intSliderGrp -q -v frw_rendermanThreads`;
	
	AddStringAttribute( "deadlineRenderManArgs" );
	setAttr defaultRenderGlobals.deadlineRenderManArgs -type "string" `textFieldGrp -q -text frw_rendermanArgs`;
	
	AddLongAttribute( "deadlineSubmitArnoldJob" );
	setAttr defaultRenderGlobals.deadlineSubmitArnoldJob `checkBox -q -v frw_submitArnoldJob`;

	AddLongAttribute( "deadlineArnoldLayerSubmission" );
	setAttr("defaultRenderGlobals.deadlineArnoldLayerSubmission", ArnoldSubmitEachLayer());

	AddLongAttribute( "deadlineExportArnoldLocal" );
	setAttr defaultRenderGlobals.deadlineExportArnoldLocal `checkBox -q -v frw_exportArnoldLocal`;
	
	AddLongAttribute( "deadlineExportArnoldCompressed" );
	setAttr defaultRenderGlobals.deadlineExportArnoldCompressed `checkBox -q -v frw_exportArnoldCompressed`;
	
	AddLongAttribute( "deadlineArnoldThreads" );
	setAttr defaultRenderGlobals.deadlineArnoldThreads `intSliderGrp -q -v frw_arnoldThreads`;
	
	AddStringAttribute( "deadlineArnoldArgs" );
	setAttr defaultRenderGlobals.deadlineArnoldArgs -type "string" `textFieldGrp -q -text frw_arnoldArgs`;

	AddLongAttribute( "deadlineSubmitMaxwellJob" );
	setAttr defaultRenderGlobals.deadlineSubmitMaxwellJob `checkBox -q -v frw_submitMaxwellJob`;

	AddLongAttribute( "deadlineSubmitRedshiftJob" );
	setAttr defaultRenderGlobals.deadlineSubmitRedshiftJob `checkBox -q -v frw_submitRedshiftJob`;

	AddLongAttribute( "deadlineExportRedshiftLocal" );
	setAttr defaultRenderGlobals.deadlineExportRedshiftLocal `checkBox -q -v frw_exportRedshiftLocal`;

	AddLongAttribute( "deadlineRedshiftFrameDependent" );
	setAttr defaultRenderGlobals.deadlineRedshiftFrameDependent `checkBox -q -v frw_redshiftFrameDependent`;

	AddLongAttribute( "deadlineRedshiftLayerSubmission" );
	setAttr defaultRenderGlobals.deadlineRedshiftLayerSubmission `checkBox -q -v frw_redshiftLayerSubmission`;

	AddLongAttribute( "deadlineRedshiftThreads" );
	setAttr defaultRenderGlobals.deadlineRedshiftThreads `intSliderGrp -q -v frw_redshiftThreads`;
	
	AddStringAttribute( "deadlineRedshiftArgs" );
	setAttr defaultRenderGlobals.deadlineRedshiftArgs -type "string" `textFieldGrp -q -text frw_redshiftArgs`;
	
	AddLongAttribute( "deadlineExportMaxwellLocal" );
	setAttr defaultRenderGlobals.deadlineExportMaxwellLocal `checkBox -q -v frw_exportMaxwellLocal`;

	AddLongAttribute( "deadlineMaxwellThreads" );
	setAttr defaultRenderGlobals.deadlineMaxwellThreads `intSliderGrp -q -v frw_maxwellThreads`;
	
	AddStringAttribute( "deadlineMaxwellArgs" );
	setAttr defaultRenderGlobals.deadlineMaxwellArgs -type "string" `textFieldGrp -q -text frw_maxwellArgs`;	

	AddLongAttribute( "deadlineDisableAutoCameraTag" );
	setAttr defaultRenderGlobals.deadlineDisableAutoCameraTag `checkBox -q -v frw_disableAutoCameraTag`;

	// Enable or disable some options based on current values.
	int $useMayaBatchPlugin = `checkBox -q -v frw_useMayaBatchPlugin`;
	int $submitMayaScene = `checkBox -q -v frw_submitMayaScene`;
	textFieldGrp -edit -enable $useMayaBatchPlugin frw_startupScript;
	textFieldGrp -edit -enable (!$useMayaBatchPlugin) frw_mayaArgs;
	checkBox -edit -enable (!$useMayaBatchPlugin) frw_ignoreError211;
	checkBox -edit -enable ($useMayaBatchPlugin) frw_useLocalAssetCaching;
	checkBox -edit -enable ( `optionMenuGrp -q -value frw_camera` != " " ) frw_disableAutoCameraTag;
	
	if( $renderer == "mentalRay" )
	{
		AddLongAttribute( "deadlineMentalRayAutoMemoryLimit" );
		setAttr defaultRenderGlobals.deadlineMentalRayAutoMemoryLimit `checkBox -q -v frw_autoMemoryLimit`;
		
		AddLongAttribute( "deadlineMentalRayMemoryLimit" );
		setAttr defaultRenderGlobals.deadlineMentalRayMemoryLimit `intSliderGrp -q -v frw_memoryLimit`;

		int $autoMemoryLimit = `checkBox -q -v frw_autoMemoryLimit`;
		intSliderGrp -edit -enable (!$autoMemoryLimit) frw_memoryLimit;
	}

	if( $renderer == "redshift" || $renderer == "ifmIrayPhotoreal" || $renderer == "octaneRender"  )
	{
		AddLongAttribute( "deadlineGPUsPerTask" );
		setAttr defaultRenderGlobals.deadlineGPUsPerTask `intSliderGrp -q -v frw_deadlineGPUsPerTask`;

		string $deadlineGPUsSelectDevices = `textFieldGrp -q -text frw_deadlineGPUsSelectDevices`;
		intSliderGrp -edit -enable (strcmp($deadlineGPUsSelectDevices, "") == 0) frw_deadlineGPUsPerTask;

		AddStringAttribute( "deadlineGPUsSelectDevices" );
		setAttr defaultRenderGlobals.deadlineGPUsSelectDevices -type "string" `textFieldGrp -q -text frw_deadlineGPUsSelectDevices`;

		int $deadlineGPUsPerTask = `intSliderGrp -q -v frw_deadlineGPUsPerTask`;
		textFieldGrp -edit -enable ($deadlineGPUsPerTask == 0) frw_deadlineGPUsSelectDevices;
	}
	
	if( $renderer == "vray" )
	{
		AddLongAttribute( "deadlineVrayAutoMemoryEnabled" );
		setAttr defaultRenderGlobals.deadlineVrayAutoMemoryEnabled `checkBox -q -v frw_vrayAutoMemoryEnabled`;
		
		AddLongAttribute( "deadlineVrayAutoMemoryBuffer" );
		setAttr defaultRenderGlobals.deadlineVrayAutoMemoryBuffer `intSliderGrp -q -v frw_vrayAutoMemoryBuffer`;
		
		checkBox -edit -enable $useMayaBatchPlugin frw_vrayAutoMemoryEnabled;
		
		int $vrayAutoMemoryEnabled = `checkBox -q -v frw_vrayAutoMemoryEnabled`;
		intSliderGrp -edit -enable ($useMayaBatchPlugin && $vrayAutoMemoryEnabled) frw_vrayAutoMemoryBuffer;
	}
	
	if( $renderer == "ifmIrayPhotoreal" )
	{		
		AddLongAttribute( "deadlineIRayUseCPUs" );
		setAttr defaultRenderGlobals.deadlineIRayUseCPUs `checkBox -q -v frw_irayUseCPUs`;

		int $iraySelectUseCPUs = `checkBox -q -v frw_irayUseCPUs`;

		AddFloatAttribute( "deadlineIRayCPULoad" );
		setAttr defaultRenderGlobals.deadlineIRayCPULoad  `floatSliderGrp -q -v frw_irayCPULoad`;

		floatSliderGrp -edit -enable $iraySelectUseCPUs frw_irayCPULoad;
		
	}
	
	int $regionRendering = `checkBox -q -v frw_regionRendering`;
	int $animationEnabled = IsAnimatedOn();
	if( $renderLayersEnabled )
	{
		int $submitEachRenderLayer = `checkBox -q -v frw_submitEachRenderLayer`;
		checkBox -edit -enable $submitEachRenderLayer frw_regionRendering;
		checkBox -edit -enable $submitEachRenderLayer frw_overrideLayerSettings;
		
		int $layerOverride = `checkBox -q -v frw_overrideLayerSettings`;
		
		if( $submitEachRenderLayer )
			textFieldGrp -edit -enable ($animationEnabled && $layerOverride) frw_FrameList;
		else
			textFieldGrp -edit -enable $animationEnabled frw_FrameList;
		
		if( !$submitEachRenderLayer && $regionRendering )
		{
		   $regionRendering = false;
		   checkBox -edit -v $regionRendering frw_regionRendering;
		}
	}
	else
		textFieldGrp -edit -enable $animationEnabled frw_FrameList;
	
	int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;
	checkBox -edit -enable $submitEachCamera frw_ignoreDefaultCameras;
	rowLayout -edit -visible ($regionType == $JigsawRegionRenderType) frw_jigsawRenderLayout;
	columnLayout -edit -visible ($regionType == $TileRegionRenderType) frw_tileRenderLayout;
	button -edit -enable $regionRendering frw_openJigsaw;
	text -edit -enable $regionRendering frw_jigsawLabel;
	intSliderGrp -edit -enable $regionRendering frw_tilesInX;
	intSliderGrp -edit -enable $regionRendering frw_tilesInY;
	
	checkBox -edit -enable $regionRendering frw_submitTileSingleJob;
	
	int $singleRegionRendering = `checkBox -q -v frw_submitTileSingleJob`;
	int $assemblyRendering = `checkBox -q -v frw_submitTileDependentJob`;

	//checkBox -edit -enable frw_submitTileSingleJob;
	intSliderGrp -edit -enable ($regionRendering && ($singleRegionRendering)) frw_tileSingleFrame;
	checkBox -edit -enable $regionRendering frw_submitTileDependentJob;
	checkBox -edit -enable ($regionRendering && $assemblyRendering && $regionType == $JigsawRegionRenderType) frw_submitTileErrorOnMissing;
	checkBox -edit -enable ($regionRendering && $assemblyRendering) frw_submitTileCleanupJob;

	optionMenuGrp -edit -enable ($regionRendering && $regionType == $JigsawRegionRenderType && $assemblyRendering) frw_compositeType;
	checkBox -edit -enable ($regionRendering && $compType != $BlankImageCompType && $regionType == $JigsawRegionRenderType && $assemblyRendering) frw_submitTileErrorOnMissingBackground;
	textFieldButtonGrp -edit -enable ($regionRendering && $compType != $BlankImageCompType && $regionType == $JigsawRegionRenderType && $assemblyRendering) frw_submitTileCompositeOverName;

	checkBox -edit -enable $animationEnabled frw_renderPreviewJobFirst;
	int $previewEnabled = `checkBox -q -v frw_renderPreviewJobFirst`;
	checkBox -edit -enable ($previewEnabled && $animationEnabled) frw_dependent;
	intSliderGrp -edit -enable ($previewEnabled && $animationEnabled) frw_PreviewFrames;
	intSliderGrp -edit -enable ($previewEnabled && $animationEnabled) frw_PreviewPriority;
	
	string $taskOrder = `optionMenuGrp -q -value frw_taskOrder`;
		
	int $outOfOrderStepEnabled = (strcmp($taskOrder, "Every Nth, Then Forward") == 0) || (strcmp($taskOrder, "Every Nth - Block Fill") == 0) || (strcmp($taskOrder,"Every Nth - Half Raster Refine") == 0);
	intSliderGrp -edit -enable $outOfOrderStepEnabled frw_taskOrderStep;
	
	int $submitVrayJob = `checkBox -q -v frw_submitVRayJob`;
	checkBox -edit -enable $submitVrayJob  frw_submitVrimg2ExrJob;
	checkBox -edit -enable $submitVrayJob  frw_deleteVrimgFiles;
	
	int $maxwellCoopRender = `checkBox -q -v frw_maxwellCooperativeRendering`;
	int $maxwellAutoMergeFiles = `checkBox -q -v frw_maxwellAutoMergeFiles`;

	text -edit -enable $maxwellCoopRender frw_maxwellNumCoopRendersLabel;
	intField -edit -enable $maxwellCoopRender frw_maxwellNumCoopRenders;
	checkBox -edit -enable $maxwellCoopRender frw_maxwellCoopSeparateJobs;
	checkBox -edit -enable $maxwellCoopRender frw_maxwellAutoMergeFiles;
	checkBox -edit -enable $maxwellCoopRender frw_maxwellMissingIntermediate;
	checkBox -edit -enable $maxwellCoopRender frw_maxwellDeleteIntermediate;

	if( $maxwellCoopRender )
	{
		checkBox -edit -enable $maxwellAutoMergeFiles frw_maxwellMissingIntermediate;
		checkBox -edit -enable $maxwellAutoMergeFiles frw_maxwellDeleteIntermediate;
	}
	
	int $subFramesEnabled = `checkBox -q -v frw_abcSubFrameCheck`;
	
	floatSliderGrp -edit -enable $subFramesEnabled frw_abcLowSubFrameCheck;
	floatSliderGrp -edit -enable $subFramesEnabled frw_abcHighSubFrameCheck;
	
}

global proc UpdateRegionRenderType()
{
	global int $JigsawRegionRenderType;
	global int $TileRegionRenderType;
	
	int $jobType = `optionMenuGrp -q -select frw_regionRenderType`;
	
	rowLayout -edit -enable ($jobType == $JigsawRegionRenderType) frw_jigsawRenderLayout;
	columnLayout -edit -enable ($jobType == $TileRegionRenderType) frw_tileRenderLayout;
	SavePersistentDeadlineOptions();
}

global proc UpdateCompositeType()
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	
	int $compType = `optionMenuGrp -q -select frw_compositeType`;
	
	rowLayout -edit -enable ($compType == $SelectedImageCompType) frw_compLayout;
	SavePersistentDeadlineOptions();
}

global proc UpdateJobType()
{
	global string $MayaRenderOptionsRollout;
	global string $MayaRenderOptionsArnoldRollout;
	global string $MayaRenderOptionsMentalRayRollout;
	global string $MayaRenderOptionsRedshiftRollout;
	global string $MayaRenderOptionsIRayRollout;
	global string $MayaRenderOptionsVRayRollout;
	global string $MayaRenderOptionsTileRollout;
	global string $MentalRayExportRollout;
	global string $MentalRayExportRenderJobRollout;
	global string $VrayExportRollout;
	global string $VrayExportRenderJobRollout;
	global string $VrayExportVrimgJobRollout;
	global string $RendermanExportRollout;
	global string $RendermanExportRenderJobRollout;
	global string $ArnoldExportRollout;
	global string $ArnoldExportRenderJobRollout;
	global string $MaxwellExportRollout;
	global string $MaxwellExportRenderJobRollout;
	global string $MaxwellExportCoopOptionsRollout;
	global string $RedshiftExportRollout;
	global string $RedshiftExportRenderJobRollout;
	global string $BifrostSimulationJobRollout;
	global string $AlembicExportJobRollout;
	global string $AlembicAdvancedOptionsJobRollout;
	global string $MayaScriptJobRollout;
	global string $FluidCachingJobRollout;
	global string $GeometryCachingJobRollout;
	
	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;
	global int $RedshiftExportJobType;

	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $FluidCachingJobType;
	global int $GeometryCachingJobType;
	
	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;
	string $renderer = GetCurrentRenderer();
	
	frameLayout -edit -visible ($jobType == $MayaRenderJobType) $MayaRenderOptionsRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "arnold") $MayaRenderOptionsArnoldRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "mentalRay") $MayaRenderOptionsMentalRayRollout;
	frameLayout -edit -visible ( ($jobType == $MayaRenderJobType && $renderer == "redshift") || $jobType == $RedshiftExportJobType ) $MayaRenderOptionsRedshiftRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "vray") $MayaRenderOptionsVRayRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType && $renderer == "ifmIrayPhotoreal") $MayaRenderOptionsIRayRollout;
	frameLayout -edit -visible ($jobType == $MayaRenderJobType || $jobType == $ArnoldExportJobType ) $MayaRenderOptionsTileRollout;
	
	frameLayout -edit -visible ($jobType == $MentalRayExportJobType ) $MentalRayExportRollout;
	frameLayout -edit -visible ($jobType == $MentalRayExportJobType ) $MentalRayExportRenderJobRollout;
	
	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportRollout;
	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportRenderJobRollout;
	frameLayout -edit -visible ($jobType == $VRayExportJobType ) $VrayExportVrimgJobRollout;
	
	frameLayout -edit -visible ($jobType == $RendermanExportJobType ) $RendermanExportRollout;
	frameLayout -edit -visible ($jobType == $RendermanExportJobType ) $RendermanExportRenderJobRollout;
	
	frameLayout -edit -visible ($jobType == $ArnoldExportJobType ) $ArnoldExportRollout;
	frameLayout -edit -visible ($jobType == $ArnoldExportJobType ) $ArnoldExportRenderJobRollout;
	
	frameLayout -edit -visible ($jobType == $MaxwellExportJobType ) $MaxwellExportRollout;
	frameLayout -edit -visible ($jobType == $MaxwellExportJobType ) $MaxwellExportRenderJobRollout;
	frameLayout -edit -visible ($jobType == $MaxwellExportJobType ) $MaxwellExportCoopOptionsRollout;

	frameLayout -edit -visible ($jobType == $BifrostSimulationJobType) $BifrostSimulationJobRollout;

	frameLayout -edit -visible ($jobType == $AlembicExportJobType) $AlembicExportJobRollout;
	frameLayout -edit -visible ($jobType == $AlembicExportJobType) $AlembicAdvancedOptionsJobRollout;

	frameLayout -edit -visible ($jobType == $MayaScriptJobType) $MayaScriptJobRollout;

	frameLayout -edit -visible ($jobType == $FluidCachingJobType) $FluidCachingJobRollout;

	frameLayout -edit -visible ($jobType == $GeometryCachingJobType) $GeometryCachingJobRollout;

	frameLayout -edit -visible ($jobType == $RedshiftExportJobType ) $RedshiftExportRollout;
	frameLayout -edit -visible ($jobType == $RedshiftExportJobType ) $RedshiftExportRenderJobRollout;

	optionMenuGrp -edit -en ($jobType != $RedshiftExportJobType ) frw_redshiftVerbose;
	if ($jobType == $RedshiftExportJobType)
	{
		checkBox -edit -v true frw_useMayaBatchPlugin;
	}
	checkBox -edit -en ($jobType  != $RedshiftExportJobType) frw_useMayaBatchPlugin;
}

//---------------------------------------------------------
// Functions for job submission.
//---------------------------------------------------------

proc int[] removeDuplicateIntegers(int $array[])
{
	int $index = 0;
	int $newarray[];
	for( $i = 0 ; $i < size($array) ; $i++ )
	{
		$entry = true;
		for( $j = 0 ; $j < $i ; $j++ )
		{
			if( $array[$i] == $array[$j] ) //duplicate
			{
				$entry = false;
			}
		}
		if( $entry == true )
		{
			$newarray[$index] = $array[$i];
			$index++;
		}
	}
	return $newarray;
}

proc int[] GetFramesArray(string $frameString)
{
	int $frameArray[];
	string $frameListParsed = CallDeadlineCommand( "-ParseFrameList \"" + $frameString + "\" False", false );
	
	if( startsWith( $frameListParsed, "Error:" ) )
	{
		string $result = `confirmDialog -title "Submission Error" -message ( "Failed to parse frame list.  Please ensure the frame list is valid then submit again." ) -button "OK" -defaultButton "OK"`;
		error "Deadline: Failed to parse frame list.";
	}
	
	$frameArray = python("[int(frame) for frame in '"+$frameListParsed+"'.split(',')]");
	return $frameArray;	
}

proc int[] ApplyOutOfOrder(int $frames[])
{
	string $taskOrder = `optionMenuGrp -q -value frw_taskOrder`;
	int $taskStep = `intSliderGrp -q -v frw_taskOrderStep`;
	
	if( strcmp($taskOrder, "Every Nth, Then Forward") == 0 )
	{
		int $tempFramesBefore[] = {};
		int $tempFramesAfter[] = {};
		int $frameCount = size($frames);
		for ($i = 0; $i < $frameCount; $i++)
		{
			if($i % $taskStep == 0)
				$tempFramesBefore[size($tempFramesBefore)] = $frames[$i];
			else
				$tempFramesAfter[size($tempFramesAfter)] = $frames[$i];
		}
		
		for ($i = 0; $i < size($tempFramesAfter); $i++)
		{
			$tempFramesBefore[size($tempFramesBefore)] = $tempFramesAfter[$i];
		}
		
		$frames = $tempFramesBefore;
	}
	else if(strcmp($taskOrder, "Every Nth - Block Fill" ) == 0)
	{
		int $newFrames[] = {};
		int $frameCount = size($frames); 
		int $blockSize = $frameCount/$taskStep;

		for($i=0; $i < $blockSize; $i++)
		{
			for($j=0; $j < $taskStep; $j++)
			{
				int $index = ($j * $blockSize) + $i;
				$newFrames[size($newFrames)] = $frames[$index];
			}
		}
		
		if(size($frames) > size($newFrames))
		{
			// Check that no elements have been missed
			for($i=0; $i < size($frames); $i++)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
						$found = 1;
					
				}
				if($found == 0)
					$newFrames[size($newFrames)] = $frames[$i];
			}
		}
		
		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "Every Nth - Half Raster Refine" ) == 0)
	{
		int $newFrames[] = {};
		int $frameCount = size($frames);
		int $step = $taskStep;
		
		while($step > 1)
		{
			for($i=0; $i < size($frames); $i+=$step)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
					{
						$found = 1;
					}
				}
				
				if($found == 0)
				{
					$newFrames[size($newFrames)] = $frames[$i];
				}
				
			}
			$step = $step / 2;
		}
		if(size($frames) > size($newFrames))
		{
			// Check that no elements have been missed
			for($i=0; $i < size($frames); $i++)
			{
				int $found = 0;
				for($j = 0; $j < size($newFrames); $j++)
				{
					if($newFrames[$j] == $frames[$i])
						$found = 1;
					
				}
				if($found == 0)
					$newFrames[size($newFrames)] = $frames[$i];
			}
		}
		
		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "Last To First (Reverse)" ) == 0)
	{
		int $newFrames[] = {};
		for($i=(size($frames)-1); $i >= 0; $i--)
		{
			$newFrames[size($newFrames)] = $frames[$i];
		}
		
		$frames = $newFrames;
	}
	else if(strcmp($taskOrder, "First And Last Frames First" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			$newFrames[size($newFrames)] = $frames[0];
			$newFrames[size($newFrames)] = $frames[(size($frames) - 1)];
			
			for($i=1; $i < (size($frames) - 1); $i++)
			{
				$newFrames[size($newFrames)] = $frames[$i];
			}
			
			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Both Ends" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $halfSize = size($frames) / 2;
			int $back = size($frames) - 1;
			
			for($front = 0; $front < $halfSize; $front++)
			{
				
				$newFrames[size($newFrames)] = $frames[$front];
				if(!($front >= $back))
					$newFrames[size($newFrames)] = $frames[$back];
				
				$back--;
			}
			
			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;
						
					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}
			
			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Center" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $halfSize = size($frames) / 2;
			int $back = $halfSize+1;
			while($back >= size($frames))
				$back -= 1;
			
			for($front = ($halfSize-1); $front >= 0 ; $front--)
			{
				
				$newFrames[size($newFrames)] = $frames[$front];
				if(!($front >= $back))
					$newFrames[size($newFrames)] = $frames[$back];
				
				$back++;
			}
			
			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;
						
					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}
			
			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "From Both Ends And From Center" ) == 0)
	{
		int $newFrames[] = {};
		if(size($frames) > 1)
		{
			int $theSize = size($frames);
			int $halfSize = $theSize / 2;
			
			int $front = 0;
			int $back = $theSize - 1;
			int $middleDec = $halfSize - 1;
			int $middleInc = $halfSize;
				
			while($front < $halfSize && $middleDec > $front && $back > $halfSize && $middleInc < $back)
			{
				$newFrames[size($newFrames)] = $frames[$front];
				$newFrames[size($newFrames)] = $frames[$back];
				$newFrames[size($newFrames)] = $frames[$middleDec];
				$newFrames[size($newFrames)] = $frames[$middleInc];
				
				$front++;
				$middleInc++;
				$middleDec--;
				$back--;
			}
			
			if(size($frames) > size($newFrames))
			{
				// Check that no elements have been missed
				for($i=0; $i < size($frames); $i++)
				{
					int $found = 0;
					for($j = 0; $j < size($newFrames); $j++)
					{
						if($newFrames[$j] == $frames[$i])
							$found = 1;
						
					}
					if($found == 0)
						$newFrames[size($newFrames)] = $frames[$i];
				}
			}
			
			$frames = $newFrames;
		}
	}
	else if(strcmp($taskOrder, "Random" ) == 0)
	{
		int $newFrames[] = {};
		int $usedIndices[] = {};
		int $theSize = size($frames);
		
		int $attempts = 0;
		
		for($i=0; $i < $theSize; $i++)
		{
			$usedIndices[size($usedIndices)] = 0;
		}
		
		while(size($newFrames) < size($frames) && $attempts < 30000)
		{
			int $randIndex = rand(0, $theSize);
			
			if($randIndex < $theSize)
			{
				if($usedIndices[$randIndex] == 0)
				{
					$usedIndices[$randIndex] = 1;
					$newFrames[size($newFrames)] = $frames[$randIndex];
				}
			}
			
			$attempts++;
			
		}
		
		print("Attempts = "+$attempts+"\n");
		if($attempts < 30000)
			$frames = $newFrames;
		
	}
	
	return $frames;
}

proc string FromArrayToCommaSeparatedString(int $array[])
{
	string $result = "";
	
	for($i = 0; $i < (size($array) - 1); $i++)
	{
		$result = $result + $array[$i] +",";
	}
	$result = $result + $array[size($array)-1];
	
	return $result;
}

proc string[] getXGenFiles(  )
{
	string $xgenFiles[];
	// xgen files must be stored relative to the scene
	string $collectionNames[] = `ls -type xgmPalette`;
	string $currpath;
	int $curr = 0;
	for( $i = 0; $i < size( $collectionNames ); $i++ )
	{
		$currpath = $collectionNames[$i] + ".xfn";
		if( !size( dirname( $currpath ) ) )
		{
			$xgenFiles[ $curr++ ] = ( dirname( `file -q -sn` ) + "/" + `getAttr $currpath` );
		}
	}
	return $xgenFiles;
}
//DEPRECATED
proc int[] WriteIntegrationSettings( int $fileId, int $groupBatch )
{
	print("This Function is Deprecated.");
	global string $IntegrationInfoKeys[];
	global string $IntegrationInfoValues[];
	
	string $integrationSettingsFilename = "";
	int $kvpIndex = 0;
	string $batchMode = "";
	
	int $id = stringArrayFind( "integrationSettingsPath", 0, $IntegrationInfoKeys );
	if($id >= 0)
		$integrationSettingsFilename = $IntegrationInfoValues[$id];

	$id = stringArrayFind( "extraKVPIndex", 0, $IntegrationInfoKeys );
	if($id >= 0)
		$kvpIndex = $IntegrationInfoValues[$id];

	$id = stringArrayFind( "batchMode", 0, $IntegrationInfoKeys );
	if($id >= 0)
		$batchMode = $IntegrationInfoValues[$id];
		if( $batchMode == "True" )
			$groupBatch = true;

	if( `filetest -f $integrationSettingsFilename` )
	{
		string $data = `freadAllText $integrationSettingsFilename`;
		fprint $fileId( $data );
	}


	return {$groupBatch, $kvpIndex };
}

proc string getRedshiftOutputPrefix( string $element, string $currCamera, string $layer )
{
	if( $element != "" )
	{
		string $filePrefix = `getAttr ($element+".filePrefix")`;
		if(size($filePrefix) == 0)
			return "<BeautyPath>/<BeautyFile>.<RenderPass>";
		
		if( `match "<BeautyPath>" $filePrefix` != "" )
			return $filePrefix;
		
		return OutputPrefixAddHiddenTokens( $layer, $filePrefix );
	}
	else
	{
		return GetMayaOutputPrefix( $currCamera, $layer);
	}
}

proc WriteRenderElementRegionPrefix( int $fileId, string $renderer, string $layer, string $elements[], int $isJigsaw, int $isSingleFrame, int $tileNum, int $x, int $y, int $tilesInX, int $tilesInY )
{
	if ( RegionsHaveSeparatePrefixes( $renderer ) )
	{
		int $elementNum = 0;
		for( $element in $elements )
		{
			if( $element != "")
			{
				string $rePrefix = getRedshiftOutputPrefix( $element, "", $layer );
				if( `match "<BeautyFile>" $rePrefix` == "" )
				{
					if( $isJigsaw )
					{
						$rePrefix = GetJigsawOutputPrefix($rePrefix, $tileNum, $renderer);
					}
					else
					{
						$rePrefix = GetTileOutputPrefix( $rePrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
					}
				}
				string $reString = "RenderElement" + $elementNum + "RegionPrefix";
				if( $isSingleFrame)
				{
					$reString = $reString + $tileNum;
				}
				$reString += "=" + $rePrefix + "\n";
				
				fprint $fileId ( $reString );
				
				$elementNum++;
			}
		}
	}
	
}

proc WriteRenderElementNodes( int $fileId, string $renderer, string $elements[] )
{
	if ( RegionsHaveSeparatePrefixes( $renderer ) )
	{
		int $elementNum = 0;
		for( $element in $elements )
		{
			if ($element != "")
			{
				fprint $fileId ("RenderElementNodeName" + $elementNum + "=" + $element + "\n");
				$elementNum++;
			}
		}
	}
}

// Given a string containing the multi-line standard output from a deadline command job submission,
// extracts and returns the resulting job ID
//
// Arguments:
//     string $submitResults
//         The full standard output from an invocation of Deadline command to submit a job
//
// Returns:
//     string
//         The ID of the job created by the submission
proc string parseJobIDFromSubmissionOutput( string $submitResults )
{
	string $jobId = "";
	python( "import sys" );
	int $deadlineMayaPythonLoaded = python( "\"deadline_submission\" in sys.modules" );
	if ( $deadlineMayaPythonLoaded )
	{
		if ( catch( $jobId = python( "deadline_submission.DeadlineSubmissionOutput(\"" + encodeString( $submitResults ) + "\" ).job_id" ) ) )
		{
			error "Deadline: Failed to parse job ID.";
		}
	}
	else {
		error "Could not find deadline_submission module";
	}
	return $jobId;
}

// Creates the submission files and submits the job to Deadline.
proc string WriteJobFilesAndSubmit( string $renderer, int $showDialog, int $regionRendering, int $jobType, string $cameraOverride )
{
	global string $DeadlineSubmitterWindow;
	global string $StartupScriptPathGrp;
	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;
	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $FluidCachingJobType;
	global int $GeometryCachingJobType;
	global int $RedshiftExportJobType;
	
	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;
	
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	
	// Get the deadline temp directory.
	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";
	int $maximumPriority = `getAttr defaultRenderGlobals.DeadlineMaxPriority`;
	
	// Get the output file path and prefix.
	string $outputFilePath = GetBaseOutputDirectory( $renderer );
	string $mentalRayFilename = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
	string $vrayFilename = ForceRenderLayerToken( CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` ) );
	
	// Get some initial settings.
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	
	$overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;
	
	// Append the render layer name to the job name if the submit each render layer check is on.
	string $currentRenderLayer = "";
	int $submitEachRenderLayer = false;
	string $renderLayerDisplayName = "";
	if( IsRenderLayersOn() )
	{
		$submitEachRenderLayer = `checkBox -q -value frw_submitEachRenderLayer`;
		$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		$renderLayerDisplayName = GetRenderLayerDisplayName( $currentRenderLayer );
		
		if( $jobType == $MayaRenderJobType && $submitEachRenderLayer )
		{
			if($overrideLayerSettings)
			{
				$jobField = "frw_JobName_" + $currentRenderLayer;
				$jobName = `textFieldGrp -q -text $jobField`;
			}
			else
			{
				$jobName += " - " + $renderLayerDisplayName;
			}
			
			$frameList = DeadlineGetFrameList();
		}
		else if( $jobType == $ArnoldExportJobType )
		{
			$jobName += " - " + $renderLayerDisplayName;
		}
		else if( $jobType == $RedshiftExportJobType && `checkBox -q -v frw_redshiftLayerSubmission` )
		{
			$jobName += " - " + $renderLayerDisplayName;
		}
	}
	
	// Get region rendering settings.
	string $regionLeft = 0;
	string $regionTop = 0; 
	string $regionRight = 0; 
	string $regionBottom = 0;
	int $currX = 0;
	int $currY = 0;
	int $currTile = 0;
	
	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`;
	
	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;
	int $singleRegionTiles = 0;
	string $singleRegionLeft = "";
	string $singleRegionTop = "";
	string $singleRegionRight = "";
	string $singleRegionBottom = "";
	
	// Append tile information to job name if doing a region render.
	if( $jobType == $MayaRenderJobType && $regionRendering )
	{
		if( !$singleRegionJob )
		{
			if( `attributeExists deadlineRegionLeft defaultRenderGlobals` )
			{
				$regionLeft = `getAttr defaultRenderGlobals.deadlineRegionLeft`;
			}

			if( `attributeExists deadlineRegionTop defaultRenderGlobals` ) 
			{
				$regionTop = `getAttr defaultRenderGlobals.deadlineRegionTop`;
			}

			if( `attributeExists deadlineRegionRight defaultRenderGlobals` )
			{
				$regionRight = `getAttr defaultRenderGlobals.deadlineRegionRight`;
			}

			if( `attributeExists deadlineRegionBottom defaultRenderGlobals` ) 
			{
				$regionBottom = `getAttr defaultRenderGlobals.deadlineRegionBottom`;
			}

			if( `attributeExists deadlineCurrTile defaultRenderGlobals` )
			{
				$currTile = `getAttr defaultRenderGlobals.deadlineCurrTile`;
			}

			if( `attributeExists deadlineCurrX defaultRenderGlobals` )
			{
				$currX = `getAttr defaultRenderGlobals.deadlineCurrX`;
			}

			if( `attributeExists deadlineCurrY defaultRenderGlobals` )
			{
				$currY = `getAttr defaultRenderGlobals.deadlineCurrY`;
			}
			
			if($regionType == $TileRegionRenderType)
			{
				$jobName += " (Tile " + $currTile + " : " + $currX + "x" + $currY + " of " + $tilesInX + "x" + $tilesInY + ")";
			}
			else
			{
				$jobName += " (Region " + $currTile + ")";
			}
		}
		else
		{
			if( `attributeExists deadlineRegionSingleTiles defaultRenderGlobals` ) 
			{
				$singleRegionTiles = `getAttr defaultRenderGlobals.deadlineRegionSingleTiles`;
			}

			if( `attributeExists deadlineRegionSingleLeft defaultRenderGlobals` ) 
			{
				$singleRegionLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
			}

			if( `attributeExists deadlineRegionSingleTop defaultRenderGlobals` )
			{
				$singleRegionTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
			}

			if( `attributeExists deadlineRegionSingleRight defaultRenderGlobals` )
			{
				$singleRegionRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
			}

			if( `attributeExists deadlineRegionSingleBottom defaultRenderGlobals` )
			{
				$singleRegionBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
			}
			
			$jobName += " (Frame " + $singleRegionFrame + " - " + $singleRegionTiles + " Tiles)";
		}
	}
	
	// Figure out the camera to use (if specified).
	string $camera = "";
	if( $cameraOverride != "" )
	{
		$camera = $cameraOverride;
	}
	else
	{
		string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
		string $cameraNames[] = `listTransforms -cameras`;
		for( $cameraName in $cameraNames )
		{
			if( $cameraName == $selectedCamera )
			{
				$camera = $selectedCamera;
				break;
			}
		}
	}
	
	//Check if we need to create a preview job and submit that first
	
	int $previewEnabled = `checkBox -q -value frw_renderPreviewJobFirst`;
	int $previewPriority = `intSliderGrp -q -v frw_PreviewPriority`;
	int $previewFrames = `intSliderGrp -q -v frw_PreviewFrames`;
	int $previewDependent = `checkBox -q -value frw_dependent`;
	int $frameOffset = `intSliderGrp -q -v frw_frameNumberOffset`;
	int $frameRange[] = GetFramesArray($frameList);
	int $numFrames = 0;
	int $gap = 0;
	int $previewFrameRange[];
	int $newFrameRange[];
	string $submitResults = "";
	
	if( $regionRendering )
	{
		if (!($regionRendering && $submitEachRenderLayer && !$singleRegionJob))
		{
			$previewEnabled = 0;
		}
	}
	
	if ($previewEnabled == 1)
	{
		//We need to make a preview job. The preview job needs to be a dependency of the rest of frames if that is enabled
		
		//Some checks to make things are cool
		$numFrames = size($frameRange);
		if ($numFrames > $previewFrames)
		{
			$gap = $numFrames/$previewFrames;
			
			//Build the new frame lists
			for( $i = 0; $i < $numFrames; $i++ )
			{
				if( $i % $previewFrames == 0)
				{
					$previewFrameRange[size($previewFrameRange)]=$frameRange[$i];
				}
				else
				{
					$newFrameRange[size($newFrameRange)]=$frameRange[$i];
				}
			}
			$frameRange=$newFrameRange;
		}
		else
		{
			print("Preview frame is larger or equal to the number of frames in the Job, does not make any sense to create a preview Job.");
			$previewEnabled = 0;
		}
	}
	$frameRange = ApplyOutOfOrder($frameRange);
	$previewFrameRange = ApplyOutOfOrder($previewFrameRange);
	string $assetPaths[];
	for($jobNumber = 0; $jobNumber <= $previewEnabled; $jobNumber++)
	{
	
		string $namePostFix = "";
		//Check if the Job Name needs a special postfix
		if($previewEnabled == 1)
		{
			if($jobNumber == 0)
			{
				$namePostFix = " [PREVIEW FRAMES]";
			}
			else
			{
				$namePostFix = " [REST OF FRAMES]";
			}
		}
		
		string $jobDependencies = `textFieldGrp -q -text frw_dependencies`;
		//If this is the rest of frames job, check if we need to add the previous job as a dependency
		if($previewEnabled == 1 && $previewDependent == 1 && $jobNumber == 1)
		{
		
			string $jobId = parseJobIDFromSubmissionOutput( $submitResults );
		
			if( size($jobDependencies) == 0)
			{
				$jobDependencies = $jobId+"";
			}
			else
			{
				$jobDependencies = $jobDependencies+","+$jobId;
			}
		}
		
		//Calculate the Priority
		int $jobPriority = `intSliderGrp -q -v frw_JobPriority`;
		
		if ($previewEnabled == 1 && $jobNumber == 0)
		{
			$jobPriority = $jobPriority + $previewPriority;
			
			if($maximumPriority < $jobPriority)
			{
				$jobPriority = $maximumPriority;
			}
			
		}
		
		int $hasREs = 0;
		string $REs[] = {};
		string $removableREs[] = {};
		int $isMultichannelExr = false;
		string $multichannel = " (multichannel)";
		string $ext = "";
		
		string $elements[] = {""};
		
		if( $renderer == "vray" )
		{
			$elements = getVRayElementNames();
		}
		else if ( $renderer == "arnold" ) 
		{
			$elements = getArnoldElementNames();
		}
		else if ( $renderer == "maxwell" ) 
		{
			$elements = getMaxwellElementNames();
		}
		else if ( $renderer == "redshift" )
		{
			$elements = getRedshiftElements();
		}
		else if ( $renderer == "renderman22" )
		{
			$elements = getRendermanElements();
		}

		string $jobUUID = GetDeadlineUUID( 10 );
		// Create the job info file.
		string $submitFilename = CheckSlashes( $tempDir + "/maya_deadline_info_" + $jobUUID + ".job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
		{
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
		}
		
		int $useMayaBatchPlugin = `checkBox -q -v frw_useMayaBatchPlugin`;
		if( $useMayaBatchPlugin )
		{
			fprint $fileId ( "Plugin=MayaBatch\n" );
		}
		else
		{
			fprint $fileId ( "Plugin=MayaCmd\n" );
		}
		
		if( $camera != "" )
		{
			$jobName = $jobName + " - " + $camera;
		}

		// Add job name suffix for special Maya jobs.
		if( $jobType == $BifrostSimulationJobType )
		{
			$jobName += " [Bifrost Job]";
		}
		else if( $jobType == $AlembicExportJobType )
		{
			$jobName += " [Alembic Export Job]";
		}
		else if( $jobType == $MayaScriptJobType )
		{
			$jobName += " [Script Job]";
		}
		else if( $jobType == $FluidCachingJobType )
		{
			$jobName += " [Fluid Caching Job]";
		}
		else if( $jobType == $GeometryCachingJobType )
		{
			$jobName += " [Geometry Caching Job]";
		}
		
		fprint $fileId ( "Name=" + $jobName + $namePostFix + "\n" );
		int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;
		if($submitEachRenderLayer || $submitEachCamera)
		{
			fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
		}

		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_LimitCount` + "\n" );
		fprint $fileId ( "Priority=" + $jobPriority + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_SlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MinSlaveTimeout` + "\n" );
		fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_AutoTaskTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ConcurrentTasks` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_limitGroups` + "\n" );
		fprint $fileId ( "JobDependencies=" + $jobDependencies + "\n" );
		
		if( `checkBox -q -value frw_isBlacklist` )
		{
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		}
		else
		{
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		}
		
		if( `checkBox -q -value frw_submitAsSuspended` )
		{
			fprint $fileId ( "InitialStatus=Suspended\n" );
		}
		
		if( $jobType == $MayaRenderJobType )
		{
			int $counter = 0;
			
			// Store the currently selected render layer
			string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
			string $renderLayerList[] = {""};
			if( IsRenderLayersOn() )
			{
				if( $submitEachRenderLayer )
				{
					$renderLayerList = {$currentRenderLayer};
				}
				else
				{
					
					$renderLayerList = getRenderableRenderLayers();
				}
			}
			
			// Loop through the render layer if the checkbox is on
			for( $i = 0; $i < size( $renderLayerList ); $i++ )
			{
				int $isRenderable = 0;
				if( $renderLayerList[$i] == "")
				{
					$isRenderable = 1;
				}
				else
				{
					if( !catch(`editRenderLayerGlobals -currentRenderLayer $renderLayerList[$i]`) )
					{
						$isRenderable = 1;
					}
				}
				
				if( $isRenderable )
				{
					if( $renderer == "mentalRay" )
					{
						$elements = getMentalRayElementNames( $renderLayerList[$i] );
					}
					
					string $tempOutputFilePath = $outputFilePath;
					
					string $renderableCameras[] = {};
					if( $camera != "" )
					{
						stringArrayInsertAtIndex(0, $renderableCameras, $camera );
					}
					else
					{
						$renderableCameras  = deadlineGetRenderableCameras( false );
					}
					
					if( size($renderableCameras) == 0 )
					{
						stringArrayInsertAtIndex(0, $renderableCameras, "" );
					}

					// Determine if we can represent the V-Ray output in the job info
					int $canRepresentVRayOuputInDL = 0;
					int $canRepresentVRayFilenameInDL = 0;
					if( $renderer == "vray" )
					{
						string $vrayPrefix = `getAttr vraySettings.fileNamePrefix`;
						if( !`isValidString $tempOutputFilePath ".*#.*"`)
						{
							$canRepresentVRayOuputInDL = 1;
							if( !`isValidString $vrayPrefix ".*##.*"` )
								$canRepresentVRayFilenameInDL = 1;
						}
					}

					//Redshift has it's own functions that get the output filenames
					//There are separate functions for the main pass and for AOV's
					//If multiple AOV's have the same output filename then they are merged into one file
					//As such we only want to include the files once.
					if ( $renderer == "redshift" )
					{
						for( $element in $elements )
						{
							$outputFilename = getRedshiftOutputFilename( 0, 0, $tempOutputFilePath, $element, $renderableCameras[0] );
							
							fprint $fileId ( "OutputFilename" + $counter + "=" + $outputFilename + "\n" );
							$counter += 1;
						}						
					}
					else if( $renderer == "vray" && $canRepresentVRayOuputInDL && !$canRepresentVRayFilenameInDL )
					{
						// In this code path, the user is submitting a MayaBatch render job with V-Ray, but we
						// can only represent the directory output in the job info
						fprint $fileId ( "OutputDirectory0=" + CheckSlashes( $tempOutputFilePath ) + "\n" );
					}
					// Bypass when V-Ray is the renderer and the output cannot represent using Deadline's format
					else if( $renderer != "vray" || $canRepresentVRayOuputInDL )
					{
						for( $cameraName in $renderableCameras )
						{
							
							for($element in $elements)
							{
								string $outputPrefix = "";
								$outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayerList[$i], $cameraName, $element ) );
								$outputPrefix = swapDeepExr( $outputPrefix );
								
								if( $renderer == "renderman22" )
								{
									$tempOutputFilePath = GetRendermanOutputDirectory( $renderLayerList[$i], $cameraName, $element );
								}
								
								if( $jobType == $MayaRenderJobType && $regionRendering )
								{
									if( !$singleRegionJob )
									{
										if($regionType ==$TileRegionRenderType)
										{
											$outputPrefix = GetTileOutputPrefix( $outputPrefix, $currX, $currY, $tilesInX, $tilesInY, $renderer );
										}
										else
										{
											$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $currTile, $renderer );
										}
										fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $tempOutputFilePath + "/" + $outputPrefix ) + "\n" );
									}
									else
									{
										$outputPrefix = GetOutputPrefix( 1, $singleRegionFrame, $renderLayerList[$i], $cameraName, $element );
										$outputPrefix = swapDeepExr( $outputPrefix );
										
										if($regionType == $TileRegionRenderType)
										{
											int $tileNum = 0;
											for( $y = 1; $y <= $tilesInY; $y++ )
											{
												for( $x = 1; $x <= $tilesInX; $x++ )
												{
													string $tempFilePrefix = GetTileOutputPrefix( $outputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
													fprint $fileId ( "OutputFilename" + $counter + "Tile"+$tileNum+"=" + CheckSlashes( $tempOutputFilePath + "/" + $tempFilePrefix ) + "\n" );
													$tileNum++;
												}
											}
										}
										else
										{
											for( $tileNum = 0; $tileNum < $singleRegionTiles; $tileNum++ )
											{
												
												string $tempFilePrefix = GetJigsawOutputPrefix( $outputPrefix, $tileNum, $renderer );
												fprint $fileId ( "OutputFilename" + $counter + "Tile"+$tileNum+"=" + CheckSlashes( $tempOutputFilePath + "/" + $tempFilePrefix ) + "\n" );
											}
										}
									}
								}
								else
								{
									fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $tempOutputFilePath + "/" + $outputPrefix ) + "\n" );
								}
								$counter += 1;
							}
						}
					}
				}
			}
			// Reselect the current render layer
			editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			
		}
		else if( $jobType == $MentalRayExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + dirname( $mentalRayFilename ) + "\n" );
		}
		else if( $jobType == $VRayExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + dirname( $vrayFilename ) + "\n" );
		}
		else if( $jobType == $RendermanExportJobType )
		{
			if( $renderer == "renderman22" )
			{	
				
				fprint $fileId ( "OutputDirectory0=" + GetRendermanRibDirectory( $currentRenderLayer, $camera ) + "\n" );
			}
			else
			{
				fprint $fileId ( "OutputDirectory0=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` + "/renderman/" + GetStrippedSceneFileName() ) + "\n" );
			}
		}
		else if( $jobType == $ArnoldExportJobType || $jobType == $MaxwellExportJobType )
		{
			string $assExportFolder = `workspace -fre "ASS"`;
			if( $assExportFolder == "" )
			{
				$assExportFolder = "data";
			}
			
			fprint $fileId ( "OutputDirectory0=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` + "/" + $assExportFolder ) + "\n" );
		}
		else if( $jobType == $RedshiftExportJobType )
		{
			fprint $fileId ( "OutputDirectory0=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` + "/redshift/" ) + "\n" );
		}
		
		$frameList = FromArrayToCommaSeparatedString($frameRange);
		if($jobNumber == 0 && $previewEnabled == 1)
		{
			$frameList = FromArrayToCommaSeparatedString($previewFrameRange);
		}

		if( $jobType == $MayaRenderJobType && $regionRendering && $singleRegionJob )
		{
			//fprint $fileId ( "Frames=0-" + ($singleRegionTiles-1) + "\n" );
			//fprint $fileId ( "ChunkSize=1\n" );
			fprint $fileId ( "TileJob=True\n" );
			fprint $fileId ( "TileJobFrame=" + $singleRegionFrame + "\n" );
			
			if( $regionType == $TileRegionRenderType)
			{
				fprint $fileId ( "TileJobTilesInX=" + $tilesInX + "\n" );
				fprint $fileId ( "TileJobTilesInY=" + $tilesInY + "\n" );
			}
			else
			{
				fprint $fileId ( "TileJobTilesInX=" + $singleRegionTiles + "\n" );
				fprint $fileId ( "TileJobTilesInY=1\n" );
			}
				
		}
		else
		{	   
			//TODO, what do I do with this nonsense when submitting a preview job
			if( $jobType == $MayaRenderJobType && $submitEachRenderLayer )
			{
				if($overrideLayerSettings)
				{
					$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
					
					$field = "frw_FrameList_" + $currentRenderLayer;
					fprint $fileId ( "Frames=" + `textFieldGrp -q -text $field` + "\n" );
					
					$field = "frw_FrameGroup_" + $currentRenderLayer;
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v $field` + "\n" );
				}
				else
				{
					fprint $fileId ( "Frames=" + $frameList + "\n" );
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v frw_FrameGroup` + "\n" );
				}
			}
			else
			{
				if( ( $jobType == $ArnoldExportJobType && $regionRendering && $singleRegionJob ) )
				{
					fprint $fileId ( "Frames=" + $singleRegionFrame + "\n" );
				}
				else
				{
					fprint $fileId ( "Frames=" + $frameList + "\n" );
				}
				
				// Regular renders and Arnold exports can be split across machines, but other exports (AFAIK) must be done on a single machine.
				if( $jobType == $MayaRenderJobType || $jobType == $ArnoldExportJobType || $jobType == $MaxwellExportJobType || $jobType == $RendermanExportJobType || $jobType == $RedshiftExportJobType )
				{
					fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -v frw_FrameGroup` + "\n" );
				}
				else
				{
					fprint $fileId ( "ChunkSize=100000\n" );
				}
			}
		}
		
		if( $jobType == $MayaRenderJobType && $regionRendering && $useMayaBatchPlugin && $renderer == "vray" )
		{
			fprint $fileId ( "ForceReloadPlugin=True\n" );
		}
		
		$kvpIndex = 0;
		$groupBatch = false;
		$dependentJob = false;
		int $submitDependentRegionJob = `checkBox -q -v frw_submitTileDependentJob`;
		if( $regionRendering && $submitDependentRegionJob)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDependentVRrayJob = `checkBox -q -v frw_submitVRayJob`;
		if($jobType == $VRayExportJobType && $submitDependentVRrayJob)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDependentArnold = `checkBox -q -v frw_submitArnoldJob`;
		if($jobType == $ArnoldExportJobType && $submitDependentArnold)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDependentMaxwell = `checkBox -q -v frw_submitMaxwellJob`;
		if( $jobType == $MaxwellExportJobType && $submitDependentMaxwell )
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDepRenderMan = `checkBox -q -v frw_submitRenderManJob`;
		if($jobType == $RendermanExportJobType && $submitDepRenderMan)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDepMentalRay = `checkBox -q -v frw_submitMentalRayJob`;
		if($jobType == $MentalRayExportJobType && $submitDepMentalRay)
		{
			$groupBatch = true;
			$dependentJob = true;
		}
		int $submitDepRedShift = `checkBox -q -v frw_submitRedshiftJob`;
		if($jobType == $RedshiftExportJobType && $submitDepRedShift)
		{
			$groupBatch = true;
			$dependentJob = true;
		}


		if ( $groupBatch )
		{
			string $batchName = `textFieldGrp -q -text frw_JobName`;
			//This will group the jobs created later in the same batch
			fprint $fileId ( "BatchName=" + $batchName + "\n" );
		}
		
		$assetPaths = FindAssetPaths();
		// We wanna add the scene file to the asset paths if we're not submitting it so that we can precache it
		if( !`checkBox -q -value frw_submitMayaScene` )
		{
			stringArrayInsertAtIndex( size( $assetPaths ), $assetPaths, CheckSlashes( `file -q -sceneName` ) );
		}
		WriteAssetPathsToJobFile( $assetPaths, $fileId );
		
		fclose $fileId;
		
		// Create the plugin info file.
		string $jobFilename = CheckSlashes( $tempDir + "/maya_deadline_job_" + $jobUUID + ".job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
		{
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		}
		
		// If animation is enabled.
		fprint $fileId ( "Animation=" + IsAnimatedOn() + "\n" );
		
		fprint $fileId ( "RenderSetupIncludeLights=" + GetRenderSetupIncludeLights() + "\n" );
		
		if( $jobType == $MentalRayExportJobType )
		{
			fprint $fileId ( "Renderer=mentalRayExport\n" );
			fprint $fileId ( "UsingRenderLayers=false\n" );
			
			global string $gExportFilterCheckBoxes[];
			global string $gExportPathesCheckBoxes[];
			
			fprint $fileId ( "MentalRayExportfile=" + $mentalRayFilename + "\n" );
			fprint $fileId ( "MentalRayExportBinary=" + ((`radioButton -query -select MayatomrExport_Binary`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportTabStop=" + ($tabstop = `intField -query -value MayatomrExport_TabSize`) + "\n" );
			
			int $perframe = 0;
			int $padframe = 0;
			if(`checkBoxGrp -query -value1 MayatomrExport_FilePerFrame`)
			{
				$perframe = `optionMenuGrp -q -select MayatomrExport_FrameExtension`;
				$padframe = `intFieldGrp -q -value1 MayatomrExport_FramePadding`;
				if ($padframe > 9)
				{
					$padframe = 9;
				}
			}
			
			fprint $fileId ( "MentalRayExportPerFrame=" + $perframe + "\n" );
			fprint $fileId ( "MentalRayExportPadFrame=" + $padframe + "\n" );
			fprint $fileId ( "MentalRayExportPerLayer=" + `checkBoxGrp -query -value1 MayatomrExport_FilePerLayer` + "\n" );
			
			$pathnames = "";
			if(`checkBoxGrp -query -value1 MayatomrExport_Pathes`)
			{
				for( $cnt=0; $cnt < size( $gExportPathesCheckBoxes ); $cnt++ )
				{
					$pathnames += `optionMenuGrp -query -sl $gExportPathesCheckBoxes[$cnt]`;
				}
			}
			else
			{
				$pathnames = "n";
			}
			
			fprint $fileId ( "MentalRayExportPathNames=" + $pathnames + "\n" );
			
			$fragment = (`optionMenuGrp -q -select MayatomrExport_Fragment`-1);
			fprint $fileId ( "MentalRayExportFragment=" + $fragment + "\n" );
			fprint $fileId ( "MentalRayExportFragmentMaterials=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentMaterials`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportFragmentShaders=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentIncomingShdrs`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportFragmentChildDag=" + ((`checkBoxGrp -q -v1 MayatomrExport_FragmentChildDag`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportPassContributionMaps=" + ((`checkBoxGrp -q -v1 MayatomrExport_PassContributionMaps`) ? 1 : 0) + "\n" );
			fprint $fileId ( "MentalRayExportPassUserData=" + ((`checkBoxGrp -q -v1 MayatomrExport_PassUserData`) ? 1 : 0) + "\n" );
			
			$filter = "";
			if(`checkBoxGrp -query -value1 MayatomrExport_Filters`)
			{
				for($cnt=0; $cnt<size($gExportFilterCheckBoxes); $cnt++)
				{
					$filter += (`checkBoxGrp -query -value1 $gExportFilterCheckBoxes[$cnt]`) ? "0" : "1";
				}
			}
			
			fprint $fileId ( "MentalRayExportFilterString=" + $filter + "\n" );
		}
		else if( $jobType == $VRayExportJobType )
		{
			fprint $fileId ( "Renderer=vrayExport\n" );
			fprint $fileId ( "VRayExportFile=" + $vrayFilename + "\n" );
		}
		else if( $jobType == $RendermanExportJobType )
		{
			
			fprint $fileId ( "MaxProcessors=" + `intSliderGrp -q -v frw_exportRenderManThreads` + "\n" );
			
			fprint $fileId ( "RenderWithRis=" + `checkBox -q -v frw_renderRenderManWithRis` + "\n" );
			
			if( $renderer == "renderman22" )
			{
				fprint $fileId ( "Renderer=renderman22Export\n" );
				fprint $fileId ( "RIBDirectory=" + python( "dlRenderman.get_rib_directory()" ) + "\n" );
				fprint $fileId ( "RIBPrefix=" + python( "dlRenderman.get_rib_prefix()" )+ "\n" );
			}
			else
			{
				fprint $fileId ( "Renderer=rendermanExport\n" );
			}
		}
		else if( $jobType == $ArnoldExportJobType )
		{
			fprint $fileId ( "Renderer=arnoldExport\n" );
			int $exportCompressed = `checkBox -q -v frw_exportArnoldCompressed`;
			fprint $fileId( "ArnoldExportCompressed=" + $exportCompressed + "\n" );
			if( IsRenderLayersOn() )
			{
				fprint $fileId ( "RenderLayer=" + `editRenderLayerGlobals -q -crl` + "\n" );
			}
		}
		else if( $jobType == $MaxwellExportJobType )
		{
			fprint $fileId ( "Renderer=maxwellExport\n" );
			
			string $outputScript = `textFieldButtonGrp -q -text frw_maxwellScriptName`;
			if($cameraOverride != "")
			{
				string $base = basenameEx( $outputScript );
				string $folder = substituteAllString($outputScript,basename($outputScript,""),"");
				string $ext = fileExtension( $outputScript );
				
				$outputScript = $folder+$base+"_"+$cameraOverride+"."+$ext;
			}
			
			fprint $fileId ( "MaxwellMXSFile=" + $outputScript + "\n" );
		}
		else if( $jobType == $RedshiftExportJobType )
		{
			fprint $fileId ( "Renderer=redshiftExport\n" );
			if( IsRenderLayersOn() )
			{
				fprint $fileId ( "RenderLayer=" + `editRenderLayerGlobals -q -crl` + "\n" );
			}
		}
		else if( $jobType == $BifrostSimulationJobType )
		{

			fprint $fileId ( "BifrostJob=True\n" );

			string $cacheOutDir = CheckSlashes( `textFieldGrp -q -text frw_bifrostCacheDir` );
			fprint $fileId( "OutputFilePath=" + $cacheOutDir + "\n" );

			if(IntMayaVersion() > 2015)
			{
				string $formatIndex = (string)((`optionMenuGrp -q -select frw_biFrostCompressionFormat`)-1); // Change index from 1-3 to 0-2
				fprint $fileId( "BifrostCompressionFormat=" + $formatIndex + "\n" );
			}
		}
		else if( $jobType == $AlembicExportJobType )
		{
			string $alembicAttrs[] = { "frw_verboseCheck", "frw_noNormalsCheck", "frw_renderableOnlyCheck",
									   "frw_stripNamespacesCheck", "frw_uvWriteCheck", "frw_writeColorSetsCheck", 
									   "frw_writeFaceSetsCheck", "frw_wholeFrameGeoCheck", "frw_worldSpaceCheck", 
										"frw_writeVisibilityCheck", "frw_filterEulerRotationsCheck", "frw_writeCreasesCheck" };

			string $alembicOutFile = CheckSlashes(`textFieldGrp -q -text frw_alembicExportFile` );

			fprint $fileId ( "AlembicJob=True\n" );
			fprint $fileId( "OutputFile=" + basename( $alembicOutFile, "" ) + "\n" );
			
			for($i = 0; $i<size($alembicAttrs); $i++)
			{
				if(`checkBox -q -v $alembicAttrs[$i]`)
				{
					string $checkedItem = substituteAllString(`checkBox -q -label $alembicAttrs[$i]`, " ", "" );
					fprint $fileId( $checkedItem + "=True\n" );
				}
			}
			
			if( `checkBox -q -v frw_abcSubFrameCheck` )
			{
				fprint $fileId ( "AlembicSubFrames=True\n" );
				fprint $fileId( "AlembicLowSubFrame=" + `floatSliderGrp -q -v frw_abcLowSubFrameCheck` + "\n" );
				fprint $fileId( "AlembicHighSubFrame=" + `floatSliderGrp -q -v frw_abcHighSubFrameCheck` + "\n" );
			}
			
			fprint $fileId( "AlembicAttributes=" + `textFieldGrp -q -text frw_abcDynamicAttributes` + "\n" );
			fprint $fileId( "AlembicAttributePrefix=" + `textFieldGrp -q -text frw_abcDynamicAttributePrefix` + "\n" );
			
			// if index == 1, use HDF, else use Ogawa
			if( `optionMenuGrp -q -sl frw_alembicFormat` == 1 )
			{
				fprint $fileId( "AlembicFormatOption=HDF\n" );
			}
			else
			{
				fprint $fileId( "AlembicFormatOption=Ogawa\n" );	
			}

			fprint $fileId( "OutputFilePath="+ CheckSlashes( dirname( $alembicOutFile ) ) + "\n" );

			// AlembicExportSelection
			string $alembicSelection = "All";
			string $items[] = `ls -sl -l`;

			if( `radioButtonGrp -q -select frw_AlembicExportSelection` == 2 && size( stringArrayRemove( $items, `ls -l` ) ) )
			{
				$alembicSelection = "";
				for($item in $items)
				{
					$alembicSelection += ( $item + "," );
				}
				$alembicSelection = `substring $alembicSelection 1 (size($alembicSelection)-1)`; // Chop off the last comma
			}
			fprint $fileId( "AlembicSelection=" + $alembicSelection + "\n" );
		}
		else if( $jobType == $MayaScriptJobType )
		{
			fprint $fileId ( "ScriptJob=True\n" );

			string $fullfile = `textFieldGrp -q -text frw_mayaScriptJob`;
			string $result = basename( $fullfile, "" );
			fprint $fileId ( "ScriptFilename=" + $result +"\n");
		}
		// Fluid and Geometry caching is very similar. This would be easy to form into generalized nCaching (along with nCaching, nParticles, nCloth, nHair) in the future
		else if( $jobType == $FluidCachingJobType )
		{
			// This will be handled in a similar fashion to Geometry caching
			string $fluidCacheOutDir = `textFieldButtonGrp -q -text frw_FluidCacheOutputDir`;
			string $fileDists[] = { "True", "False" };

			fprint $fileId ( "FluidCacheJob=True\n" );

			fprint $fileId ( "FluidCacheFileName=" + `textFieldGrp -q -text frw_FluidCacheFileName` + "\n" );
			fprint $fileId ( "OutputFilePath=" + $fluidCacheOutDir  + "\n" );
			fprint $fileId ( "CacheFormat=" + `optionMenuGrp -q -value frw_FluidCacheFormat` + "\n" );
			fprint $fileId ( "OneFilePerFluid=" + `checkBox -q -value frw_FluidCacheSplitCheck` + "\n" );
			fprint $fileId ( "OneFilePerFrame=" + $fileDists[int(`radioButtonGrp -q -select frw_FluidCacheFileDistRadio`)-1] + "\n" );

			string $selection = "All";
			string $fluids[] = `listTransforms "-type fluidShape"`;
			string $sels[] = `ls -sl`;

			string $selectedFluids[] = IntersectTwoStringArray($fluids, $sels);

			if( size( stringArrayRemove( $selectedFluids, $fluids ) ) ) // There is a difference between the selected fluids and all fluids in the scene. Therefore we have not selected everything
			{
				$selection = "";
				for($item in $selectedFluids)
				{
					$selection += $item + ",";
				}
				$selection = `substring $selection 1 (size($selection)-1)`; // Chop off the last comma
			}

			fprint $fileId ( "SelectedFluids=" + $selection + "\n" );

		}
		else if( $jobType == $GeometryCachingJobType )
		{
			string $GeometricCacheOutDir = `textFieldGrp -q -text frw_GeometricCacheOutputDir`;
			string $fileDists[] = { "True", "False" };
			string $dblOrFlt[] = { "Double", "Float" };
			string $storePts[] = { "Local", "World" };

			fprint $fileId ( "GeometryCacheJob=True\n" );
			fprint $fileId ( "OutputFilePath=" + $GeometricCacheOutDir  + "\n" );					
			fprint $fileId ( "OneFilePerFrame=" + $fileDists[int(`radioButtonGrp -q -select frw_GeometricCacheFileDistRadio`)-1] + "\n" );
			fprint $fileId ( "SavePointsAs=" + $dblOrFlt[int(`radioButtonGrp -q -select frw_GeometricCacheDblOrFltRadio`)-1] + "\n" );
			fprint $fileId ( "SavePointsIn=" + $storePts[int(`radioButtonGrp -q -select frw_GeometricCacheLocOrWldRadio`)-1] + "\n" );
			fprint $fileId ( "OneFilePerGeometry=" + `checkBox -q -value frw_GeometricCacheSplitCheck` + "\n" );
			fprint $fileId ( "CacheFormat=" + `optionMenuGrp -q -value frw_GeoCacheFormat` + "\n" );
			fprint $fileId ( "GeoCacheFileName=" + `textFieldGrp -q -text frw_GeoCacheFileName` + "\n" );

			string $selection = "All"; // default is all Geometry selected
			string $geos[] = `listTransforms -geometry`;
			string $sels[] = `ls -sl`;

			string $selectedGeos[] = IntersectTwoStringArray($geos, $sels); // This is all of the selected Geometry
			
			if( size( stringArrayRemove( $selectedGeos, $geos ) ) ) // There is a difference between the selected Geometry and all the Geometry. Therefore we have not selected everything
			{
				// reassign the string and set up the actual selection
				$selection = "";
				for($item in $selectedGeos)
				{
					$selection += $item + ",";
				}
				$selection = `substring $selection 1 (size($selection)-1)`; // Chop off the last comma
			}
			
			fprint $fileId ( "SelectedGeometry=" + $selection + "\n" );
		}
		else
		{
			fprint $fileId ( "Renderer=" + $renderer + "\n" );
			fprint $fileId ( "UsingRenderLayers=" + IsRenderLayersOn() + "\n" );
			fprint $fileId ( "RenderLayer=" + $currentRenderLayer + "\n" );
			
			int $renderHalfFrames = ShowHalfFramesOption( $renderer ) ? `checkBox -q -value frw_renderHalfFrames` : 0;
			fprint $fileId ( "RenderHalfFrames=" + $renderHalfFrames + "\n" );
			
			fprint $fileId ( "FrameNumberOffset=" + $frameOffset + "\n" );
			
			int $localRendering = `checkBox -q -value frw_localRendering` && `checkBox -q -enable frw_localRendering`;
			fprint $fileId ( "LocalRendering=" + $localRendering + "\n" );
			
			int $strictErrorChecking = `checkBox -q -value frw_strictErrorChecking`;
			fprint $fileId ( "StrictErrorChecking=" + $strictErrorChecking + "\n" );
			
			if( $regionRendering )
			{
				fprint $fileId ( "RegionRendering=True\n" );
				
				WriteRenderElementNodes( $fileId, $renderer, $elements );
				
				if( !$singleRegionJob )
				{
					fprint $fileId ( "RegionLeft=" + $regionLeft + "\n" );
					fprint $fileId ( "RegionTop=" + $regionTop + "\n" );
					fprint $fileId ( "RegionRight=" + $regionRight + "\n" );
					fprint $fileId ( "RegionBottom=" + $regionBottom + "\n" );
				}
				else
				{
					
					//fprint $fileId ( "RegionSingleJob=True\n" );
					//fprint $fileId ( "RegionSingleFrame=" + $singleRegionFrame + "\n" );
					fprint $fileId ( $singleRegionLeft + "\n" );
					fprint $fileId ( $singleRegionTop + "\n" );
					fprint $fileId ( $singleRegionRight + "\n" );
					fprint $fileId ( $singleRegionBottom + "\n" );
					
					if($regionType == $JigsawRegionRenderType)
					{
						for( $tileNum = 0; $tileNum < $singleRegionTiles; $tileNum++ )
						{
							string $outputFilePrefix = "";
							if( $renderer == "renderman22" )
							{
								$outputFilePrefix = python( "dlRenderman.get_output_directory()" );
							}
							else
							{
								$outputFilePrefix = GetMayaOutputPrefix( $camera, $currentRenderLayer );
							}
							$outputFilePrefix = GetJigsawOutputPrefix($outputFilePrefix, $tileNum, $renderer);
							
							fprint $fileId ("RegionPrefix" + $tileNum + "=" + $outputFilePrefix + "\n");
							
							WriteRenderElementRegionPrefix( $fileId, $renderer, $currentRenderLayer, $elements, 1, 1, $tileNum, 0,0,0,0 );
							
						}
					}
					else
					{
						int $tileNum = 0;
						for( $y = 1; $y <= $tilesInY; $y++ )
						{
							for( $x = 1; $x <= $tilesInX; $x++ )
							{
								string $outputFilePrefix = GetBaseOutputPrefix($renderer, $camera, $currentRenderLayer);
								$outputFilePrefix = GetTileOutputPrefix( $outputFilePrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
								
								// Renderman strips the leading '_' from output file names, so we need to add an additional one.
								//if( $renderer == "renderMan" || $renderer == "renderManRIS" )
								//	$outputFilePrefix = "_" + $outputFilePrefix;
								
								fprint $fileId ("RegionPrefix" + $tileNum + "=" + $outputFilePrefix + "\n");
								
								WriteRenderElementRegionPrefix( $fileId, $renderer, $currentRenderLayer, $elements, 0, 1, $tileNum, $x, $y, $tilesInX, $tilesInY );
								
								$tileNum++;
							}
						}
					}
				}
			}
			
			if( EnableCpuOption( $renderer ) )
			{
				fprint $fileId ( "MaxProcessors=" + `intSliderGrp -q -v frw_MaxCPUs` + "\n" );
			}
			
			if( $renderer == "mayaSoftware" )
			{
				// render globals qualification
				string $rendQual[] = `listConnections defaultRenderGlobals.qual`;
				
				// get antialising quality level and turn it into a string
				string $strAntialiasing = "highest";
				int $intAntialiasing = `getAttr ($rendQual[0] + ".edgeAntiAliasing")`;
				if ( $intAntialiasing == 1 )
				{
					$strAntialiasing = "high";
				}

				if ( $intAntialiasing == 2 )
				{
					$strAntialiasing = "medium";
				}

				if ( $intAntialiasing == 3 )
				{
					$strAntialiasing = "low";
				}
				
				fprint $fileId ( "AntiAliasing=" + $strAntialiasing + "\n" );
			}
			
			// Krakatoa options currently only supported by the MayaBatch plugin.
			if( $useMayaBatchPlugin && $renderer == "MayaKrakatoa")
			{
				string $boolVal = "";
				float $krakatoaFinalPassDensity = `getAttr "MayaKrakatoaRenderSettings.finalPassDensity"`;
				fprint $fileId ( "KrakatoaFinalPassDensity="+ $krakatoaFinalPassDensity + "\n" );
				
				int $krakatoaFinalPassDensityExponent = `getAttr "MayaKrakatoaRenderSettings.finalPassDensityExponent"`;
				fprint $fileId ( "KrakatoaFinalPassDensityExponent=" + $krakatoaFinalPassDensityExponent + "\n" );
				
				int $krakatoaUseLightingPassDensity = `getAttr "MayaKrakatoaRenderSettings.useLightingPassDensity"`;
				
				if($krakatoaUseLightingPassDensity == 1) 
				{ 
					$boolVal = "True";
				}
				else 
				{ 
					$boolVal = "False";
				}

				fprint $fileId ( "KrakatoaUseLightingPassDensity=" + $boolVal+ "\n" );
				
				float $krakatoaLightingDensity = `getAttr "MayaKrakatoaRenderSettings.lightingPassDensity"`;
				fprint $fileId ( "KrakatoaLightingPassDensity="+ $krakatoaLightingDensity + "\n" );
				
				int $krakatoaLightingDensityExponent = `getAttr "MayaKrakatoaRenderSettings.lightingPassDensityExponent"`;
				fprint $fileId ( "KrakatoaLightingPassDensityExponent=" + $krakatoaLightingDensityExponent + "\n" );
				
				int $krakatoaUseEmissionStrength = `getAttr "MayaKrakatoaRenderSettings.useEmissionStrength"`;
				if($krakatoaUseEmissionStrength == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaUseEmissionStrength=" + $boolVal + "\n" );
				
				float $krakatoaEmissionStrength = `getAttr "MayaKrakatoaRenderSettings.emissionStrength"`;
				fprint $fileId ( "KrakatoaEmissionStrength="+ $krakatoaEmissionStrength + "\n" );

				int $krakatoaEmissionStrengthExponent = `getAttr "MayaKrakatoaRenderSettings.emissionStrengthExponent"`;
				fprint $fileId ( "KrakatoaEmissionStrengthExponent=" + $krakatoaEmissionStrengthExponent + "\n" );
				
				int $krakatoaUseEmission = `getAttr "MayaKrakatoaRenderSettings.useEmission"`;
				if($krakatoaUseEmission == 1) 
				{
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaUseEmission=" + $boolVal + "\n" );
				
				int $krakatoaUseAbsorption = `getAttr "MayaKrakatoaRenderSettings.useAbsorption"`;
				if($krakatoaUseAbsorption == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaUseAbsorption=" + $boolVal + "\n" );
				
				int $krakatoaEnableMotionBlur = `getAttr "MayaKrakatoaRenderSettings.enableMotionBlur"`;
				if($krakatoaEnableMotionBlur == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaEnableMotionBlur=" + $boolVal + "\n" );
				
				int $krakatoaMotionBlurParticleSegments = `getAttr "MayaKrakatoaRenderSettings.motionBlurParticleSegments"`;
				fprint $fileId ( "KrakatoaMotionBlurParticleSegments=" + $krakatoaMotionBlurParticleSegments+ "\n" );
				
				int $krakatoaJitteredMotionBlur = `getAttr "MayaKrakatoaRenderSettings.jitteredMotionBlur"`;
				if($krakatoaJitteredMotionBlur == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaJitteredMotionBlur=" + $boolVal + "\n" );
				
				float $krakatoaShutterAngle = `getAttr "MayaKrakatoaRenderSettings.shutterAngle"`;
				fprint $fileId ( "KrakatoaShutterAngle="+ $krakatoaShutterAngle + "\n" );
				
				int $krakatoaEnableDOF = `getAttr "MayaKrakatoaRenderSettings.enableDOF"`;
				if($krakatoaEnableDOF == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaEnableDOF=" + $boolVal + "\n" );
				
				float $krakatoaSampleRateDOF = `getAttr "MayaKrakatoaRenderSettings.sampleRateDOF"`;
				fprint $fileId ( "KrakatoaSampleRateDOF="+ $krakatoaSampleRateDOF + "\n" );
				
				int $krakatoaEnableMatteObjects = `getAttr "MayaKrakatoaRenderSettings.enableMatteObjects"`;
				if($krakatoaEnableMatteObjects == 1) 
				{ 
					$boolVal = "True"; 
				}
				else
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaEnableMatteObjects=" + $boolVal + "\n" );
				
				int $krakatoaEnableOverrideBG = `getAttr "MayaKrakatoaRenderSettings.overrideBG"`;
				if($krakatoaEnableOverrideBG == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaEnableOverrideBG=" + $boolVal + "\n" );
				
				//float $krakatoaBGOverride[] = `getAttr "MayaKrakatoaRenderSettings.backgroundColor"`;
				//fprint $fileId ( "KrakatoaBGOverride=" + $krakatoaBGOverride[0]+ " "+ $krakatoaBGOverride[1] + " " + $krakatoaBGOverride[2] + "\n" );
				
				int $krakatoaEnableOverrideColor = `getAttr "MayaKrakatoaRenderSettings.overrideColor"`;
				if($krakatoaEnableOverrideColor == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaEnableOverrideColor=" + $boolVal + "\n" );
				
				//float $krakatoaColorOverride[] = `getAttr "MayaKrakatoaRenderSettings.colorChannelOverride"`;
				//fprint $fileId ( "KrakatoaColorOverride=" + $krakatoaColorOverride[0]+ " "+ $krakatoaColorOverride[1] + " " + $krakatoaColorOverride[2] + "\n" );
				
				int $krakatoaEnableOverrideEmission = `getAttr "MayaKrakatoaRenderSettings.overrideEmission"`;
				if($krakatoaEnableOverrideEmission == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaEnableOverrideEmission=" + $boolVal + "\n" );
				
				//float $krakatoaEmissionOverride[] = `getAttr "MayaKrakatoaRenderSettings.emissionChannelOverride"`;
				//fprint $fileId ( "KrakatoaEmissionOverride=" + $krakatoaEmissionOverride[0]+ " "+ $krakatoaEmissionOverride[1] + " " + $krakatoaEmissionOverride[2] + "\n" );
				
				int $krakatoaEnableOverrideAbsorption = `getAttr "MayaKrakatoaRenderSettings.overrideAbsorption"`;
				if($krakatoaEnableOverrideAbsorption == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaEnableOverrideAbsorption=" + $boolVal+ "\n" );
				
				//float $krakatoaAbsorptionOverride[] = `getAttr "MayaKrakatoaRenderSettings.absorptionChannelOverride"`;
				//fprint $fileId ( "krakatoaAbsorptionOverride=" + $krakatoaAbsorptionOverride[0]+ " "+ $krakatoaAbsorptionOverride[1] + " " + $krakatoaAbsorptionOverride[2] + "\n" );
				
				string $krakatoaRenderingMethod = `getAttr -asString "MayaKrakatoaRenderSettings.renderingMethod"`;
				fprint $fileId ( "KrakatoaRenderingMethod="+ $krakatoaRenderingMethod + "\n" );
				
				if ($krakatoaRenderingMethod =="Voxels")
				{
					float $krakatoaVoxelSize = `getAttr "MayaKrakatoaRenderSettings.voxelSize"`;
					fprint $fileId ( "KrakatoaVoxelSize="+ $krakatoaVoxelSize + "\n" );
					
					float $krakatoaVoxelFilterRadius = `getAttr "MayaKrakatoaRenderSettings.voxelFilterRadius"`;
					fprint $fileId ( "KrakatoaVoxelFilterRadius="+ $krakatoaVoxelFilterRadius + "\n" );
				}
				
				int $krakatoaForceEXROutput = `getAttr "MayaKrakatoaRenderSettings.forceEXROutput"`;
				if($krakatoaForceEXROutput == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}

				fprint $fileId ( "KrakatoaForceEXROutput=" + $boolVal + "\n" );				
			}
			
			if( $renderer == "arnold" )
			{
				string $arnoldVerbose = `optionMenuGrp -q -value frw_arnoldVerbose`;
				fprint $fileId ( "ArnoldVerbose=" + $arnoldVerbose + "\n" );

				int $mayaToArnoldVersion = GetPluginMajorVersion( "mtoa" );
				fprint $fileId ( "MayaToArnoldVersion=" + $mayaToArnoldVersion + "\n" );
				
				int $conductorDepScan = `checkBox -q -value frw_conductorDepScan`;
				//print ("----------------------------------------------------conductorDepScan=" + $conductorDepScan + "\n\n\n\n");
				
				// Use the Conductor dependency scanner
				if ( $conductorDepScan == 1)
				{
					print ("-Scanning for dependencies-------------\n\n\n\n");
					python("import json; from conductor.lib import common, maya_utils; import maya.cmds as mc");
					python("resources = common.load_resources_file(); dependency_attrs = resources.get('maya_dependency_attrs') or {}; dependencies = {'dependencies':  maya_utils.collect_dependencies(dependency_attrs)};");
					python("dependency_sidecar_path = '{}.cdepends'.format(mc.file(query=True, sceneName=True))");
					python("with open(dependency_sidecar_path, 'w') as fh:  json.dump(dependencies, fh)");
					print ("Dependencies written");
			    }
			}
				
			if( $renderer == "mentalRay" )
			{
				string $mentalRayVerbose = `optionMenuGrp -q -value frw_mentalRayVerbose`;
				fprint $fileId ( "MentalRayVerbose=" + $mentalRayVerbose + "\n" );
				
				int $autoMemoryLimit = `checkBox -q -value frw_autoMemoryLimit`;
				fprint $fileId ( "AutoMemoryLimit=" + $autoMemoryLimit + "\n" );
				
				int $memoryLimit = `intSliderGrp -q -v frw_memoryLimit`;
				fprint $fileId ( "MemoryLimit=" + $memoryLimit + "\n" );
			}

			if( $renderer == "redshift" || $renderer == "ifmIrayPhotoreal" || $renderer == "octaneRender" )
			{
				int $deadlineGPUsPerTask = `intSliderGrp -q -v frw_deadlineGPUsPerTask`;
				fprint $fileId ( "GPUsPerTask=" + $deadlineGPUsPerTask + "\n" );

				string $deadlineGPUsSelectDevices = `textFieldGrp -q -text frw_deadlineGPUsSelectDevices`;
				fprint $fileId ( "GPUsSelectDevices=" + `textFieldGrp -q -text frw_deadlineGPUsSelectDevices` + "\n" );
			}
			
			if( $renderer == "redshift" )
			{
				int $redshiftVerbose = `optionMenuGrp -q -sl frw_redshiftVerbose`;
				fprint $fileId ( "RedshiftVerbose=" + ( $redshiftVerbose -1 ) + "\n" );
			}
			
			if( $renderer == "ifmIrayPhotoreal" )
			{
				string $boolVal = "";
								
				int $irayUseCPUs = `checkBox -q -v frw_irayUseCPUs`;
				
				if($irayUseCPUs == 1) 
				{ 
					$boolVal = "True"; 
				}
				else 
				{ 
					$boolVal = "False"; 
				}
				
				fprint $fileId ( "IRayUseCPUs=" + $boolVal + "\n" );
				
				float $irayCPULoad = `floatSliderGrp -q -v frw_irayCPULoad`;
				fprint $fileId ( "IRayCPULoad=" + $irayCPULoad + "\n" );
				
				int $irayMaxSamples = `getAttr ifmGlobalsIrayPhotoreal.irayMaxSamples`;
				fprint $fileId ( "IRayMaxSamples=" + $irayMaxSamples + "\n" );
			}

			if( $renderer == "vray" )
			{
				if( $useMayaBatchPlugin )
				{
					int $vrayAutoMemoryEnabled = `checkBox -q -value frw_vrayAutoMemoryEnabled`;
					fprint $fileId ( "VRayAutoMemoryEnabled=" + $vrayAutoMemoryEnabled + "\n" );
					
					int $vrayAutoMemoryBuffer = `intSliderGrp -q -v frw_vrayAutoMemoryBuffer`;
					fprint $fileId ( "VRayAutoMemoryBuffer=" + $vrayAutoMemoryBuffer + "\n" );
				}
			}
			
			if( $renderer == "maxwell" )
			{
				fprint $fileId ( "MaxwellRenderTime=" + `getAttr "maxwellRenderOptions.renderTime"` + "\n" );
				fprint $fileId ( "MaxwellSamplingLevel=" + `getAttr "maxwellRenderOptions.samplingLevel"` + "\n" );
				fprint $fileId ( "MaxwellResumeRender=false\n" );
			}
			
			if( $renderer == "OctaneRender" )
			{
				fprint $fileId ( "OctaneMaxSamples=" + `getAttr "octaneSettings.MaxSamples"` + "\n" );
			}
		}

		//fprint $fileId ( "Version=" + IntMayaVersion() + "\n" );
		fprint $fileId ( "Version=" + MayaVersion() + "\n" );

		if( MayaVersion() >= 2016.5 )
		{
			fprint $fileId ( "UseLegacyRenderLayers=" + !mayaHasRenderSetup() + "\n" );
		}
		
		string $mayaBuild = `optionMenuGrp -q -value frw_mayaBuild`;
		fprint $fileId ( "Build=" + $mayaBuild + "\n" );
		
		fprint $fileId ( "ProjectPath=" + CheckSlashes( `textFieldGrp -q -text frw_projectPath` ) + "\n" );
		if( !$useMayaBatchPlugin )
		{
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_mayaArgs` + "\n" );
		}
		else
		{
			fprint $fileId ( "StartupScript=" + `textFieldButtonGrp -q -text $StartupScriptPathGrp` + "\n" );
		}
		
		int $res[] = GetGlobalsResolution();
		fprint $fileId ( "ImageWidth=" + $res[0] + "\n" );
		fprint $fileId ( "ImageHeight=" + $res[1] + "\n" );
		//if( $renderer != "vray" )
		//	fprint $fileId ( "AspectRatio=" + `getAttr "defaultResolution.deviceAspectRatio"` + "\n" );
		
		// Skip existing is only supported in 2014 and later, and by specific renderers.
		if( IntMayaVersion() >= 2014 && ( $renderer == "ifmirayphotoreal" || $renderer == "mentalRay" || $renderer == "mayaSoftware" || $renderer == "mayaHardware" || $renderer == "mayaHardware2" || $renderer == "mayaVector") )
		{
			int $skipExistingFrames = `getAttr defaultRenderGlobals.skipExistingFrames`;
			fprint $fileId ( "SkipExistingFrames=" + $skipExistingFrames + "\n" );
		}
		
		string $baseOutputFilePath = GetBaseOutputDirectory( $renderer );
		
		fprint $fileId ( "OutputFilePath=" + $baseOutputFilePath + "\n" );
		if( IsRenderLayersOn() && !$submitEachRenderLayer )
		{
			fprint $fileId ( "OutputFilePrefix=\n" );
		}
		else if( $jobType == $MaxwellExportJobType )
		{
			fprint $fileId ( "OutputFilePrefix=\n" );
		}
		else
		{
			string $mayaOutputFilePrefix = GetBaseOutputPrefix( $renderer, $camera, $currentRenderLayer );

			if( $jobType == $MayaRenderJobType && $regionRendering )
			{
				
				int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;  
				if($regionType == $TileRegionRenderType)
				{
					$mayaOutputFilePrefix = GetTileOutputPrefix( $mayaOutputFilePrefix, $currX, $currY, $tilesInX, $tilesInY, $renderer );
				}
				else
				{
					$mayaOutputFilePrefix = GetJigsawOutputPrefix( $mayaOutputFilePrefix, $currTile, $renderer );
				}
				
				WriteRenderElementRegionPrefix( $fileId, $renderer, $currentRenderLayer, $elements, ($regionType == $JigsawRegionRenderType), 0, $currTile, $currX, $currY, $tilesInX, $tilesInY );
			}
			
			fprint $fileId ( "OutputFilePrefix=" + $mayaOutputFilePrefix + "\n" );	
		}
		
		//fprint $fileId ( "MotionBlur=" + GetMotionBlur() + "\n" );
			
		// If the user has specified a camera, make it the default
		fprint $fileId ( "Camera=" + $camera + "\n" );
		
		// Now list all the camera options
		fprint $fileId ("Camera0=\n");
		string $cameraNames[] = `listTransforms -cameras`;
		for( $n = 1 ; $n <= size($cameraNames); $n++ )
		{
			fprint $fileId ( "Camera" + $n + "=" + $cameraNames[ $n - 1 ] + "\n" );
		}

		int $countRenderableCameras = size( deadlineGetRenderableCameras( false ) );
		fprint $fileId ( "CountRenderableCameras=" + $countRenderableCameras + "\n" );
		
		string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
		int $submitMayaSceneFile = `checkBox -q -value frw_submitMayaScene`;
		if( !$submitMayaSceneFile )
		{
			fprint $fileId ( "SceneFile=" + $sceneFilePath + "\n" );
		}
		
		int $ignoreError211 = `checkBox -q -value frw_ignoreError211`;
		fprint $fileId ( "IgnoreError211=" + $ignoreError211 + "\n" );
		
		if( $useMayaBatchPlugin )
		{
			int $useLocalAssetCaching = `checkBox -q -value frw_useLocalAssetCaching`;
			fprint $fileId ( "UseLocalAssetCaching=" + $useLocalAssetCaching + "\n" );
		}
		
		int $OCIOEnabled = 0;
		catchQuiet( $OCIOEnabled = `colorManagementPrefs -q -cmConfigFileEnabled` );
		fprint $fileId ( "EnableOpenColorIO=" + $OCIOEnabled + "\n" );
		
		fclose $fileId;
		
		
		string $argList[];
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;
		if( $submitMayaSceneFile )
		{
			$argList[size($argList)] = $sceneFilePath;
			string $xgenFiles[] = getXGenFiles();
			// add xgen files to job params and command
			for($xgenPath in $xgenFiles)
			{
				$argList[size($argList)] = $xgenPath;
			}
		}
		if( $jobType == $MayaScriptJobType)
		{	
			string $result = `textFieldGrp -q -tx frw_mayaScriptJob`;
			$argList[size($argList)] = $result;
		}

		// Submit the job to Deadline
		// Special case, only concatenate pipeline tool settings to .job file if it is not a dependentJob
		if( !$dependentJob )
		{
			string $batchName = `textFieldGrp -q -text frw_JobName`;
			ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
		}
		string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
		$submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
	}

	// Parse the standard output from Deadline command to extract the job ID
	string $jobId = parseJobIDFromSubmissionOutput( $submitResults );

	int $doPrecaching = `getAttr defaultRenderGlobals.deadlinePrecacheAssetsForAWS`;
	// We have the job ID, now it's time to call the AWS Portal stuff
	if(size($assetPaths) > 0 && $doPrecaching)
	{
		print( CallDeadlineCommand( "-AWSPortalPrecacheJob "+$jobId, true ) );
	}

	// Specify which renderer is being used.
	if( $jobType == $MentalRayExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: mentalRayExport\n";
	}
	else if( $jobType == $VRayExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: vrayExport\n";
	}
	else if( $jobType == $RendermanExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: rendermanExport\n";
	}
	else if( $jobType == $ArnoldExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: arnoldExport\n";
	}
	else if( $jobType == $MaxwellExportJobType )
	{
		$submitResults = $submitResults + "\n\nUsing renderer: maxwellExport\n";
	}
	else if( $jobType == $BifrostSimulationJobType )
	{
		$submitResults = $submitResults + "\n\nCreating bifrost simulation\n";
	}
	else if( $jobType == $AlembicExportJobType )
	{
		$submitResults = $submitResults + "\n\nExporting to Alembic format\n";
	}
	else if( $jobType == $MayaScriptJobType )
	{
		$submitResults = $submitResults + "\n\nRunning Maya Script Job\n";
	}
	else if( $jobType == $GeometryCachingJobType )
	{
		$submitResults = $submitResults + "\n\nRunning Geometry cache job\n";
	}
	else if( $jobType == $FluidCachingJobType )
	{
		$submitResults = $submitResults + "\n\nRunning Fluid cache job\n";
	}
	else
	{
		$submitResults = $submitResults + "\n\nUsing renderer: " + $renderer + "\n";
	}

	// Show results
	if( $showDialog )
	{
		confirmDialog -title "Submission Results" -parent $DeadlineSubmitterWindow -message $submitResults -button "Ok";
	}
	else
	{
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	}

	return $jobId;
}

proc int SetupDependentTileAnimationAssemblerJob(string $renderer, string $jobIds[], string $currentRenderLayer, string $currCamera)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	global int $JigsawRegionRenderType;
	global int $TileRegionRenderType;

	int $jobCount = 0;
	int $totalTiles = 0;

	string $elements[] = {""};
	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
	int $overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];
	if( $renderer == "vray" )
	{
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.
	}

	if( $submitEachRenderLayer )
	{
		if($overrideLayerSettings)
		{
			$field = "frw_FrameList_" + $currentRenderLayer;
			$frameList = `textFieldGrp -q -text $field`;
		}
		else
		{
			$frameList = DeadlineGetFrameList();
		}
	}

	int $frameRange[] = GetFramesArray($frameList);

	string $regionLeftValues[];
	string $regionRightValues[];
	string $regionTopValues[];
	string $regionBottomValues[];
	int $tilesInX = 0;
	int $tilesInY = 0;

	if ( $regionType == $JigsawRegionRenderType )
	{
		string $regionString = `getAttr defaultRenderGlobals.deadlineRegionLeft`;
		$regionLeftValues = stringToStringArray($regionString,";");

		$regionString = `getAttr defaultRenderGlobals.deadlineRegionRight`;
		$regionRightValues = stringToStringArray($regionString,";");

		$regionString = `getAttr defaultRenderGlobals.deadlineRegionTop`;
		$regionTopValues = stringToStringArray($regionString,";");

		$regionString = `getAttr defaultRenderGlobals.deadlineRegionBottom`;
		$regionBottomValues = stringToStringArray($regionString,";");

		$totalTiles = size( $regionLeftValues );
	}
	else if ( $regionType == $TileRegionRenderType )
	{
		$tilesInX = `intSliderGrp -q -v frw_tilesInX`;
		$tilesInY = `intSliderGrp -q -v frw_tilesInY`;
	}

	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}
	else if( $renderer == "redshift" )
	{
		$elements = getRedshiftElementsUniquePaths( $currCamera );
	}
	else if ( $renderer == "renderman22" )
	{
		$elements = getRendermanElements();
	}

	string $outputFilePath = GetBaseOutputDirectory($renderer);

	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";
	string $configFilenames[];
	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilename = "";
	int $currTile = 0;

	string $jobIdString = stringArrayToString ($jobIds,",");
	
	if( $regionType == $TileRegionRenderType )
	{
		python( "dlTileGenerator = TileRendering.TileGenerator( " + $tilesInX + ", " + $tilesInY + ", " + $width + ", " + $height + ", returnSize=True)" );
	}
	
	for($element in $elements)
	{
		string $tempOutputDirectory = $outputFilePath;
		if( $renderer == "renderman22" )
		{
			$tempOutputDirectory = GetRendermanOutputDirectory($currentRenderLayer, $currCamera, $element);
		}
		
		$configFilenames = {};

		string $jobName = `textFieldGrp -q -text frw_JobName`;
		if( $currentRenderLayer != "" )
		{
			$jobName += " - " + $currentRenderLayer;
		}

		if( $currCamera != "" )
		{
			$jobName += " - " + $currCamera;
		}

		if( $element != "" )
		{
			$jobName = $jobName + " - "+$element+" (Animation - Tile Assembly Job)";
		}
		else
		{
			$jobName = $jobName + " - (Animation - Tile Assembly Job)";
		}

		string $jobUUID = GetDeadlineUUID( 10 );
		$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info_" + $jobUUID + ".job" );
		$fileId = `fopen $submitFilename "w"`;

		if( $fileId == 0 )
		{
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
		}

		fprint $fileId ( "Plugin=DraftTileAssembler\n" );
		fprint $fileId ( "Name=" + $jobName + "\n" );
		fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );

		fprint $fileId ( "IsFrameDependent=True\n" );

		string $outputFilename = "";
		if( $renderer == "redshift" )
		{
			$outputFilename = getRedshiftOutputFilename( 0,0, $tempOutputDirectory, $element, $currCamera );
			fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );
		}
		else
		{
			int $includeFilename = 1;
			//V-Ray Replaces each Hash in the Filename prefix with the full frame number while deadline replaces each grouping of Hashes with the frame number.
			//If there are multiple hashes in a row this causes Deadline to fail to match the output Filename so we only want to show the directory.
			if( $renderer == "vray" )
			{
				string $userDefinedPrefix = `getAttr vraySettings.fileNamePrefix`;
				if( `isValidString $userDefinedPrefix ".*##.*"` )
				{
					$includeFilename = 0;
				}
			}
			if( $includeFilename )
			{
				string $outputPrefix = GetOutputPrefix( 0, 0, $currentRenderLayer, $currCamera, $element );
				$outputPrefix = swapDeepExr( $outputPrefix );
				$outputFilename = CheckSlashes( $tempOutputDirectory  + "/" + $outputPrefix );
				fprint $fileId ( "OutputFilename0=" +$outputFilename + "\n" );
			}
			else {
				// We can provide Deadline with the output directory
				fprint $fileId ( "OutputDirectory0=" + $tempOutputDirectory + "\n" );
			}
		}

		fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );
		fprint $fileId ( "Frames="+$frameList+"\n" );

		fprint $fileId ( "ChunkSize=1\n" );

		if( `checkBox -q -value frw_isBlacklist` )
		{
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		}
		else
		{
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
		}


		fclose $fileId;

		$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job_" + $jobUUID + ".job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
		{
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
		}
		int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
		int $tileMissingBackground = `checkBox -q -v frw_submitTileErrorOnMissingBackground`;
		string $missing = $errorOnMissing ? "true" : "false";
		string $missingBackground = $tileMissingBackground ? "true" : "false";
		fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
		fprint $fileId ( "ErrorOnMissingBackground="+$missingBackground+"\n" );
		fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );
		fprint $fileId ( "MultipleConfigFiles=true\n" );
		fclose $fileId;

		int $frameCount = 0;

		for($frameNumber in $frameRange)
		{
			string $outputPrefix = "";
			string $outputFilename = "";
			string $mayaOutputPrefix = "";
			string $base = "";
			if( $renderer == "redshift" )
			{
				$mayaOutputPrefix = getRedshiftOutputPrefix($element, $currCamera, $currentRenderLayer );

				if( $element == "" )
				{
					$outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
					$base = basenameEx( $outputPrefix );

				}
				else
				{
					string $aovParts[] = redshiftGetAovPathParts( $element, 0, $currCamera );
					$base = $aovParts[ 2 ] + "." +$frameNumber ;

				}
				$outputFilename = getRedshiftOutputFilename( 1, $frameNumber, $tempOutputDirectory, $element, $currCamera );
			}
			else
			{
				$outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
				$outputFilename = CheckSlashes( $tempOutputDirectory  + "/" + $outputPrefix );
				$base = basenameEx( $outputPrefix );
			}



			string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;
			string $configDirectory = dirname( $outputFilename );

			if( $element == "" || $renderer == "vray" )
			{
				$configFilename = CheckSlashes( $configDirectory  + "/"+$base+"_config_"+$dateString+".txt" );
			}
			else
			{
				$configFilename = CheckSlashes( $configDirectory  + "/"+$base+"_"+$element+"_config_"+$dateString+".txt" );
			}
			sysFile -makeDir $configDirectory;

			$fileId = `fopen $configFilename "w"`;
			if( $fileId == 0 )
			{
				print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );
			}

			fprint $fileId ( "\n" );
			fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
			fprint $fileId ( "ImageWidth=" +$width+ "\n" );
			fprint $fileId ( "ImageHeight=" + $height + "\n" );

			string $imfType = GetImageType( $renderer, $element );
			
			if( TilesAreCropped( $renderer, $imfType ) )
			{
				fprint $fileId ( "TilesCropped=False\n" );
			}
			else
			{
				fprint $fileId ( "TilesCropped=True\n" );
			}

			int $currTile = 0;
			string $inputPrefix = "";
			string $inputImageFilename = "";

			if( $regionType == $JigsawRegionRenderType )
			{
				for( $i = 0; $i < $totalTiles; $i++ )
				{
					string $tileRegionLeft = $regionLeftValues[$i];
					string $tileRegionLeftArray[] = stringToStringArray($tileRegionLeft, ",");
					string $tileRegionRight = $regionRightValues[$i];
					string $tileRegionRightArray[] = stringToStringArray($tileRegionRight, ",");
					string $tileRegionTop = $regionTopValues[$i];
					string $tileRegionTopArray[] = stringToStringArray($tileRegionTop, ",");
					string $tileRegionBottom = $regionBottomValues[$i];
					string $tileRegionBottomArray[] = stringToStringArray($tileRegionBottom, ",");

					if( $tileRegionLeftArray[$frameCount] != "-1" )
					{

						if( $renderer == "redshift" )
						{
							$inputPrefix = GetJigsawOutputPrefix( $mayaOutputPrefix, $i, $renderer);
							$inputImageFilename = getRedshiftOutputFilenameWithPrefix(1, $frameNumber, $tempOutputDirectory, $element, $currCamera, $inputPrefix);

						}
						else
						{
							$inputPrefix = GetJigsawOutputPrefix( $outputPrefix, $i, $renderer);
							$inputImageFilename = CheckSlashes( $tempOutputDirectory  + "/" + $inputPrefix );
						}
						int $currWidth = int($tileRegionRightArray[$frameCount])-int($tileRegionLeftArray[$frameCount]);
						int $currHeight = int($tileRegionBottomArray[$frameCount])-int($tileRegionTopArray[$frameCount]);
						int $top = int($tileRegionTopArray[$frameCount]);

						fprint $fileId ( "Tile"+$currTile+"FileName=" + $inputImageFilename + "\n");

						fprint $fileId ( "Tile"+$currTile+"X=" + ( $tileRegionLeftArray[$frameCount] ) + "\n" );
						fprint $fileId ( "Tile"+$currTile+"Y=" + ( $top ) + "\n" );

						fprint $fileId ( "Tile"+$currTile+"Width=" + ( $currWidth ) + "\n" );
						fprint $fileId ( "Tile"+$currTile+"Height=" + ( $currHeight ) + "\n" );
					}

					$currTile++;
				}
			}
			else if( $regionType == $TileRegionRenderType )
			{
				for( $y = 1; $y <= $tilesInY; $y++ )
				{
					for( $x = 1; $x <= $tilesInX; $x++ )
					{
						int $tileProps[] = python( "dlTileGenerator.getTile( ("+( $x - 1 )+","+( $y - 1 )+") )" );
						int $minX = $tileProps[0];
						int $width = $tileProps[1];
						int $minY = $tileProps[2];
						int $height = $tileProps[3];
						string $inputPrefix = "";
						string $inputImageFilename = "";
						if( $renderer == "redshift" )
						{
							$inputPrefix = GetTileOutputPrefix( $mayaOutputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
							$inputImageFilename = getRedshiftOutputFilenameWithPrefix( 1, $frameNumber, $tempOutputDirectory, $element, $currCamera, $inputPrefix );
						}
						else
						{
							$inputPrefix = GetTileOutputPrefix( $outputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
							$inputImageFilename = CheckSlashes( $tempOutputDirectory  + "/" + $inputPrefix );
						}

						fprint $fileId ( "Tile" + $currTile + "FileName=" + $inputImageFilename + "\n" );
						fprint $fileId ( "Tile"+$currTile+"X="+$minX+"\n" );
						fprint $fileId ( "Tile"+$currTile+"Y="+$minY+"\n" );
						fprint $fileId ( "Tile"+$currTile+"Width="+$width+"\n" );
						fprint $fileId ( "Tile"+$currTile+"Height="+$height+"\n" );

						$currTile++;
					}
				}
			}

			fprint $fileId ( "TileCount=" + $currTile + "\n" );

			int $compType = `optionMenuGrp -q -select frw_compositeType`;
			string $oldImage;
			if($compType == $PreviousImageCompType)
			{
				$oldImage = $outputFilename;
				fprint $fileId ("BackgroundSource="+$oldImage+"\n");
			}
			else if($compType == $SelectedImageCompType)
			{
				$oldImage = `textFieldButtonGrp -q -text frw_submitTileCompositeOverName`;
				fprint $fileId ("BackgroundSource="+$oldImage+"\n");
			}
			fclose $fileId;
			stringArrayInsertAtIndex(`size($configFilenames)`, $configFilenames, $configFilename );
		}

		string $argList[];
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;
		for($conFile in $configFilenames)
		{
			$argList[size($argList)] = $conFile;
		}

		// Submit the job to Deadline
		string $batchName = `textFieldGrp -q -text frw_JobName`;
		ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
		string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );
		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
		$jobCount++;
	}

	return $jobCount;
}

proc int SetupDependentJigsawAssemblerJob(string $renderer, string $jobIds[], int $frameNumber, int $regionValues[], string $currentRenderLayer, string $currCamera)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	string $elements[] = {""};

	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";

	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}
	else if( $renderer == "redshift" )
	{
		$elements = getRedshiftElementsUniquePaths( $currCamera );
	}
	else if ( $renderer == "renderman22" )
	{
		$elements = getRendermanElements();
	}

	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $currentRenderLayer != "" )
		$jobName += " - " + $currentRenderLayer;
	if( $currCamera != "" )
		$jobName += " - " + $currCamera;

	$jobName = $jobName + "(Frame " + $frameNumber + " - Tile Assembly Job)";

	string $outputFilePath = GetBaseOutputDirectory($renderer);

	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";
	string $configFilenames[];
	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilename = "";

	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];;
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.

	int $totalTiles = size($regionValues)/4;
	int $currTile = 0;

	string $jobUUID = GetDeadlineUUID( 10 );
	$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info_" + $jobUUID + ".job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=DraftTileAssembler\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );

	int $curFile = 0;
	for( $element in $elements  )
	{
		string $tempOutputDirectory = $outputFilePath;
		if( $renderer == "renderman22" )
		{
			$tempOutputDirectory = GetRendermanOutputDirectory($currentRenderLayer, $currCamera, $element);
		}
		
		string $outputFilename = "";
		if( $renderer == "redshift" )
		{
			$outputFilename = getRedshiftOutputFilename( 1,$frameNumber, $tempOutputDirectory, $element, $currCamera );
		}
		else
		{
			string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
			$outputPrefix = swapDeepExr( $outputPrefix );
			$outputFilename = CheckSlashes( $tempOutputDirectory  + "/" + $outputPrefix );
		}
		fprint $fileId ( "OutputFilename"+$curFile+"=" + $outputFilename + "\n" );
		$curFile++;
	}

	string $jobIdString = stringArrayToString ($jobIds,",");
	fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );

	fprint $fileId ( "Frames=0-"+(`size($elements)` -1)+"\n" );

	fprint $fileId ( "ChunkSize=1\n" );

	if( `checkBox -q -value frw_isBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );


	fclose $fileId;
	$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job_" + $jobUUID + ".job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
	int $tileMissingBackground = `checkBox -q -v frw_submitTileErrorOnMissingBackground`;
	string $missing = $errorOnMissing ? "true" : "false";
	string $missingBackground = $tileMissingBackground ? "true" : "false";
	fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
	fprint $fileId ("ErrorOnMissingBackground="+$missingBackground+"\n");
	fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );

	if( size($elements) > 1 )
		fprint $fileId ( "MultipleConfigFiles=true\n" );

	fclose $fileId;
	for($element in $elements)
	{
		string $tempOutputDirectory = $outputFilePath;
		if( $renderer == "renderman22" )
		{
			$tempOutputDirectory = GetRendermanOutputDirectory($currentRenderLayer, $currCamera, $element);
		}
		
		string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;
		string $outputPrefix = "";
		string $outputFilename = "";
		string $mayaOutputPrefix = "";
		string $baseName = "";
		if( $renderer == "redshift" )
		{
			$mayaOutputPrefix = getRedshiftOutputPrefix($element, $currCamera, $currentRenderLayer );

			if( $element == "" )
			{
				$outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
				$baseName = basenameEx( $outputPrefix );

			}
			else
			{
				string $aovParts[] = redshiftGetAovPathParts( $element, 0, $currCamera );
				$baseName = $aovParts[ 2 ] + "." +$frameNumber ;

			}
			$outputFilename = getRedshiftOutputFilename( 1, $frameNumber, $tempOutputDirectory, $element, $currCamera );
		}
		else
		{
			$outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
			$outputFilename = CheckSlashes( $tempOutputDirectory  + "/" + $outputPrefix );
			$baseName = basenameEx( $outputPrefix );
		}

		string $configDirectory = dirname( $outputFilename );

		if( $element == "" || $renderer == "vray" )
			$configFilename = CheckSlashes( $configDirectory  + "/"+$baseName+"_config_"+$dateString+".txt" );
		else
			$configFilename = CheckSlashes( $configDirectory  + "/" + $baseName + "_" + $element + "_config_"+$dateString+".txt" );

		sysFile -makeDir $configDirectory;
		$fileId = `fopen $configFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );

		int $currTile = 0;
		fprint $fileId ( "\n" );
		fprint $fileId ( "TileCount=" +$totalTiles+ "\n" );
		fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
		fprint $fileId ( "ImageWidth=" +$width+ "\n" );
		fprint $fileId ( "ImageHeight=" + $height + "\n" );

		string  $imfType = GetImageType( $renderer, $element);
		if( TilesAreCropped( $renderer, $imfType ) )
		{
			fprint $fileId ( "TilesCropped=False\n" );
		}
		else
		{
			fprint $fileId ( "TilesCropped=True\n" );
		}

		for($i = 0; $i<size($regionValues)/4; $i++)
		{
			string $inputPrefix = "";
			string $inputImageFilename = "";
			if( $renderer == "redshift" )
			{
				$inputPrefix = GetJigsawOutputPrefix( $mayaOutputPrefix, $i, $renderer);
				$inputImageFilename = getRedshiftOutputFilenameWithPrefix(1, $frameNumber, $tempOutputDirectory, $element, $currCamera, $inputPrefix );
			}
			else
			{
				$inputPrefix = GetJigsawOutputPrefix( $outputPrefix, $i, $renderer);
				$inputImageFilename = CheckSlashes( $tempOutputDirectory  + "/" + $inputPrefix );
			}


			int $currWidth = $regionValues[$i*4+1]-$regionValues[$i*4];
			int $currHeight = $regionValues[$i*4+3]-$regionValues[$i*4+2];

			int $top = ($regionValues[$i*4+2]);

			fprint $fileId ("Tile"+$currTile+"FileName=" + $inputImageFilename + "\n");
			fprint $fileId ( "Tile"+$currTile+"X="+($regionValues[$i*4])+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Y="+($top)+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Width="+($currWidth)+"\n" );
			fprint $fileId ( "Tile"+$currTile+"Height="+($currHeight)+"\n" );
			$currTile++;
		}

		int $compType = `optionMenuGrp -q -select frw_compositeType`;
		string $oldImage;
		if($compType == $PreviousImageCompType)
		{
			$oldImage = $outputFilename;
			fprint $fileId ("BackgroundSource="+$oldImage+"\n");
		}
		else if($compType == $SelectedImageCompType)
		{
			$oldImage = `textFieldButtonGrp -q -text frw_submitTileCompositeOverName`;
			fprint $fileId ("BackgroundSource="+$oldImage+"\n");
		}
		fclose $fileId;

		stringArrayInsertAtIndex(size( $configFilenames ), $configFilenames, $configFilename );

	}

	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;
	for($conFile in $configFilenames)
	{
		$argList[size($argList)] = $conFile;
	}

	// Submit the job to Deadline
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
	string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	return 1;
}

global proc int[] removeDuplicateIntegers(int $array[])
{
	int $index = 0;
	int $newarray[];
	for( $i = 0 ; $i < size($array) ; $i++ )
	{
		$entry = true;
		for( $j = 0 ; $j < $i ; $j++ )
		{
			if( $array[$i] == $array[$j] ) //duplicate
				$entry = false;
		}
		if( $entry == true )
		{
			$newarray[$index] = $array[$i];
			$index++;
		}
	}
	return $newarray;
}

global proc string[] getVRayElementNames()
{
	string $elementNames[] = {""};

	int $isMultichannelExr = false;
	string $multichannel = " (multichannel)";
	string $ext = "";

	string $REs[] = `ls -type VRayRenderElement -type VRayRenderElementSet`;
	if (`optionMenuGrp -exists vrayImageFormatMenu`)
		$ext = `optionMenuGrp -q -v vrayImageFormatMenu`;
	else
		$ext = `getAttr vraySettings.imageFormatStr`;
		if ($ext == "")
			$ext = "png";//for some reason this happens if you have not changed the format

	if( endsWith( $ext, $multichannel ) )
	{
		$ext = substring( $ext, 1, size( $ext ) - size( $multichannel ) );
		$isMultichannelExr = true;
	}
	int $enableAll = `getAttr "vraySettings.relements_enableall"`;
	int $useReferenced = `getAttr "vraySettings.relements_usereferenced"`;

	if( !$isMultichannelExr && $enableAll )
	{
		for($RE in $REs)
		{
			int $enabled = `getAttr ($RE+".enabled")`;
			int $isReferenced = `referenceQuery -isNodeReferenced $RE`;

			if($isReferenced == 1 && $useReferenced == 0)
				continue;

			if($enabled == 1)
			{
				string $reType = `getAttr ($RE+".vrayClassType")`;

				string $REName = "";
				if( $reType == "ExtraTexElement" || $reType == "MaterialSelectElement" )
				{
					string $RENameFunction[]  = `listAttr -st "vray_explicit_name_*" $RE`;
					$REName = `getAttr ($RE+"."+$RENameFunction[0])`;
					if( $REName == "" )
					{
						$RENameFunction = `listAttr -st "vray_name_*" $RE`;

						$REName = `getAttr ($RE+"."+$RENameFunction[0])`;

						if( $reType == "ExtraTexElement" )
						{
							string $textures[] = `listConnections( $RE+ ".vray_texture_extratex")`;
							if( size($textures) > 0 )
							{
								if( $REName != "" )
								{
									$REName+= "_";
								}
								$REName+=  $textures[0];
							}
						}
						else if ( $reType == "MaterialSelectElement" )
						{
							string $materials[] = `listConnections( $RE+ ".vray_mtl_mtlselect")`;
							if( size($materials) > 0 )
							{
								if( $REName != "" )
								{
									$REName+= "_";
								}
								$REName+= $materials[0];
							}
						}
					}
				}
				else
				{
					string $RENameFunction[]  = `listAttr -st "vray_name_*" $RE`;
					if( `size($RENameFunction)` == 0 )
					{
						$RENameFunction = `listAttr -st "vray_filename_*" $RE`;
					}
					$REName = `getAttr ($RE+"."+$RENameFunction[0])`;
				}

				$REName = substituteAllString($REName, " ", "_" );
				stringArrayInsertAtIndex( size( $elementNames ), $elementNames, $REName );
			}
		}

		int $separateAlpha = `getAttr "vraySettings.separateAlpha"`;
		if( $separateAlpha == 1 )
		{
			stringArrayInsertAtIndex( size( $elementNames ), $elementNames, "Alpha" );
		}
	}

	return $elementNames;
}

global proc string[] getMaxwellElementNames()
{
	string $elementNames[] = {""};
	int $embedChannels = `getAttr maxwellRenderOptions.embedAlpha`;

	if( !$embedChannels )
	{
		if( `getAttr maxwellRenderOptions.alphaChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "alpha" );

		if( `getAttr maxwellRenderOptions.deepChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "deep" );

		if( `getAttr maxwellRenderOptions.depthChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "zbuffer" );

		if( `getAttr maxwellRenderOptions.shadowChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "shadow" );

		if( `getAttr maxwellRenderOptions.objIDChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "object" );

		if( `getAttr maxwellRenderOptions.matIDChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "material" );

		if( `getAttr maxwellRenderOptions.motionVectorChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "motion" );

		if( `getAttr maxwellRenderOptions.roughnessChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "roughness" );

		if( `getAttr maxwellRenderOptions.fresnelChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "fresnel" );

		if( `getAttr maxwellRenderOptions.normalsChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "normals" );

		if( `getAttr maxwellRenderOptions.positionChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "position" );

		if( `getAttr maxwellRenderOptions.uvChannel` == 1 )
			stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "uv" );

		if( `getAttr maxwellRenderOptions.customAlphaChannel` == 1 )
		{
			string $customChannelNameAttributes[] = `listAttr -st "*cn" -multi  maxwellRenderOptions.mxCustomAlphaChannels`;
			for( $nameAttr in $customChannelNameAttributes )
			{
				stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "customAlpha_"+`getAttr( "maxwellRenderOptions." + $nameAttr )` );
			}
		}
	}

	return $elementNames;
}

global proc string getMaxwellChannelExtension( int $index, int $isChannel )
{
	string $extension = "";
	if( ($index == 0 && $isChannel ) || ($index == 32 && !$isChannel ) )
	{
		$extension = "png";
	}
	else if( ($index == 1 && $isChannel ) || ($index == 8 && !$isChannel ) )
	{
		$extension = "jpg";
	}
	else if( ($index == 2 && $isChannel ) || ($index == 19 && !$isChannel ) )
	{
		$extension = "tga";
	}
	else if( ($index == 3 && $isChannel ) || ($index == 20 && !$isChannel ) )
	{
		$extension = "bmp";
	}
	else if( ($index == 4 && $isChannel ) || ($index == 3 && !$isChannel ) )
	{
		$extension = "tif";
	}
	else if( ($index == 5 && $isChannel ) || ($index == 31 && !$isChannel ) )
	{
		$extension = "exr";
	}
	else if( ($index == 6 && $isChannel ) || ($index == 35 && !$isChannel ) )
	{
		$extension = "hdr";
	}
	else if( ($index == 7 && $isChannel ) || ($index == 36 && !$isChannel ) )
	{
		$extension = "jp2";
	}
	return $extension;
}

global proc string swapDeepExr( string $inputPath)
{
	string $outputPath = $inputPath;
	if( endsWith( $outputPath, "deepexr" ) )
	{
		$outputPath = substring( $outputPath, 1, size( $outputPath ) - size( "deepexr" ) );
		$outputPath = $outputPath+"exr";
	}
	return $outputPath;
}

global proc string[] getArnoldElements()
{
	string $elementNames[] = {};

	int $aovMode = `getAttr "defaultArnoldRenderOptions.aovMode"`;
	int $mergeAOV = `getAttr "defaultArnoldDriver.mergeAOVs"`;
	string $imfType = getImfImageType();
	if( $aovMode  )
	{
		if( !$mergeAOV )
		{
			string $AOVnames[] = `ls -type aiAOV`;
			for($aovName in $AOVnames)
			{
				int $enabled = `getAttr ($aovName+".enabled")`;
				if($enabled == 1)
				{
					stringArrayInsertAtIndex(size( $elementNames ), $elementNames,$aovName);
				}
			}
		}
	}

	return $elementNames;
}

global proc string[] getArnoldElementNames()
{
	string $elementNames[] = {};

	string $elements[] = getArnoldElements();

	if( size($elements) == 0)
		return {""};

	stringArrayInsertAtIndex(0, $elementNames, "beauty" );
	for($aovName in $elements)
	{
		stringArrayInsertAtIndex(size($elementNames), $elementNames,`getAttr ($aovName+".name")`);
	}

	return $elementNames;
}

global proc string[] getArnoldElementDrivers()
{
	string $elementDrivers[] = {};

	string $elements[] = getArnoldElements();

	for($curAOV in $elements)
	{
		string $aovName = `getAttr ($curAOV+".name")`;
		string $aovDriver[] = `listConnections ($curAOV+".outputs[0].driver")`;
		string $aovExtension = `getAttr ($aovDriver[0]+".aiTranslator")`;

		stringArrayInsertAtIndex(size($elementDrivers), $elementDrivers,$aovDriver[0]+"@driver_"+$aovExtension+".RGBA."+$aovName+".filename");
	}

	return $elementDrivers;
}

global proc string[] getRedshiftElements()
{
	string $elementNames[] = {""};

	string $imfType = getImfImageType();
	int $forceExr = `getAttr "redshiftOptions.exrForceMultilayer"`;

	if( $imfType != "exr" || $forceExr == 0 )
	{
		string $REs[] = `ls -type RedshiftAOV`;

		for($RE in $REs)
		{
			int $enabled = `getAttr ($RE+".enabled")`;
			if($enabled == 1)
			{
				stringArrayInsertAtIndex(size( $elementNames ), $elementNames,$RE);
			}
		}
	}

	return $elementNames;
}

// In redshift4maya 2.6.13, redshift broke backwards compatibility by changing the function definition of
// redshiftGetAovImageName by adding $insertLightGroup.
//
// The MEL interpreter will attempt to check that the number of arguments passed to a function matches the function's
// definition. If the target function is not yet defined, this argument check is bypassed. This function may error
// depending on whether the redshift functions have been defined yet. If the functions exist, we are trying to define a
// function that calls redshiftGetAovImageName with the incorrect number of arguments, MEL will raise an error when
// evaluating this function definition. Using an "eval" statement is a work-around that will let you define the proc
// with a statement that calls an existing function without an incorrect number of arguments
global proc string deadlineRedshiftAovImageName( string $aovNode, int $temp, string $camera, int $insertLightGroup )
{
	string $redshiftVersion = `pluginInfo -q -version "redshift4maya"`;
	string $result = "";
	if( isVersionGreaterOrEqual($redshiftVersion, "2.6.13", ".") )
	{
		$result = `eval "redshiftGetAovImageName" $aovNode $temp $camera $insertLightGroup`;
	}
	else 
	{
		$result = `eval "redshiftGetAovImageName" $aovNode $temp $camera`;
	}
	return $result;
}

global proc string[] getRedshiftElementsUniquePaths( string $cam )
{
	$elements = getRedshiftElements();

	string $usedElements[];
	string $usedFilenames[];
	for ($element in $elements)
	{
		string $outputFilename = "";
		if( $element == "" )
		{
			$outputFilename = redshiftGetImageFormatString( 0, $cam );
		}
		else
		{
			$outputFilename = deadlineRedshiftAovImageName( $element, 0, $cam, false );
		}

		if( !stringArrayContains($outputFilename,$usedFilenames)  )
		{
			stringArrayInsertAtIndex(size( $usedFilenames ), $usedFilenames, $outputFilename);
			stringArrayInsertAtIndex(size( $usedElements ), $usedElements, $element);
		}
	}

	return $usedElements;
}

global proc string getRedshiftOutputFilename( int $replaceFrameNumber, int $newFrameNumber, string $outputDir, string $element, string $cam  )
{
	string $redshiftVersion = `pluginInfo -q -version "redshift4maya"`;

	string $paddingString = "#";
	if( $replaceFrameNumber )
	{
		$paddingString =  $newFrameNumber +"";
	}
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
		while( size($paddingString) < $paddingSize )
		{
			if( $replaceFrameNumber )
			{
				$paddingString = "0" + $paddingString;
			}
			else
			{
				$paddingString = "#" + $paddingString;
			}
		}
	}

	string $curImagesPath = `workspace -q -fre "images"`;
	workspace -fr "images" $outputDir;

	string $outputFilename = "";
	if( $element == "" )
	{
		$outputFilename = redshiftGetImageFormatString( 0, $cam );
	}
	else
	{
		$outputFilename = deadlineRedshiftAovImageName( $element, 0, $cam, false );
	}

	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		if( isVersionGreaterOrEqual($redshiftVersion, "2.6.37", ".") )
		{
			$outputFilename = `substitute "<frame>" $outputFilename $paddingString`;
		}
		else
		{
			$outputFilename = `substitute "#+" $outputFilename $paddingString`;
		}
	}

	workspace -fr "images" $curImagesPath;

	return $outputFilename;
}

global proc string getRedshiftOutputFilenameWithPrefix( int $replaceFrameNumber, int $newFrameNumber, string $outputDir, string $element, string $cam, string $prefix  )
{
	string $elementAttr = "defaultRenderGlobals.imageFilePrefix";

	if( $element != "" )
	{
		$elementAttr =  $element + ".filePrefix";
	}

	string $curPrefix = `getAttr $elementAttr`;

	setAttr -type "string" $elementAttr $prefix;
	string $outputFilename = getRedshiftOutputFilename( 1, $newFrameNumber, $outputDir, $element, $cam );

	setAttr -type "string" $elementAttr $curPrefix;
	return  $outputFilename;
}

global proc string[] getMentalRayElementNames( string $currentRenderLayer)
{
	string $elementNames[] = {""};
	//Format's in Maya are stored as integers.  For Mental ray EXR is stored as 51.
	int $exrFormat = 51;

	if( $currentRenderLayer != "" )
	{
		int $format = `getAttr defaultRenderGlobals.imageFormat`;
		string $prefix = `getAttr defaultRenderGlobals.imageFilePrefix`;

		//If the format is exr and there is not a renderPass token in the output prefix then the output is rendered as a single multichannel exr so we do not have to handle the elements separately.
		if ( $format != $exrFormat || `match "<RenderPass>" $prefix`!= "" )
		{
			string $renderLayers[] = {};
			$renderLayers = `ls -type renderLayer`;
			if( stringArrayContains($currentRenderLayer, $renderLayers) )
			{
				string $connectedPasses[] = `listConnections ($currentRenderLayer+".rps")`;
				if( size($connectedPasses) >0 )
				{
					$elementNames = {};
					stringArrayInsertAtIndex(size( $elementNames ), $elementNames, "MasterBeauty" );
					for( $pass in $connectedPasses )
					{
						stringArrayInsertAtIndex(size( $elementNames ), $elementNames,$pass );
					}
				}
			}
		}
	}

	return $elementNames;
}

proc int SetupDependentTileAssemblerJob( string $renderer, string $jobIds[], int $frameNumber, int $tilesInX, int $tilesInY, string $currentRenderLayer, string $currCamera )
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $currentRenderLayer != "" )
		$jobName += " - " + $currentRenderLayer;
	if( $currCamera != "" )
		$jobName += " - " + $currCamera;

	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	if(!$singleRegionJob)
	{
		$jobName = $jobName + "(Tile Assembly Job)";
	}
	else
	{
		$jobName = $jobName + "(Frame " + $frameNumber + " - Tile Assembly Job)";
	}

	string $outputFilePath = GetBaseOutputDirectory($renderer);

	int $submitEachCamera = `checkBox -q -v frw_submitEachCamera`;

	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";

	string $elements[] = {""};

	if( $renderer == "vray" )
	{
		$elements = getVRayElementNames();
	}
	else if( $renderer == "arnold" )
	{
		$elements = getArnoldElementNames();
	}
	else if( $renderer == "mentalRay" )
	{
		$elements = getMentalRayElementNames( $currentRenderLayer );
	}
	else if( $renderer == "redshift" )
	{
		$elements = getRedshiftElementsUniquePaths( $currCamera );
	}
	else if ( $renderer == "renderman22" )
	{
		$elements = getRendermanElements();
	}

	string $renderableCameras[] = deadlineGetRenderableCameras( false );

	string $submitFilename = "";
	string $jobFilename = "";
	string $configFilenames[];
	string $configFilename = "";

	int $draftMultiFrames[];

	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.

	int $totalTiles = $tilesInX * $tilesInY;
	int $currTile = 0;

	string $jobUUID = GetDeadlineUUID( 10 );
	$submitFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_info_" + $jobUUID + ".job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=DraftTileAssembler\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlinePool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_JobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_onComplete` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_Group` + "\n" );

	int $curFile = 0;
	for( $element in $elements  )
	{
		string $outputFilename = "";
		if( $renderer == "redshift" )
		{
			$outputFilename = getRedshiftOutputFilename( 1,$frameNumber, $outputFilePath, $element, $currCamera );
		}
		else
		{
			string $tempOutputDirectory = $outputFilePath;
			if( $renderer == "renderman22" )
			{
				$tempOutputDirectory = GetRendermanOutputDirectory($currentRenderLayer, $currCamera, $element);
			}
			string $outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
			$outputPrefix = swapDeepExr( $outputPrefix );
			$outputFilename = CheckSlashes( $tempOutputDirectory  + "/" + $outputPrefix );
		}
		fprint $fileId ( "OutputFilename"+$curFile+"=" + $outputFilename + "\n" );
		$curFile++;
	}

	string $jobIdString = stringArrayToString ($jobIds,",");
	fprint $fileId ( "JobDependencies=" + $jobIdString + "\n" );

	if($singleRegionJob)
		fprint $fileId ( "Frames=0-"+(`size($elements)` -1)+"\n" );
	else
		fprint $fileId ("Frames=0-"+(size($draftMultiFrames)-1)+"\n");

	fprint $fileId ( "ChunkSize=1\n" );
	fprint $fileId ( "MachineLimit=1\n" );

	if( `checkBox -q -value frw_isBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_machineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_machineList` + "\n" );


	fclose $fileId;
	$jobFilename = CheckSlashes( $tempDir + "/draft_tile_deadline_job_" + $jobUUID + ".job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	int $errorOnMissing = `checkBox -q -v frw_submitTileErrorOnMissing`;
	string $missing = $errorOnMissing ? "true" : "false";
	fprint $fileId ( "ErrorOnMissing=" +$missing+ "\n" );
	fprint $fileId ( "CleanupTiles=" + `checkBox -q -v frw_submitTileCleanupJob` + "\n" );
	if ( size($elements) > 1 )
		fprint $fileId ( "MultipleConfigFiles=true\n" );

	fclose $fileId;

	for( $element in $elements)
	{
		string $tempOutputDirectory = $outputFilePath;
		if( $renderer == "renderman22" )
		{
			$tempOutputDirectory = GetRendermanOutputDirectory( $currentRenderLayer, $currCamera, $element );
		}
		string $dateString = `date -format "YYYY_MM_DD_hh_mm_ss"`;
		string $outputPrefix = "";
		string $outputFilename = "";
		string $mayaOutputPrefix = "";
		string $baseName = "";
		if( $renderer == "redshift" )
		{
			$mayaOutputPrefix = getRedshiftOutputPrefix($element, $currCamera, $currentRenderLayer );

			if( $element == "" )
			{
				$outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
				$baseName = basenameEx( $outputPrefix );

			}
			else
			{
				string $aovParts[] = redshiftGetAovPathParts( $element, 0, $currCamera );
				$baseName = $aovParts[ 2 ] + "." +$frameNumber ;

			}
			$outputFilename = getRedshiftOutputFilename( 1, $frameNumber, $tempOutputDirectory, $element, $currCamera );
		}
		else
		{
			$outputPrefix = GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $currCamera, $element );
			$outputFilename = CheckSlashes( $tempOutputDirectory  + "/" + $outputPrefix );
			$baseName = basenameEx( $outputPrefix );
		}
		string $configDirectory = dirname( $outputFilename );

		if( $element == "" || $renderer == "vray" )
			$configFilename = CheckSlashes( $configDirectory  + "/"+$baseName+"_config_"+$dateString+".txt" );
		else
			$configFilename = CheckSlashes( $configDirectory  + "/" + $baseName + "_" + $element + "_config_"+$dateString+".txt" );

		sysFile -makeDir $configDirectory;
		$fileId = `fopen $configFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $configFilename + "\n" );

		int $currTile = 0;
		fprint $fileId ( "\n" );
		fprint $fileId ( "TileCount=" +$totalTiles+ "\n" );
		fprint $fileId ( "ImageFileName=" + $outputFilename + "\n" );
		fprint $fileId ( "ImageWidth=" +$width+ "\n" );
		fprint $fileId ( "ImageHeight=" + $height + "\n" );

		string  $imfType = GetImageType($renderer, $element);
		if( TilesAreCropped( $renderer, $imfType ) )
		{
			fprint $fileId ( "TilesCropped=False\n" );
		}
		else
		{
			fprint $fileId ( "TilesCropped=True\n" );
		}

		python( "dlTileGenerator = TileRendering.TileGenerator( " + $tilesInX + ", " + $tilesInY + ", " + $width + ", " + $height + ", returnSize=True)" );
		for( $y = 1; $y <= $tilesInY; $y++ )
		{
			for( $x = 1; $x <= $tilesInX; $x++ )
			{
				int $tileProps[] = python( "dlTileGenerator.getTile( ("+( $x - 1 )+","+( $y - 1 )+") )" );
				int $minX = $tileProps[0];
				int $width = $tileProps[1];
				int $minY = $tileProps[2];
				int $height = $tileProps[3];
				string $inputPrefix = "";
				string $inputImageFilename = "";
				if( $renderer == "redshift" )
				{
					$inputPrefix = GetTileOutputPrefix( $mayaOutputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
					$inputImageFilename = getRedshiftOutputFilenameWithPrefix(1, $frameNumber, $tempOutputDirectory, $element, $currCamera, $inputPrefix);
				}
				else
				{
					$inputPrefix = GetTileOutputPrefix( $outputPrefix, $x, $y, $tilesInX, $tilesInY, $renderer );
					$inputImageFilename = CheckSlashes( $tempOutputDirectory  + "/" + $inputPrefix );
				}

				if($singleRegionJob )
				{
					fprint $fileId ("Tile"+$currTile+"FileName="+$inputImageFilename+"\n");
					fprint $fileId ("Tile"+$currTile+"="+$inputImageFilename+"\n");

				}
				else
				{
					string $ext;
					$ext = `fileExtension $inputPrefix`;

					string $postFix = "."+$frameNumber+"."+$ext;

					string $base = basename( $inputPrefix, $postFix );
					fprint $fileId ("Tile"+$currTile+"Prefix="+$base+"\n");
				}

				fprint $fileId ( "Tile"+$currTile+"X="+$minX+"\n" );
				fprint $fileId ( "Tile"+$currTile+"Y="+$minY+"\n" );
				fprint $fileId ( "Tile"+$currTile+"Width="+$width+"\n" );
				fprint $fileId ( "Tile"+$currTile+"Height="+$height+"\n" );

				$currTile++;
			}
		}
		fclose $fileId;

		stringArrayInsertAtIndex(size( $configFilenames ), $configFilenames, $configFilename );
	}

	// Submit the job to Deadline
	string $submissionCommand = "\"" + $submitFilename + "\" \"" + $jobFilename + "\"";

	for($conFile in $configFilenames)
	{
		$submissionCommand = $submissionCommand+" \""+$conFile+"\"";
	}

	string $argList[] ;
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	for($conFile in $configFilenames)
	{
		$argList[size($argList)] = $conFile;
	}

	// Submit the job to Deadline
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
	string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	return 1;
}

// Sets some region rendering settings before submitting the job to Deadline.
proc int SetupRegionRenderingJob( string $renderer, string $cameraOverride )
{
	global string $DeadlineSubmitterWindow;
	global int $MayaRenderJobType;
	global int $JigsawRegionRenderType;
	global int $TileRegionRenderType;

	int $submitCounter = 0;

	AddStringAttribute( "deadlineRegionLeft" );
	AddStringAttribute( "deadlineRegionTop" );
	AddStringAttribute( "deadlineRegionRight" );
	AddStringAttribute( "deadlineRegionBottom" );
	AddLongAttribute( "deadlineCurrX" );
	AddLongAttribute( "deadlineCurrY" );
	AddLongAttribute( "deadlineCurrTile" );

	AddStringAttribute( "deadlineRegionSingleLeft" );
	AddStringAttribute( "deadlineRegionSingleTop" );
	AddStringAttribute( "deadlineRegionSingleRight" );
	AddStringAttribute( "deadlineRegionSingleBottom" );
	AddLongAttribute( "deadlineRegionSingleTiles" );

	int $taskLimit = `getAttr defaultRenderGlobals.DeadlineTaskLimit`;
	int $res[] = GetGlobalsResolution();
	int $width = $res[0];
	int $height = $res[1];
	if( $renderer == "vray" )
		$height = $height - 0; // vray is very picky about the height. Not width for some reason.

	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`;

	int $totalTiles = $tilesInX * $tilesInY;
	int $currTile = 0;

	string $camera = "";
	if( $cameraOverride != "" )
		$camera = $cameraOverride;
	else
	{
		string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
		string $cameraNames[] = `listTransforms -cameras`;
		for( $cameraName in $cameraNames )
		{
			if( $cameraName == $selectedCamera )
			{
				$camera = $selectedCamera;
				break;
			}
		}
	}

	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	int $regions[];
	int $assemblyRegions[];

	string $jobIdList[];
	if( !$singleRegionJob )
	{
		if($regionType == $TileRegionRenderType)
		{
			python( "dlTileGenerator = TileRendering.TileGenerator( " + $tilesInX + ", " + $tilesInY + ", " + $width + ", " + $height + ", origin='" + getRenderOriginLocation( $renderer ) + "', exclusiveRanges=" + getRenderExclusiveRanges( $renderer ) + ")" );
			for( $y = 1; $y <= $tilesInY; $y++ )
			{
				for( $x = 1; $x <= $tilesInX; $x++ )
				{
					int $tileProps[] = python( "dlTileGenerator.getTile( ("+( $x - 1 )+","+( $y - 1 )+") );" );
					int $minX = $tileProps[0];
					int $maxX = $tileProps[1];
					int $minY = $tileProps[2];
					int $maxY = $tileProps[3];
					
					setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" $minX;
					setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $maxX;
					setAttr defaultRenderGlobals.deadlineRegionTop -type "string" $minY;
					setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $maxY;

					setAttr defaultRenderGlobals.deadlineCurrX ( $x );
					setAttr defaultRenderGlobals.deadlineCurrY ( $y );
					setAttr defaultRenderGlobals.deadlineCurrTile ( $currTile );

					string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
					if($jobId != "")
					{
						stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
						$submitCounter++;
					}

					$currTile++;
				}
			}
		}
		else
		{

			if(catchQuiet(`python("jigsawThread.isAlive()")`))
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}

			if(`python("jigsawThread.isAlive()")`)
			{
				python("jigsawThread.requestSave()");
				//Jigsaw uses an inverted coordinate system when compared to Draft and the common tilerendering code
				int $jigsawInverted = IsRegionRenderingInverted( $renderer );
				$regions = `python("jigsawThread.getRegions(" + $jigsawInverted + ")")`;
				$assemblyRegions = `python("jigsawThread.getRegions()")`;
			}
			else
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}

			string $regionLeftValues[];
			string $regionRightValues[];
			string $regionTopValues[];
			string $regionBottomValues[];
			string $frameList = `textFieldGrp -q -text frw_FrameList`;
			int $frameRange[] = GetFramesArray($frameList);
			int $numRegions = size($regions)/4;

			int $renderHeight = `getAttr "defaultResolution.height"`;
			int $renderWidth = `getAttr "defaultResolution.width"`;

			for($curRegion =0;$curRegion<$numRegions;$curRegion++)
			{
				int $top = ($regions[$curRegion*4+2]);
				int $right = ($regions[$curRegion*4+1]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "renderman22" || $renderer == "ifmIrayPhotoreal" )
				{
					$right++;
				}

				int $left = ($regions[$curRegion*4]);
				int $bottom = ($regions[$curRegion*4+3]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "renderman22" )
				{
					$bottom++;
				}

				if($renderer == "arnold")
				{
					if( $right == $renderWidth )
					{
						$right -=1;
					}

					if( $bottom == $renderHeight )
					{
						$bottom -=1;
					}
				}

				if(`size($regionLeftValues)` == $curRegion)
				{
					stringArrayInsertAtIndex($curRegion, $regionLeftValues, ""+$left);
					stringArrayInsertAtIndex($curRegion, $regionTopValues, ""+ $top);
					stringArrayInsertAtIndex($curRegion, $regionRightValues, ""+ $right);
					stringArrayInsertAtIndex($curRegion, $regionBottomValues, ""+ $bottom);
				}
				else
				{
					$regionLeftValues[$curRegion] = $regionLeftValues[$curRegion] +","+ $left;
					$regionTopValues[$curRegion] = $regionTopValues[$curRegion] +","+ $top;
					$regionRightValues[$curRegion] = $regionRightValues[$curRegion] +","+ $right;
					$regionBottomValues[$curRegion] = $regionBottomValues[$curRegion] +","+ $bottom;
				}
			}

			for( $i=0; $i<size($regionLeftValues);$i++)
			{
				setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" ($regionLeftValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionTop -type "string" ($regionTopValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionRight -type "string" ($regionRightValues[$i]);
				setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" ($regionBottomValues[$i]);

				setAttr defaultRenderGlobals.deadlineCurrTile $currTile;
				string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
				if($jobId != "")
				{
					stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
					$submitCounter++;
				}
				$currTile++;
			}
			string $assemblyRegionLeftValues[];
			string $assemblyRegionRightValues[];
			string $assemblyRegionTopValues[];
			string $assemblyRegionBottomValues[];

			for($curRegion =0;$curRegion<$numRegions;$curRegion++)
			{
				int $assemblyTop = ($assemblyRegions[$curRegion*4+2]);
				int $assemblyRight = ($assemblyRegions[$curRegion*4+1]);
				int $assemblyLeft = ($assemblyRegions[$curRegion*4]);
				int $assemblyBottom = ($assemblyRegions[$curRegion*4+3]);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionLeftValues, ""+$assemblyLeft);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionTopValues, ""+ $assemblyTop);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionRightValues, ""+ $assemblyRight);
				stringArrayInsertAtIndex($curRegion, $assemblyRegionBottomValues, ""+ $assemblyBottom);
			}

			string $regionString = stringArrayToString($assemblyRegionLeftValues,";");
			setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionTopValues,";");
			setAttr defaultRenderGlobals.deadlineRegionTop -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionRightValues,";");
			setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $regionString;
			$regionString = stringArrayToString($assemblyRegionBottomValues,";");
			setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $regionString;
		}

		int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
		if( $submitDependentJob && $submitCounter > 0 )
		{
			int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
			if( IsRenderLayersOn() && !$submitEachRenderLayer )
			{
				// Store the currently selected render layer
				string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
				string $renderLayerList[] = getRenderableRenderLayers();

				// Loop through the render layer if the checkbox is on
				for( $layer in $renderLayerList )
				{
					// Select the render layer to make sure the render settings are updated
					if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
					{
						if( $camera != "" )
						{
							int $count = SetupDependentTileAnimationAssemblerJob( $renderer, $jobIdList, $layer, $camera );
							$submitCounter += $count;
						}
						else
						{
							string $cameraNames[] = deadlineGetRenderableCameras( false );
							for( $cameraName in $cameraNames )
							{
								int $count = SetupDependentTileAnimationAssemblerJob( $renderer, $jobIdList, $layer, $cameraName );
								$submitCounter += $count;
							}
						}
					}
				}

				// Reselect the current render layer
				editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			}
			else
			{
				string $currentRenderLayer = "";
				if( IsRenderLayersOn() && $submitEachRenderLayer )
					$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;

				if( $camera != "" )
				{
					int $count = SetupDependentTileAnimationAssemblerJob( $renderer, $jobIdList, $currentRenderLayer, $camera );
					$submitCounter += $count;
				}
				else
				{
					string $cameraNames[] = deadlineGetRenderableCameras( false );
					for( $cameraName in $cameraNames )
					{
						int $count = SetupDependentTileAnimationAssemblerJob( $renderer, $jobIdList, $currentRenderLayer, $cameraName );
						$submitCounter += $count;
					}
				}
			}
		}
	}
	else
	{
		setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" "";
		setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" "";

		if($regionType == $TileRegionRenderType)
		{
			if($tilesInX * $tilesInY > $taskLimit)
			{
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Unable to submit job with " + ($tilesInX * $tilesInY) + " tasks.  Task Count exceeded Job Task Limit of "+$taskLimit) -button "Close";
				return 0;
			}

			python( "dlTileGenerator = TileRendering.TileGenerator( " + $tilesInX + ", " + $tilesInY + ", " + $width + ", " + $height + ", origin='" + getRenderOriginLocation( $renderer ) + "', exclusiveRanges=" + getRenderExclusiveRanges( $renderer ) + ")" );
			for( $y = 1; $y <= $tilesInY; $y++ )
			{
				for( $x = 1; $x <= $tilesInX; $x++ )
				{
					int $tileProps[] = python( "dlTileGenerator.getTile( ("+( $x - 1 )+","+( $y - 1 )+"));" );
					int $minX = $tileProps[0];
					int $maxX = $tileProps[1];
					int $minY = $tileProps[2];
					int $maxY = $tileProps[3];

					string $regionSingleLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
					$regionSingleLeft += "RegionLeft" + $currTile + "=" + $minX + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" $regionSingleLeft;

					string $regionSingleRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
					$regionSingleRight += "RegionRight" + $currTile + "=" + $maxX + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" $regionSingleRight;

					string $regionSingleTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
					$regionSingleTop += "RegionTop" + $currTile + "=" + $minY + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" $regionSingleTop;

					string $regionSingleBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
					$regionSingleBottom += "RegionBottom" + $currTile + "=" + $maxY + "\n";
					setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" $regionSingleBottom;

					$currTile++;
				}
			}
		}
		else
		{
			if(catchQuiet(`python("jigsawThread.isAlive()")`))
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}

			if(`python("jigsawThread.isAlive()")`)
			{
				python("jigsawThread.requestSave()");
				//Jigsaw uses an inverted coordinate system when compared to Draft and the common tilerendering code
				int $jigsawInverted = IsRegionRenderingInverted( $renderer );
				$regions = `python("jigsawThread.getRegions(" + $jigsawInverted + ")")`;
				$assemblyRegions = `python("jigsawThread.getRegions()")`;
			}
			else
			{
				confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
				return 0;
			}

			if(size($regions)/4 > $taskLimit)
			{
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Unable to submit job with " + (size($regions)/4) + " tasks.  Task Count exceeded Job Task Limit of "+$taskLimit) -button "Close";
				return 0;
			}

			int $renderHeight = `getAttr "defaultResolution.height"`;
			for( $i=0; $i<size($regions)/4;$i++)
			{
				int $tempRight = ($regions[$i*4+1]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "renderman22" || $renderer == "ifmIrayPhotoreal"  )
					$tempRight++;

				int $tempBottom = ($regions[$i*4+3]-1);
				if( $renderer == "mentalRay" || $renderer == "renderMan" || $renderer == "renderManRIS" || $renderer == "renderman22" || $renderer == "ifmIrayPhotoreal" )
						$tempBottom++;

				string $regionSingleLeft = `getAttr defaultRenderGlobals.deadlineRegionSingleLeft`;
				$regionSingleLeft += "RegionLeft" + $currTile + "=" + ($regions[$i*4]) + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleLeft -type "string" $regionSingleLeft;

				string $regionSingleRight = `getAttr defaultRenderGlobals.deadlineRegionSingleRight`;
				$regionSingleRight += "RegionRight" + $currTile + "=" + $tempRight + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleRight -type "string" $regionSingleRight;

				string $regionSingleTop = `getAttr defaultRenderGlobals.deadlineRegionSingleTop`;
				$regionSingleTop += "RegionTop" + $currTile + "=" + ($regions[$i*4+2]) + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleTop -type "string" $regionSingleTop;

				string $regionSingleBottom = `getAttr defaultRenderGlobals.deadlineRegionSingleBottom`;
				$regionSingleBottom += "RegionBottom" + $currTile + "=" + $tempBottom + "\n";
				setAttr defaultRenderGlobals.deadlineRegionSingleBottom -type "string" $regionSingleBottom;

				$currTile++;
			}
		}

		setAttr defaultRenderGlobals.deadlineRegionSingleTiles $currTile;

		string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 1, $MayaRenderJobType, $camera );
		if( $jobId != "" )
		{
			stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId);
			$submitCounter++;
		}

		int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
		if( $submitDependentJob && $submitCounter > 0 )
		{
			int $frameNumber = `intSliderGrp -q -v frw_tileSingleFrame`;

			int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
			if( IsRenderLayersOn() && !$submitEachRenderLayer )
			{
				// Store the currently selected render layer
				string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
				string $renderLayerList[] = getRenderableRenderLayers();

				// Loop through the render layer if the checkbox is on
				for( $layer in $renderLayerList )
				{
					// Select the render layer to make sure the render settings are updated
					if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
					{
						if( $camera != "" )
						{
							if($regionType == $TileRegionRenderType)
							{
								int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $layer, $camera );
								$submitCounter += $count;
							}
							else
							{

								int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $layer, $camera );
								$submitCounter += $count;
							}
						}
						else
						{

							string $cameraNames[] = deadlineGetRenderableCameras( false );
							for( $cameraName in $cameraNames )
							{
								string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frameNumber, $layer, $cameraName, "" ) );

								if($regionType == $TileRegionRenderType)
								{
									int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $layer, $cameraName );
									$submitCounter += $count;
								}
								else
								{
									int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $layer, $cameraName );
									$submitCounter += $count;
								}
							}
						}
					}
				}

				// Reselect the current render layer
				editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			}
			else
			{
				string $currentRenderLayer = "";
				if( IsRenderLayersOn() && $submitEachRenderLayer )
					$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;

				if( $camera != "" )
				{
					if($regionType == $TileRegionRenderType)
					{
						int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $currentRenderLayer, $camera );
						$submitCounter += $count;
					}
					else
					{
						int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $currentRenderLayer, $camera );
						$submitCounter += $count;
					}
				}
				else
				{
					string $cameraNames[] = deadlineGetRenderableCameras( false );
					for( $cameraName in $cameraNames )
					{
						string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frameNumber, $currentRenderLayer, $cameraName, "") );
						if($regionType == $TileRegionRenderType)
						{
							int $count = SetupDependentTileAssemblerJob( $renderer, $jobIdList, $frameNumber, $tilesInX, $tilesInY, $currentRenderLayer, $cameraName );
							$submitCounter += $count;
						}
						else
						{
							int $count = SetupDependentJigsawAssemblerJob( $renderer, $jobIdList, $frameNumber, $assemblyRegions, $currentRenderLayer, $cameraName );
							$submitCounter += $count;
						}
					}
				}
			}
		}
	}
	return $submitCounter;
}

proc int SetupMentalRayExportJob( string $renderer )
{
	global int $MentalRayExportJobType;

	int $submitCounter = 0;

	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $MentalRayExportJobType, "" );

	$submitCounter++;

	int $submitDependentJob = `checkBox -q -v frw_submitMentalRayJob`;
	if( $submitDependentJob )
	{
		string $frameList = `textFieldGrp -q -text frw_FrameList`;
		string $outputFilePath = GetBaseOutputDirectory($renderer);

		int $perlayer = `checkBoxGrp -query -value1 MayatomrExport_FilePerLayer`;
		int $perframe = `checkBoxGrp -query -value1 MayatomrExport_FilePerFrame`;
		int $padframe = 0;
		int $format = 0;
		if( $perframe )
		{
			$format = `optionMenuGrp -q -select MayatomrExport_FrameExtension`;
			$padframe = `intFieldGrp -q -value1 MayatomrExport_FramePadding`;
			if ($padframe > 9)
				$padframe = 9;
		}

		string $inputPath = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
		string $inputDirectory = dirname( $inputPath ) + "/";
		string $inputFilename = basenameEx( $inputPath );
		string $inputExtension = fileExtension( $inputPath );

		string $padding = "";
		if( $perframe )
		{
			$padding = match( "[0-9]+", $frameList );
			while( size($padding) < $padframe )
				$padding = "0" + $padding;
		}


		string $renderLayerList[] = getRenderableRenderLayers();
		for( $i = 0; $i < size( $renderLayerList ); $i++ )
		{
			string $jobName = `textFieldGrp -q -text frw_JobName`;

			if( $perlayer )
			{
					$jobName = $jobName + " - " + $renderLayerList[$i];
			}

			string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";

			string $jobUUID = GetDeadlineUUID( 10 );
			string $submitFilename = CheckSlashes( $tempDir + "/mr_deadline_info_" + $jobUUID + ".job" );
			$fileId = `fopen $submitFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

			fprint $fileId ( "Plugin=MentalRay\n" );
			fprint $fileId ( "Name=" + $jobName + "\n" );
			fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
			fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
			fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineMentalPool` + "\n" );
			fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineMentalSecondaryPool` + "\n" );
			fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_MentalJobPriority` + "\n" );
			fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_MentalOnComplete` + "\n" );
			fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_MentalSlaveTimeout` + "\n" );
			fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MentalMinSlaveTimeout` + "\n" );
			fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_MentalAutoTaskTimeout` + "\n" );
			fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_MentalConcurrentTasks` + "\n" );
			fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
			fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_MentalGroup` + "\n" );
			fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_MentalLimitCount` + "\n" );
			fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_MentalLimitGroups` + "\n" );
			fprint $fileId ( "OutputDirectory0=" + $outputFilePath + "\n" );
			fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
			fprint $fileId ( "Frames=" + $frameList + "\n" );
			fprint $fileId ( "ChunkSize=1\n" );

			if( `checkBox -q -value frw_MentalIsBlacklist` )
				fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_MentalMachineList` + "\n" );
			else
				fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_MentalMachineList` + "\n" );


			fclose $fileId;

			$layer = "";

			// The layer name is only appended if there is more than one layer in the list.
			if( $perlayer && IsRenderLayersOn() )
			{

				$layer = GetRenderLayerDisplayName( $renderLayerList[$i] );
				$layer = "_" + $layer;
			}

			if( $perframe )
			{
				if( $format == 1 )
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $inputExtension + "." + $padding;
				else if( $format == 2 )
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $padding + "." + $inputExtension;
				else
					$inputPath = $inputDirectory + $inputFilename + $layer + "." + $padding;
			}
			else
				$inputPath = $inputDirectory + $inputFilename + $layer + "." + $inputExtension;

			string $jobFilename = CheckSlashes( $tempDir + "/mr_deadline_job_" + $jobUUID + ".job" );
			$fileId = `fopen $jobFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

			fprint $fileId ( "InputFile=" + $inputPath + "\n" );
			fprint $fileId ( "SeparateFilesPerFrame=" + $perframe + "\n" );
			if( $perframe )
				fprint $fileId ( "StartFrameOffset=" + `intSliderGrp -q -v frw_mentalRayOffset` + "\n" );
			fprint $fileId ( "OutputPath=" + $outputFilePath + "\n" );
			fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_mentalRayThreads` + "\n" );
			fprint $fileId ( "LocalRendering=" + `checkBox -q -v frw_mentalRayLocalRendering` + "\n" );
			fprint $fileId ( "Build=" + `optionMenuGrp -q -value frw_mentalRayBuild` + "\n" );
			fprint $fileId ( "Verbose=5\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_mentalRayArgs` + "\n" );
			fclose $fileId;

			string $argList[];
			$argList[0] = $submitFilename;
			$argList[1] = $jobFilename;

			// Submit the job to Deadline
			string $batchName = `textFieldGrp -q -text frw_JobName`;
			ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
			string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
			string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

			// Show results
			print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );

			$submitCounter++;

			if( !$perlayer )
				break;
		}
	}

	return $submitCounter;
}

proc string[] get_all_filename_attributes_from_yeti_objects( ) {
	string $yetiAttrNames[];
	if( `pluginInfo -query -loaded "pgYetiMaya"` == 0 ){
		return $yetiAttrNames;
	}
	//Currently we're supporting Yeti's texture node's "file_name" attribute, and Yeti's reference node's "reference_file" attribute.
	//Maybe in the future this could be expanded to be more general if needed.


	string $yetiShapesArray[] = `ls -type "pgYetiMaya"`;
	string $yetiShapesArrayFeather[] = `ls -type "pgYetiMayaFeather"`; //I really think only pgYetiMaya nodes can have a Yeti graph. But I don't know. Maybe these other two types can too. I have them in here just for safe measure.
	string $yetiShapesArrayGroom[] = `ls -type "pgYetiGroom"`;
	appendStringArray( $yetiShapesArray, $yetiShapesArrayFeather, size($yetiShapesArrayFeather) );
	appendStringArray( $yetiShapesArray, $yetiShapesArrayGroom, size($yetiShapesArrayGroom) );

	for( $yetiShape in $yetiShapesArray ) {

		string $yetiTextureNodeList[0];
		catch( $yetiTextureNodeList = `pgYetiGraph -listNodes -type "texture" $yetiShape` );
		for( $yetiTextureNode in $yetiTextureNodeList ) {
			$attrVal = `pgYetiGraph -node $yetiTextureNode -param "file_name" -getParamValue $yetiShape`;
			$attrName = $yetiShape + "." + $yetiTextureNode + ".file_name"; //Make it a period separted attribute name. This is just for convenience. Later on in the code we will split this out into 3 parts again.
			$yetiAttrNames[ size($yetiAttrNames) ] = $attrName;
		}

		$yetiReferenceNodeList = `pgYetiGraph -listNodes -type "reference" $yetiShape`;
		for( $yetiReferenceNode in$yetiReferenceNodeList ) {
			$attrVal = `pgYetiGraph -node $yetiReferenceNode -param "reference_file" -getParamValue $yetiShape`;
			$attrName = $yetiShape + "." + $yetiReferenceNode + ".reference_file"; //Make it a period separted attribute name. This is just for convenience. Later on in the code we will split this out into 3 parts again.
			$yetiAttrNames[ size($yetiAttrNames) ] = $attrName;
		}
	}

	return $yetiAttrNames;
}

proc string getYetiSearchPath( string $nodeName ) {
	string $yetiValues[];

	$yetiValues = stringToStringArray( $nodeName, "." ); // 3 period separated values
	string $yetiFullPath = `pgYetiGraph -node $yetiValues[1] -param $yetiValues[2] -getParamValue $yetiValues[0]`;

	return dirname( $yetiFullPath );


}

proc string[] getYetiSearchPaths()
{
	string $yetiSearchPaths[];
	string $yetiAttrNames[] = get_all_filename_attributes_from_yeti_objects();

	for( $yetiAttr in $yetiAttrNames )
	{
		$yetiSearchPaths[ size($yetiSearchPaths) ] = getYetiSearchPath( $yetiAttr );
	}

	return stringArrayRemoveDuplicates( $yetiSearchPaths );
}

proc writeYetiSearchPaths( int $fileId )
{
	string $searchPaths[] = getYetiSearchPaths();

	int $pathCount = 0;
	for( $searchPath in $searchPaths )
	{
		fprint $fileId ( "YetiSearchPath" + $pathCount + "=" + CheckSlashes( $searchPath ) + "\n" );
		$pathCount++;
	}
}

proc int SubmitDependentVRayJob( string $postfix, string $jobId )
{
	int $submitCounter = 0;
	float $vrayVersion = GetVRayVersion();

	int $submitLayers = false;
	string $currentRenderLayer = "";
	string $renderLayerList[] = {""};

	if( IsRenderLayersOn() )
	{
		$currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		$renderLayerList = getRenderableRenderLayers();
		$submitLayers = true;
	}

	for( $layer in $renderLayerList )
	{
		string $jobName = `textFieldGrp -q -text frw_JobName`;
		if( $postfix != "" )
			$jobName = $jobName + " (" + $postfix + ")";

		int $perframe = `getAttr( "vraySettings.misc_eachFrameInFile" )`;
		string $frameList = `textFieldGrp -q -text frw_FrameList`;

		string $inputPath = ForceRenderLayerToken( CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` ) );
		string $inputDirectory = dirname( $inputPath ) + "/";
		string $inputFilename = basenameEx( $inputPath );
		string $inputPadding = "";
		string $inputExtension = fileExtension( $inputPath );
		if( $inputExtension == "" )
			$inputExtension = "vrscene";

		if( $perframe )
			$inputPadding = "_0000";
		if( $postfix != "" )
			$inputFilename = $inputFilename + "_" + $postfix;

		if( $submitLayers )
		{
			// Select the render layer to make sure the render settings are updated
			if( catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
				continue;

			string $renderLayerName = $layer;
			if( $vrayVersion >= 3.6 )
			{
				// V-Ray 3.6 now strips the "rs_", and defaultRenderLayer must change to masterLayer
				$renderLayerName = GetRenderLayerDisplayName( $layer );
				if( floor( MayaVersion() * 10 ) / 10 == 2016.5 )
				{
					// renderLayerDisplayName didn't exist in 2016.5 (when Render Setups were introduced), but we still need to remove the "rs_"
					string $prefix = "rs_";
					if( startsWith( $layer, $prefix ) )
					{
						// Starting position is randomly 1-indexed...
						$renderLayerName = substring( $layer, size( $prefix ) + 1, size( $layer ) );
					}
					else
					{
						$renderLayerName = $layer;
					}
				}
			}
			else if( $vrayVersion < 3.6 )
			{
				// V-Ray does not strip "rs_ from" the layer, but defaultRenderLayer must change to masterLayer
				if( $layer == "defaultRenderLayer" )
				{
					$renderLayerName = "masterLayer";
				}
				else
				{
					$renderLayerName = $layer;
				}
			}

			// tokens V-Ray accepts in its paths
			string $layerTokens[] = { "<Layer>", "<layer>", "%l" };
			for( $layerToken in $layerTokens )
			{
				$inputFilename = substituteAllString( $inputFilename, $layerToken, $renderLayerName );
			}

			$jobName = $jobName + " - " + $renderLayerName;
		}

		$inputPath = $inputDirectory + $inputFilename + $inputPadding + "." + $inputExtension;

		string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", "", "" ) );
		string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );
		string $userDefinedPrefix = `getAttr vraySettings.fileNamePrefix`;
		string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";

		string $jobUUID = GetDeadlineUUID( 10 );
		string $submitFilename = CheckSlashes( $tempDir + "/vray_deadline_info_" + $jobUUID + ".job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

		fprint $fileId ( "Plugin=Vray\n" );
		fprint $fileId ( "Name=" + $jobName + "\n" );
		string $batchName = `textFieldGrp -q -text frw_JobName`;
		//This will group the jobs created later in the same batch
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineVrayPool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineVraySecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_VrayJobPriority` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_VraySlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_VrayMinSlaveTimeout` + "\n" );
		fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_VrayAutoTaskTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_VrayConcurrentTasks` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_VrayOnComplete` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_VrayGroup` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_VrayLimitCount` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_VrayLimitGroups` + "\n" );

		// Deadline does not handle frame numbers in the directory portion of the output path
		if( !`isValidString $outputFilePath ".*#.*"` )
		{
			// We cannot communicate the filename to Deadline when there are consecutive hash characters
			// VRay will output the full padded frame number without any delimiter and Deadline does
			// not handle this
			
			if( !`isValidString $userDefinedPrefix ".*##.*"` )
			{
				fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );
			}
			else {
				// We can provide Deadline with the output directory
				fprint $fileId ( "OutputDirectory0=" + $outputFilePath + "\n" );
			}
		}
		fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
		fprint $fileId ( "Frames=" + $frameList + "\n" );
		fprint $fileId ( "ChunkSize=1\n" );

		if( `checkBox -q -value frw_VrayIsBlacklist` )
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );
		else
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );


		fclose $fileId;

		string $jobFilename = CheckSlashes( $tempDir + "/vray_deadline_job_" + $jobUUID + ".job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

		fprint $fileId ( "InputFilename=" + $inputPath + "\n" );
		fprint $fileId ( "SeparateFilesPerFrame=" + $perframe + "\n" );
		fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_vrayThreads` + "\n" );
		fprint $fileId ( "Width=0\n" );
		fprint $fileId ( "Height=0\n" );
		writeYetiSearchPaths( $fileId );
		//fprint $fileId ( "OutputFilename=" + $outputFilePath + "\n" );
		fclose $fileId;

		string $argList[] ;
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;

		// Submit the job to Deadline
		ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
		string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

		$submitCounter++;

		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );

		int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
		if( `checkBox -q -v frw_submitVrimg2ExrJob` && $submitDependentJob  )
		{
			if( fileExtension( $outputFilename ) == "vrimg" )
			{
				// Parse the standard output from the V-Ray stand-alone job to get the job ID
				string $vrayJobId = parseJobIDFromSubmissionOutput( $submitResults );

				string $convertJobId = "";
				string $jobIdRegEx = "[a-z,A-Z,0-9]+_[0-9]+_[a-z,A-Z,0-9]+_[0-9,a-f,A-F]+";
				$matches = `match $jobIdRegEx $submitResults`;
				if( size( $matches ) > 0 )
					$convertJobId = $matches;

				string $vrimgPrefix = CheckSlashes( GetOutputPrefix( 1, 0, "", "", "" ) );
				string $inputVrimgFilename = CheckSlashes( $outputFilePath  + "/" + $vrimgPrefix );

				string $outputExrDirectory = dirname( $inputVrimgFilename );
				string $outputExrPrefix = basename( CheckSlashes( GetOutputPrefix( 0, 0, "", "", "" ) ), ".vrimg" );
				string $outputExrFilename = CheckSlashes( $outputExrDirectory  + "/" + $outputExrPrefix + ".exr" );

				$jobName = $jobName + " - Conversion Job";

				$jobUUID = GetDeadlineUUID( 10 );
				string $convertSubmitFilename = CheckSlashes( $tempDir + "/vrimg_deadline_info_" + $jobUUID + ".job" );
				$fileId = `fopen $convertSubmitFilename "w"`;
				if( $fileId == 0 )
					print( "Error in Deadline Submission Script: could not create " + $convertSubmitFilename + "\n" );

				fprint $fileId ( "Plugin=Vrimg2Exr\n" );
				fprint $fileId ( "Name=" + $jobName + "\n" );
				fprint $fileId ( "BatchName=" + `textFieldGrp -q -text frw_JobName` + "\n" );
				fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
				fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
				fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineVrayPool` + "\n" );
				fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineVraySecondaryPool` + "\n" );
				fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_VrayGroup` + "\n" );
				fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_VrayJobPriority` + "\n" );
				fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_VrayLimitGroups` + "\n" );
				fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_VrayOnComplete` + "\n" );
				fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_VrayLimitCount` + "\n" );
				fprint $fileId ( "Frames=" + $frameList + "\n" );
				fprint $fileId ( "ChunkSize=1\n" );
				fprint $fileId ( "OutputFilename0=" + $outputExrFilename + "\n" );
				fprint $fileId ( "JobDependencies=" + $vrayJobId + "\n" );

				if( `checkBox -q -value frw_VrayIsBlacklist` )
					fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );
				else
					fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_VrayMachineList` + "\n" );


				fclose $fileId;

				string $convertPluginFilename = CheckSlashes( $tempDir + "/vrimg_plugin_info_" + $jobUUID + ".job" );
				$fileId = `fopen $convertPluginFilename "w"`;
				if( $fileId == 0 )
					print( "Error in Deadline Submission Script: could not create " + $convertPluginFilename + "\n" );

				string $vrimg2exrInputFilename = TxVrimg2exrDeadlineFilename( CheckSlashes( $outputFilename ) );
				if( `about -ntOS` )
					$vrimg2exrInputFilename = `substituteAllString $vrimg2exrInputFilename "/" "\\"`;
				fprint $fileId ( "InputFile=" + $vrimg2exrInputFilename + "\n" );
				fprint $fileId ( "OutputFile=\n" );
				fprint $fileId ( "Half=False\n" );
				fprint $fileId ( "sRGB=False\n" );
				fprint $fileId ( "DataWindow=True\n" );
				fprint $fileId ( "SeparateFiles=False\n" );
				fprint $fileId ( "MultiPart=False\n" );
				fprint $fileId ( "SetGamma=False\n" );
				fprint $fileId ( "Gamma=1.8\n" );
				fprint $fileId ( "SetChannel=False\n" );
				fprint $fileId ( "Channel=\n" );
				fprint $fileId ( "LongChanNames=False\n" );
				fprint $fileId ( "SetCompression=False\n" );
				fprint $fileId ( "Compression=zip\n" );
				fprint $fileId ( "SetBufferSize=False\n" );
				fprint $fileId ( "BufferSize=10\n" );
				fprint $fileId ( "Threads=0\n" );

				if( `checkBox -q -v frw_deleteVrimgFiles` )
					fprint $fileId ( "DeleteInputFiles=True\n" );
				else
					fprint $fileId ( "DeleteInputFiles=False\n" );

				fclose $fileId;

				// Submit the job to Deadline
				string $batchName = `textFieldGrp -q -text frw_JobName`;
				ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
				string $convertSubmissionCommand = "\"" + $convertSubmitFilename + "\" \"" + $convertPluginFilename + "\"";
				string $convertSubmitResults = CallDeadlineCommand( $convertSubmissionCommand, true );

				// Show results
				print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $convertSubmitResults + "\n" );

				$submitCounter++;
			}
			else
				print( "\n\nWARNING: Vrimg2Exr job not submitted because output format is not vrimg\n" );
		}
	}

	if( $submitLayers )
	{
		// Reselect the current render layer
		editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
	}

	return $submitCounter;
}

proc int SetupVRayExportJob( string $renderer )
{
	global int $VRayExportJobType;

	int $submitCounter = 0;

	//string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, 0, 1, 0, "" );
	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $VRayExportJobType, "" );

	$submitCounter++;

	int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
	if( $submitDependentJob )
	{
		// Dependent job does not support the Separate Files option.
		if( !`getAttr( "vraySettings.misc_separateFiles" )` )
		{
			$submitCounter = $submitCounter + SubmitDependentVRayJob( "", $jobId );
		}

		//~ SubmitDependentVRayJob( "", $jobId );
		//~ $submitCounter++;

		//~ if( `getAttr( "vraySettings.misc_separateFiles" )` )
		//~ {
			//~ int $exportLights = `getAttr( "vraySettings.misc_exportLights" )`;
			//~ if( $exportLights )
			//~ {
				//~ SubmitDependentVRayJob( "lights", $jobId );
				//~ $submitCounter++;
			//~ }

			//~ int $exportNodes = `getAttr( "vraySettings.misc_exportNodes" )`;
			//~ if( $exportNodes )
			//~ {
				//~ SubmitDependentVRayJob( "nodes", $jobId );
				//~ $submitCounter++;
			//~ }

			//~ int $exportGeometry = `getAttr( "vraySettings.misc_exportGeometry" )`;
			//~ if( $exportGeometry )
			//~ {
				//~ $submitCounter++;
				//~ SubmitDependentVRayJob( "geometry", $jobId );
			//~ }

			//~ int $exportMaterials = `getAttr( "vraySettings.misc_exportMaterials" )`;
			//~ if( $exportMaterials )
			//~ {
				//~ SubmitDependentVRayJob( "materials", $jobId );
				//~ $submitCounter++;
			//~ }

			//~ int $exportTextures = `getAttr( "vraySettings.misc_exportTextures" )`;
			//~ if( $exportTextures )
			//~ {
				//~ SubmitDependentVRayJob( "textures", $jobId );
				//~ $submitCounter++;
			//~ }

			//~ int $exportBitmaps = `getAttr( "vraySettings.misc_exportBitmaps" )`;
			//~ if( $exportBitmaps )
			//~ {
				//~ SubmitDependentVRayJob( "bitmaps", $jobId );
				//~ $submitCounter++;
			//~ }
		//~ }
	}

	return $submitCounter;
}

proc int SetupArnoldKickRegionJob(string $jobId, string $camera, string $renderLayer)
{
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;

	global int $TileRegionRenderType;
	global int $JigsawRegionRenderType;

	print("Start Arnold Kick Region Job");
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	string $renderLayerDisplayName = GetRenderLayerDisplayName($renderLayer);

	int $submitEachRenderLayer = IsRenderLayersOn() ? ArnoldSubmitEachLayer() : false;
	$overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings`;
	if( $submitEachRenderLayer )
	{
		if($overrideLayerSettings)
		{
			$field = "frw_FrameList_" + $renderLayer;
			$frameList = `textFieldGrp -q -text $field`;
		}
		else
		{
			$frameList = DeadlineGetFrameList();
		}
	}

	int $frameRange[] = GetFramesArray($frameList);

	int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;

	int $submissionCount = 0;

	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	string $projectPath = `textFieldGrp -q -text frw_projectPath`;
	string $assExportFolder = `workspace -fre "ASS"`;
	if( $assExportFolder == "" )
		$assExportFolder = "data";

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $assFileName = GetStrippedSceneFileName();

	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;
	int $exportCompressed = `checkBox -q -v frw_exportArnoldCompressed`;

	int $renderHeight = `getAttr "defaultResolution.height"`;
	int $renderWidth = `getAttr "defaultResolution.width"`;

	int $tilesInX = `intSliderGrp -q -v frw_tilesInX`;
	int $tilesInY = `intSliderGrp -q -v frw_tilesInY`;

	int $regions[];
	int $assemblyRegions[];
	int $regionType = `optionMenuGrp -q -select frw_regionRenderType`;
	if($regionType == $TileRegionRenderType)
	{
		for( $y = 1; $y <= $tilesInY; $y++ )
		{
			for( $x = 1; $x <= $tilesInX; $x++ )
			{
				$regions[size($regions)]= ($x-1)*($renderWidth/$tilesInX);
				$assemblyRegions[ size($assemblyRegions) ] = ($x-1)*($renderWidth/$tilesInX);
				$regions[size($regions)]= ($x)*($renderWidth/$tilesInX);
				$assemblyRegions[ size($assemblyRegions) ] = ($x)*($renderWidth/$tilesInX);
				$regions[size($regions)]= ($y-1)*($renderHeight/$tilesInY);
				$assemblyRegions[ size($assemblyRegions) ] = ($tilesInY - $y)*($renderHeight/$tilesInY);
				$regions[size($regions)]= ($y)*($renderHeight/$tilesInY);
				$assemblyRegions[ size($assemblyRegions) ] = ($tilesInY - $y + 1)*($renderHeight/$tilesInY);
			}
		}
	}
	else
	{
		if(catchQuiet(`python("jigsawThread.isAlive()")`))
		{
			confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
			return 0;
		}
		if(`python("jigsawThread.isAlive()")`)
		{
			python("jigsawThread.requestSave()");
			//Jigsaw uses an inverted coordinate system when compared to Draft and the common tilerendering code
			int $jigsawInverted = IsRegionRenderingInverted( "arnold" );
			$regions = `python("jigsawThread.getRegions(" + $jigsawInverted + ")")`;
			$assemblyRegions = `python("jigsawThread.getRegions()")`;
		}
		else
		{
			confirmDialog -title "Jigsaw Rendering" -message "In order to submit Jigsaw renders the Jigsaw window must be open." -button "OK" -defaultButton "OK";
			return 0;
		}
	}

	int $numRegions = size($regions)/4;

	int $ignoreOutFormatControl = false;
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
		string $padding = "";
		while( size($padding) < $paddingSize )
			$padding = "0" + $padding;

		int $periodInExt = `getAttr "defaultRenderGlobals.periodInExt"`;
		int $putFrameBeforeExt = `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;

		if( $periodInExt == 0 ) // name#.ext
		{
			$assFileName += $padding;
		}
		else if( $periodInExt == 1 )
		{
			if( $putFrameBeforeExt ) // name.# or name.#.ext
			{
				$assFileName += "." + $padding;
			}
			else // name.ext.#
			{
				$assFileName += ".ass." + $padding;
				$ignoreOutFormatControl = true;
			}
		}
		else if( $periodInExt == 2 ) // name_#.ext
		{
			$assFileName += "_" + $padding;
		}
	}
	if( !$ignoreOutFormatControl && `getAttr "defaultRenderGlobals.outFormatControl"` == 0 )
		$assFileName += ".ass";

	if ( $exportCompressed )
		$assFileName += ".gz";

	string $inputPath = $projectPath + "/" + $assExportFolder + "/";

	if ( IsRenderLayersOn() )
	{
		$inputPath = $inputPath + $renderLayerDisplayName + "/";
	}

	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	if ( $multipleRenderableCams )
		$inputPath = $inputPath + $camera + "/";

	$inputPath = $inputPath + CheckSlashes( $assFileName );

	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";
	int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;

	string $singleJobName = $jobName;
	// Append camera name to the job
	if( $camera != "" )
		$singleJobName += " - " + $camera;

	// Append render layer name to the job
	if( IsRenderLayersOn() )
		$singleJobName += " - " + $renderLayerDisplayName;

	string $elementDrivers[] = getArnoldElementDrivers();
	string $elementNames[] = getArnoldElementNames();

	string $extension = fileExtension( GetOutputPrefix( 0, 0, "", "", "" ) );

	if($singleRegionJob)
	{
		string $jobUUID = GetDeadlineUUID( 10 );
		string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info_" + $jobUUID + ".job" );
		$fileId = `fopen $submitFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

		fprint $fileId ( "Plugin=Arnold\n" );
		fprint $fileId ( "Name=" + $singleJobName + " - Export\n" );

		if( !$exportLocal || $submitDependentJob )
			fprint $fileId ( "BatchName=" + $batchName + "\n" );

		fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
		fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
		fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
		fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
		fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
		fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
		fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
		fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_ArnoldAutoTaskTimeout` + "\n" );
		fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
		fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
		fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
		fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
		fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );
		int $fileCount = 0;
		for( $element in $elementNames )
		{
			string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $singleRegionFrame, $renderLayer, $camera, $element ) );
			$outputPrefix = swapDeepExr( $outputPrefix );
			fprint $fileId ( "OutputFilename" + $fileCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
			$fileCount++;
		}
		fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
		fprint $fileId ( "Frames=0-" + ($numRegions-1) + "\n" );
		fprint $fileId ( "ChunkSize=1\n" );

		if( `checkBox -q -value frw_ArnoldIsBlacklist` )
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
		else
			fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );


		fclose $fileId;

		string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job_" + $jobUUID + ".job" );
		$fileId = `fopen $jobFilename "w"`;
		if( $fileId == 0 )
			print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

		fprint $fileId ( "InputFile=" + $inputPath + "\n" );
		fprint $fileId ( "DisableFrameInterpretation=" + !IsAnimatedOn() + "\n" );
		fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
		fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
		fprint $fileId ( "Verbose=4\n" );
		fprint $fileId ( "RegionJob=True\n" );
		fprint $fileId ( "SingleAss=True\n" );
		fprint $fileId ( "SingleRegionFrame="+$singleRegionFrame+"\n" );
		fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
		if( size($elementDrivers) > 0 )
		{
			fprint $fileId ( "HasAOVs=True\n" );
			int $aovCount = 0;
			for( $curAOV in $elementDrivers )
			{
				fprint $fileId ( "ASSAOV"+ $aovCount +"Name="+$curAOV+"\n" );
				$aovCount++;
			}
		}

		for($curRegion =0;$curRegion<$numRegions;$curRegion++)
		{
			int $top = ($regions[$curRegion*4+2]);
			int $right = ($regions[$curRegion*4+1]-1);
			int $left = ($regions[$curRegion*4]);
			int $bottom = ($regions[$curRegion*4+3]-1);

			if( $right == $renderWidth )
				$right -=1;
			if( $bottom == $renderHeight )
				$bottom -=1;

			fprint $fileId ( "RegionLeft"+$curRegion+"="+$left+"\n" );
			fprint $fileId ( "RegionTop"+$curRegion+"="+$top+"\n" );
			fprint $fileId ( "RegionRight"+$curRegion+"="+$right+"\n" );
			fprint $fileId ( "RegionBottom"+$curRegion+"="+$bottom+"\n" );

			int $elementCount = 0;
			for( $element in $elementNames )
			{
				string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $singleRegionFrame, $renderLayer, $camera, $element ) );
				$outputPrefix = swapDeepExr( $outputPrefix );
				$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $curRegion, "arnold" );
				if( $elementCount == 0)
				{
					fprint $fileId ( "RegionFilename"+$curRegion+"="+ CheckSlashes( $outputFilePath + "/" + $outputPrefix ) +"\n" );
				}
				else
				{
					fprint $fileId ( "AOV" + ( $elementCount - 1 ) + "Filename" + $curRegion + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix )+"\n" );
				}
				$elementCount++;
			}
		}

		fclose $fileId;

		string $argList[] ;
		$argList[0] = $submitFilename;
		$argList[1] = $jobFilename;

		// Submit the job to Deadline
		ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
		string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
		string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

		// Show results
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
		// Get the job id to return
		string $jobId = parseJobIDFromSubmissionOutput( $submitResults );
		$submissionCount++;


		if($submitDependentJob)
		{
			string $dependentIds[] = {$jobId};
			$submissionCount += SetupDependentJigsawAssemblerJob("arnold", $dependentIds, $singleRegionFrame, $assemblyRegions, $renderLayer, $camera);
		}
	}
	else
	{
		string $jobIdList[];

		AddStringAttribute( "deadlineRegionLeft" );
		AddStringAttribute( "deadlineRegionTop" );
		AddStringAttribute( "deadlineRegionRight" );
		AddStringAttribute( "deadlineRegionBottom" );
		string $regionLeftValues[];
		string $regionRightValues[];
		string $regionTopValues[];
		string $regionBottomValues[];

		for($curRegion =0;$curRegion<$numRegions;$curRegion++)
		{
			string $jobUUID = GetDeadlineUUID( 10 );
			string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info_" + $jobUUID + ".job" );
			$fileId = `fopen $submitFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

			fprint $fileId ( "Plugin=Arnold\n" );
			fprint $fileId ( "Name=" + $singleJobName + " - Render - Region "+$curRegion+"\n" );

			if( !$exportLocal || $submitDependentJob )
				fprint $fileId ( "BatchName=" + $batchName + "\n" );

			fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
			fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
			fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
			fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
			fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
			fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
			fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
			fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_ArnoldAutoTaskTimeout` + "\n" );
			fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
			fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
			fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
			fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
			fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );
			int $fileCount = 0;
			for( $element in $elementNames )
			{
				string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayer, $camera, $element ) );
				$outputPrefix = swapDeepExr( $outputPrefix );
				fprint $fileId ( "OutputFilename" + $fileCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
				$fileCount++;
			}
			//fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );

			fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
			fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because arnold export jobs can be done across multiple machines
			fprint $fileId ( "Frames=" + $frameList + "\n" );
			fprint $fileId ( "ChunkSize=1\n" );

			if( `checkBox -q -value frw_ArnoldIsBlacklist` )
				fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
			else
				fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );


			fclose $fileId;

			string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job_" + $jobUUID + ".job" );
			$fileId = `fopen $jobFilename "w"`;
			if( $fileId == 0 )
				print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

			fprint $fileId ( "InputFile=" + $inputPath + "\n" );
			fprint $fileId ( "DisableFrameInterpretation=" + !IsAnimatedOn() + "\n" );
			fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
			fprint $fileId ( "Verbose=4\n" );
			fprint $fileId ( "RegionJob=True\n" );
			fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );

			if( size($elementDrivers) > 0 )
			{
				fprint $fileId ( "HasAOVs=True\n" );
				int $aovCount = 0;
				for( $curAOV in $elementDrivers )
				{
					fprint $fileId ( "ASSAOV"+ $aovCount +"Name="+$curAOV+"\n" );
					$aovCount++;
				}
			}

			int $top = ($regions[$curRegion*4+2]);
			int $right = ($regions[$curRegion*4+1]-1);
			int $left = ($regions[$curRegion*4]);
			int $bottom = ($regions[$curRegion*4+3]-1);

			fprint $fileId ( "RegionLeft="+$left+"\n" );
			fprint $fileId ( "RegionTop="+$top+"\n" );
			fprint $fileId ( "RegionRight="+$right+"\n" );
			fprint $fileId ( "RegionBottom="+$bottom+"\n" );

			int $assemblyTop = ($assemblyRegions[$curRegion*4+2]);
			int $assemblyRight = ($assemblyRegions[$curRegion*4+1]);
			int $assemblyLeft = ($assemblyRegions[$curRegion*4]);
			int $assemblyBottom = ($assemblyRegions[$curRegion*4+3]);
			stringArrayInsertAtIndex($curRegion, $regionLeftValues, ""+$assemblyLeft);
			stringArrayInsertAtIndex($curRegion, $regionTopValues, ""+ $assemblyTop);
			stringArrayInsertAtIndex($curRegion, $regionRightValues, ""+ $assemblyRight);
			stringArrayInsertAtIndex($curRegion, $regionBottomValues, ""+ $assemblyBottom);

			int $frameCount = 0;
			for ($frame in $frameRange)
			{
				int $elementCount = 0;
				for( $element in $elementNames )
				{
					string $outputPrefix = CheckSlashes( GetOutputPrefix( 1, $frame, $renderLayer, $camera, $element ) );
					$outputPrefix = swapDeepExr( $outputPrefix );
					$outputPrefix = GetJigsawOutputPrefix( $outputPrefix, $curRegion, "arnold" );
					if( $elementCount == 0)
					{
						fprint $fileId ( "RegionFilename"+$frame+"="+ CheckSlashes( $outputFilePath + "/" + $outputPrefix ) +"\n" );
					}
					else
					{
						fprint $fileId ( "AOV" + ( $elementCount - 1 ) + "Filename"+$frame+"=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix )+"\n" );
					}
					$elementCount++;
				}
			}

			fclose $fileId;

			string $argList[] ;
			$argList[0] = $submitFilename;
			$argList[1] = $jobFilename;

			// Submit the job to Deadline
			ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
			string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
			string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

			// Show results
			print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
			$submissionCount += 1;
			// Get the job id to return
			string $jobId = parseJobIDFromSubmissionOutput( $submitResults );
			stringArrayInsertAtIndex(size($jobIdList),$jobIdList, $jobId) ;
		}

		int $submitDependentJob = `checkBox -q -v frw_submitTileDependentJob`;
		if($submitDependentJob)
		{
			string $regionString = stringArrayToString($regionLeftValues,";");
			setAttr defaultRenderGlobals.deadlineRegionLeft -type "string" $regionString;
			$regionString = stringArrayToString($regionTopValues,";");
			setAttr defaultRenderGlobals.deadlineRegionTop -type "string" $regionString;
			$regionString = stringArrayToString($regionRightValues,";");
			setAttr defaultRenderGlobals.deadlineRegionRight -type "string" $regionString;
			$regionString = stringArrayToString($regionBottomValues,";");
			setAttr defaultRenderGlobals.deadlineRegionBottom -type "string" $regionString;
			$submissionCount += SetupDependentTileAnimationAssemblerJob("arnold", $jobIdList, $renderLayer, $camera);
		}

	}
	return $submissionCount;

}

proc string SetupDependentMaxwellJob( string $jobId, string $camera, int $batch, int $coopSeed )
{
	global string $MaxwellOutputScriptListGrp;

	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	string $inputPath = `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp`;
	string $sdkVersion = `maxwell -getSDKVersion`;
	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";

	int $separateJobs;
	int $coopRendering = `checkBox -q -v frw_maxwellCooperativeRendering`;
	int $autoMerge = `checkBox -q -v frw_maxwellAutoMergeFiles`;
	int $exportLocal = `checkBox -q -v frw_exportMaxwellLocal`;
	int $animation = `getAttr "defaultRenderGlobals.animation"`;
	int $singleFile = 1;
	int $coopJobs = 1;

	if($animation)
	{
		$singleFile = 0;
	}

	if( $coopRendering )
	{
		$coopJobs = `intField -q -v frw_maxwellNumCoopRenders`;
		$separateJobs = `checkBox -q -v frw_maxwellCoopSeparateJobs`;

		if( $animation )
		{
			$separateJobs = true;
		}
	}

	string $jobUUID = GetDeadlineUUID( 10 );
	string $submitFilename = CheckSlashes( $tempDir + "/maxwell_deadline_info_" + $jobUUID + ".job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
	{
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
	}

	fprint $fileId ( "Plugin=Maxwell\n" );

	$jobName = $jobName + " - Render";

	if($camera != "")
	{
		$jobName = $jobName + " - "+$camera;
	}

	if( $coopRendering )
	{
		if( $separateJobs )
		{
			$jobName = $jobName + " - Cooperative Job " + $coopSeed + " of " + $coopJobs;
		}
		else
		{
			$jobName = $jobName + " - Single Cooperative Job";
		}
	}

	fprint $fileId ( "Name=" + $jobName + "\n" );

	if( !$exportLocal || $batch || $separateJobs || $autoMerge )
	{
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
	}

	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineMaxwellPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineMaxwellSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_MaxwellJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_MaxwellOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_MaxwellSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_MaxwellMinSlaveTimeout` + "\n" );
	fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_MaxwellAutoTaskTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_MaxwellConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_MaxwellGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_MaxwellLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_MaxwellLimitGroups` + "\n" );
	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because Maxwell export jobs can be done across multiple machines

	if( $separateJobs )
	{
		int $framesPerTask = `intSliderGrp -q -v frw_FrameGroup`;

		fprint $fileId ( "Frames=" + $frameList + "\n" );
		fprint $fileId ( "ChunkSize=" +  $framesPerTask + "\n" );
	}
	else
	{
		fprint $fileId ( "Frames=1-" + $coopJobs + "\n" );
		fprint $fileId ( "ChunkSize=1\n" );
	}

	if( `checkBox -q -value frw_MaxwellIsBlacklist` )
	{
			fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_MaxwellMachineList` + "\n" );
	}
	else
	{
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_MaxwellMachineList` + "\n" );
	}

	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", $camera, "" ) );
	string $outputFilename = CheckSlashes( $outputFilePath  + "/" + $outputPrefix );

	fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );

	string $renderFileName = substituteAllString( $outputFilename, "####.", "" );
	string $mxiFileName = substituteAllString( $renderFileName, `fileExtension($renderFileName)`, "mxi" );

	//If user specifies MXI path in Maxwell render options, use that instead of default path above
	if( `getAttr maxwellRenderOptions.specifyMXI` == 1 )
	{
		string $mxiPath = `getAttr maxwellRenderOptions.mxiPath`;

		if( $mxiPath != "" )
		{
			$mxiFileName = $mxiPath;
		}
	}


	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/maxwell_deadline_job_" + $jobUUID + ".job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
	{
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	}

	fprint $fileId ( "Version="+`substring $sdkVersion 1 1`+"\n" );
	fprint $fileId ( "SingleFile=" + $singleFile + "\n" );
	fprint $fileId ( "SeparateFiles=" + $animation + "\n" );
	fprint $fileId ( "MaxwellFile=" + $inputPath + "\n" );
	fprint $fileId ( "OutputFile=" + $renderFileName + "\n" );
	fprint $fileId ( "MxiFile=" + $mxiFileName + "\n" );
	fprint $fileId ( "LocalRendering=False\n" );

	if( `checkBox -q -v frw_maxwellMXIResume` )
	{
		fprint $fileId ( "ResumeFromMxiFile=True\n" );
	}
	else
	{
		fprint $fileId ( "ResumeFromMxiFile=False\n" );
	}

	fprint $fileId ( "Build=None\n" );
	fprint $fileId ( "RenderThreads=" + `intSliderGrp -q -v frw_maxwellThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_maxwellArgs` + "\n" );
	fprint $fileId ( "Build=None\n" );
	fprint $fileId ( "OverrideTime=False\n" );
	fprint $fileId ( "OverrideTimeValue=10.0\n" );
	fprint $fileId ( "OverrideSampling=False\n" );
	fprint $fileId ( "OverrideSamplingValue=10.0\n" );
	fprint $fileId ( "OverrideExtraSampling=False\n" );
	fprint $fileId ( "ExtraSamplingEnabled=False\n" );
	fprint $fileId ( "ExtraSamplingLevel=10.0\n" );
	fprint $fileId ( "ExtraSamplingMask=Alpha\n" );
	fprint $fileId ( "ExtraSamplingCustomAlphaName=\n" );
	fprint $fileId ( "ExtraSamplingBitmapFile=\n" );
	fprint $fileId ( "ExtraSamplingInvertMask=False\n" );
	fprint $fileId ( "Verbosity=All\n" );
	fprint $fileId ( "MergeJob=False\n" );
	fprint $fileId ( "Camera=" + $camera + "\n" );
	fprint $fileId ( "AppendFrame=" + $animation +"\n" );

	int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
	fprint $fileId ( "AnimationPadding=" + $paddingSize +"\n" );

	if( $coopRendering )
	{
		fprint $fileId ( "CoopRendering=True\n" );
		fprint $fileId ( "CoopJobs=" + $coopJobs + "\n" );

		if( $separateJobs )
		{
			fprint $fileId ( "CoopSeed=" + $coopSeed + "\n" );
		}
		else
		{
			fprint $fileId ( "SingleCoopJob=True\n" );
		}
	}

	fclose $fileId;

	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	// Submit the job to Deadline
	// Special case, only concatenate pipeline tool settings to .job file if Maxwell coop rendering and Maxwell auto merge are disabled
	if( !( $coopRendering && $autoMerge ) )
	{
		ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
	}
	string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results if not doing a co-op render, or if not auto-merging results from separate co-op render jobs
	if( !$coopRendering || ( !$autoMerge && !$separateJobs ) )
	{
		print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	}

	//Get job ID from submitted results
	string $dependantJobId = parseJobIDFromSubmissionOutput( $submitResults );
	return $dependantJobId;
}

proc SetupAutoMergeMaxwellJob( string $jobId, string $camera )
{
	global string $MaxwellOutputScriptListGrp;

	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";
	string $inputPath = `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp`;
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, "", $camera, "" ) );
	string $outputFilename = CheckSlashes( $outputFilePath + "/" + $outputPrefix );
	string $renderFileName = substituteAllString( $outputFilename, "####.", "" );
	string $mxiFileName = substituteAllString( $renderFileName, `fileExtension($renderFileName)`, "mxi" );
	string $sdkVersion = `maxwell -getSDKVersion`;

	int $singleFile = 1;
	int $coopJobs = `intField -q -v frw_maxwellNumCoopRenders`;
	int $deleteFiles = `checkBox -q -v frw_maxwellDeleteIntermediate`;
	int $failOnMissingFiles = `checkBox -q -v frw_maxwellMissingIntermediate`;

	//If user specifies MXI path in Maxwell render options, use that instead of default path above
	if( `getAttr maxwellRenderOptions.specifyMXI` == 1 )
	{
		string $mxiPath = `getAttr maxwellRenderOptions.mxiPath`;

		if( $mxiPath != "" )
		{
			$mxiFileName = $mxiPath;
		}
	}

	//Trim the last two chars off the string
	$jobId = `substring $jobId 1 ( size( $jobId ) - 1 )`;

	if( IsAnimatedOn() )
	{
		$singleFile = 0;
	}

	string $jobUUID = GetDeadlineUUID( 10 );
	string $submitFilename = CheckSlashes( $tempDir + "/maxwell_deadline_info_" + $jobUUID + ".job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
	{
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );
	}

	fprint $fileId ( "Plugin=Maxwell\n" );
	fprint $fileId ( "Name=" + $jobName + " - Merge Job\n" );
	fprint $fileId ( "BatchName=" + $jobName + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineMaxwellPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineMaxwellSecondaryPool` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_MaxwellGroup` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_MaxwellJobPriority` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_MaxwellConcurrentTasks` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_MaxwellLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_MaxwellLimitGroups` + "\n" );
	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_MaxwellOnComplete` + "\n" );
	fprint $fileId ( "OutputFilename0=" + $outputFilename + "\n" );


	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/maxwell_deadline_job_" + $jobUUID + ".job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
	{
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );
	}

	fprint $fileId ( "Version="+`substring $sdkVersion 1 1`+"\n" );
	fprint $fileId ( "SingleFile=" + $singleFile + "\n" );
	fprint $fileId ( "MaxwellFile=" + $inputPath + "\n" );
	fprint $fileId ( "OutputFile=" + $renderFileName + "\n" );
	fprint $fileId ( "MxiFile=" + $mxiFileName + "\n" );

	if( `checkBox -q -v frw_maxwellMXIResume` )
	{
		fprint $fileId ( "ResumeFromMxiFile=True\n" );
	}
	else
	{
		fprint $fileId ( "ResumeFromMxiFile=False\n" );
	}

	fprint $fileId ( "Build=None\n" );
	fprint $fileId ( "CoopRendering=True\n" );
	fprint $fileId ( "CoopJobs=" + $coopJobs + "\n" );
	fprint $fileId ( "DeleteFiles=" + $deleteFiles + "\n" );
	fprint $fileId ( "FailOnMissingFiles=" + $failOnMissingFiles + "\n" );
	fprint $fileId ( "MergeJob=True\n" );

	fclose $fileId;

	string $submissionCommand = "\"" + $submitFilename + "\" \"" + $jobFilename + "\"";
	string $submitResults = CallDeadlineCommand( $submissionCommand, true );
}

proc int CreateDependentMaxwellJob( string $jobId, string $camera, int $batch )
{
	int $submitCounter = 0;
	int $coopRendering = `checkBox -q -v frw_maxwellCooperativeRendering`;
	int $autoMerge = `checkBox -q -v frw_maxwellAutoMergeFiles`;
	int $separateJobs = `checkBox -q -v frw_maxwellCoopSeparateJobs`;
	int $coopJobs = 1;

	if( $coopRendering )
	{
		$coopJobs = `intField -q -v frw_maxwellNumCoopRenders`;
	}

	string $jobDependencies = "";

	for( $coopSeed = 1; $coopSeed <= $coopJobs; $coopSeed++ )
	{
		$dependentJobId = SetupDependentMaxwellJob( $jobId, $camera, $batch, $coopSeed );
		$jobDependencies = $jobDependencies + $dependentJobId + ",";
		$submitCounter++;

		//Only loop once if co-op jobs are combined into one
		if( !$separateJobs && $coopRendering )
		{
			break;
		}
	}

	if( $coopRendering && $autoMerge )
	{
		SetupAutoMergeMaxwellJob( $jobDependencies, $camera );
		$submitCounter++;
	}

	return $submitCounter;
}

proc SetupArnoldKickJob(string $jobId, string $camera, string $renderLayer)
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $projectPath = `textFieldGrp -q -text frw_projectPath`;
	string $assExportFolder = `workspace -fre "ASS"`;
	if( $assExportFolder == "" )
		$assExportFolder = "data";
	string $assFileName = GetStrippedSceneFileName();

	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;
	int $exportCompressed = `checkBox -q -v frw_exportArnoldCompressed`;

	string $renderLayerDisplayName = "";
	if( $renderLayer == "" )
	{
		string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		$renderLayerDisplayName = GetRenderLayerDisplayName( $currentRenderLayer );
	}
	else
	{
		$renderLayerDisplayName = GetRenderLayerDisplayName( $renderLayer );
	}

	// Append camera name to the job
	if( $camera != "" )
		$jobName = $jobName + " - " + $camera;

	// Append render layer name to the job
	if( IsRenderLayersOn() )
		$jobName += " - " + $renderLayerDisplayName;

	int $ignoreOutFormatControl = false;
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = `getAttr "defaultRenderGlobals.extensionPadding"`;
		string $padding = "";
		while( size($padding) < $paddingSize )
			$padding = "0" + $padding;

		int $periodInExt = `getAttr "defaultRenderGlobals.periodInExt"`;
		int $putFrameBeforeExt = `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;

		if( $periodInExt == 0 ) // name#.ext
		{
			$assFileName += $padding;
		}
		else if( $periodInExt == 1 )
		{
			if( $putFrameBeforeExt ) // name.# or name.#.ext
			{
				$assFileName += "." + $padding;
			}
			else // name.ext.#
			{
				$assFileName += ".ass." + $padding;
				$ignoreOutFormatControl = true;
			}
		}
		else if( $periodInExt == 2 ) // name_#.ext
		{
			$assFileName += "_" + $padding;
		}
	}

	if( !$ignoreOutFormatControl && `getAttr "defaultRenderGlobals.outFormatControl"` == 0 )
		$assFileName += ".ass";

	if ( $exportCompressed )
		$assFileName += ".gz";

	string $inputPath = $projectPath + "/" + $assExportFolder + "/";

	if ( IsRenderLayersOn() ) // swap default to master
	{
		$inputPath = $inputPath + $renderLayerDisplayName + "/";
	}

	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	int $multipleRenderableCams = ( size ( $renderableCameras ) > 1 );
	if ( $multipleRenderableCams )
		$inputPath = $inputPath + $camera + "/";

	$inputPath = $inputPath + CheckSlashes( $assFileName );

	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";

	string $jobUUID = GetDeadlineUUID( 10 );
	string $submitFilename = CheckSlashes( $tempDir + "/arnold_deadline_info_" + $jobUUID + ".job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=Arnold\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );

	if( !$exportLocal )
		fprint $fileId ( "BatchName=" + $batchName + "\n" );

	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineArnoldPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineArnoldSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_ArnoldJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_ArnoldOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_ArnoldSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_ArnoldMinSlaveTimeout` + "\n" );
	fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_ArnoldAutoTaskTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_ArnoldConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_ArnoldGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_ArnoldLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_ArnoldLimitGroups` + "\n" );

	string $elements[] = getArnoldElementNames();
	int $counter = 0;
	for($element in $elements)
	{
		string $outputPrefix = "";
		$outputPrefix = CheckSlashes( GetOutputPrefix( 0, 0, $renderLayer, $camera, $element ) );
		$outputPrefix = swapDeepExr( $outputPrefix );
		fprint $fileId ( "OutputFilename" + $counter + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix ) + "\n" );
		$counter += 1;
	}

	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=true\n" ); // this can be enabled because arnold export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=1\n" );

	if( `checkBox -q -value frw_ArnoldIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_ArnoldMachineList` + "\n" );


	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/arnold_deadline_job_" + $jobUUID + ".job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

	fprint $fileId ( "InputFile=" + $inputPath + "\n" );
	fprint $fileId ( "DisableFrameInterpretation=" + !IsAnimatedOn() + "\n" );
	fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_arnoldThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_arnoldArgs` + "\n" );
	fprint $fileId ( "Verbose=4\n" );
	fclose $fileId;

	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	// Submit the job to Deadline
	ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
	string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
}

proc int SetupMaxwellExportJob( string $renderer )
{
	global int $MaxwellExportJobType;
	global string $MaxwellOutputScriptListGrp;

	int $submitCounter = 0;
	int $submitDependentJob = `checkBox -q -v frw_submitMaxwellJob`;
	int $exportLocal = `checkBox -q -v frw_exportMaxwellLocal`;
	int $coopRendering = `checkBox -q -v frw_maxwellCooperativeRendering`;
	int $renderableCameras = 0;

	string $camera = "";
	string $selectedCamera = `optionMenuGrp -q -value frw_camera`;
	string $cameraNames[] = `listTransforms -cameras`;
	string $outputScript = `textFieldButtonGrp -q -text $MaxwellOutputScriptListGrp`;
	string $jobId = "";

	for( $cameraName in $cameraNames )
	{
		if( $selectedCamera != "" && $cameraName == $selectedCamera )
		{
			$camera = $selectedCamera;
			break;
		}

		if( IsCameraRenderable( $cameraName ) )
		{
			$renderableCameras = $renderableCameras + 1;
		}
	}

	if(!$exportLocal || !$submitDependentJob)
	{
		$jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $MaxwellExportJobType, "" );
		$submitCounter++;
	}
	else
	{
		int $start = 0;
		int $end = 0;
		int $exportOnly = 0;
		string $mxsPath = "";
		int $persistentMxs = 0;
		string $cmdLine = "";

		if( `objExists maxwellRenderOptions` == 0 )
		{
			print( "Error in Deadline Submission Script: Maxwell is not available.\n" );
			return 0;
		}

		$exportOnly = `getAttr maxwellRenderOptions.exportOnly`;
		$cmdLine = `getAttr maxwellRenderOptions.cmdLine`;
		$persistentMxs = `getAttr maxwellRenderOptions.persistentMXS`;
		$mxsPath = `getAttr maxwellRenderOptions.mxsPath`;

		removeRenderLayerAdjustmentAndUnlock maxwellRenderOptions.exportOnly;
		catch(`setAttr maxwellRenderOptions.exportOnly 1`);

		setAttr -type "string" maxwellRenderOptions.cmdLine "-node";
		maxwellUnlockAndSet maxwellRenderOptions.persistentMXS 1;
		setAttr -type "string" maxwellRenderOptions.mxsPath $outputScript;

		removeRenderLayerAdjustmentAndUnlock maxwellRenderOptions.exportOnly;
		catch(`setAttr maxwellRenderOptions.exportOnly 1`);

		string $maxwellVersion = `pluginInfo -q -version "maxwell"`;
		if( isVersionGreaterOrEqual($maxwellVersion, "2.5", ".") )
		{
			maxwellBatchRender("");
		}
		else
		{
			maxwell -batchRender;
		}

		setAttr maxwellRenderOptions.exportOnly $exportOnly;
		setAttr -type "string" maxwellRenderOptions.cmdLine $cmdLine;
		setAttr maxwellRenderOptions.persistentMXS $persistentMxs;
		setAttr -type "string" maxwellRenderOptions.mxsPath $mxsPath;
	}

	if( $submitDependentJob || $coopRendering )
	{
		if( $camera == "" && $renderableCameras > 1 )
		{
			string $cameraNames[] = deadlineGetRenderableCameras( false );
			for( $cameraName in $cameraNames )
			{
				//Create a job for each camera
				$submitCounter = $submitCounter + CreateDependentMaxwellJob( $jobId, $cameraName, 1 );
			}
		}
		else
		{
			$submitCounter = $submitCounter + CreateDependentMaxwellJob( $jobId, $camera, 0 );
		}
	}

	return $submitCounter;
}

proc exportArnoldLocally( int $regionRendering, string $renderLayer )
{
	//Exports arnold .ass files from the current scene on the submitting machine.
	//Variables:
	//  int regionRendering: whether or not this is for a region rendering job submission.

	string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
	editRenderLayerGlobals -currentRenderLayer $renderLayer;

	// If a project and output directory are set in the submitter then we need to switch to those projects so the setttings are set properly when doing a local export.
	string $oldProjectPath = `workspace -fullName`;
	string $oldImagePath = `workspace -q -fre images`;
	string $newProjectPath = CheckSlashes( `textFieldGrp -q -text frw_projectPath` );
	string $newImagePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	int $currTime = `currentTime -query`;
	int $isAnimated = IsAnimatedOn();
	
	int $exportCompressed = `checkBox -q -v frw_exportArnoldCompressed`;
	int $singleRegionJob = `checkBox -q -v frw_submitTileSingleJob`;
	int $singleRegionRendering = `checkBox -q -v frw_submitTileSingleJob`;
	
	if( $newProjectPath != "" ) setProject $newProjectPath;
	if( $newImagePath != "" ) workspace -fr images $newImagePath;

	int $frameListArray[];
	
	// If we are doing a single frame region render then pull the frame from our UI. 
	if( $regionRendering && $singleRegionRendering )
	{
		int $singleRegionFrame = `intSliderGrp -q -v frw_tileSingleFrame`;
		$frameListArray[0] = $singleRegionFrame;
	}
	else
	{
		if( $isAnimated )
		{
			string $frameList = `textFieldGrp -q -text frw_FrameList`;
			$frameListArray = GetFramesArray( $frameList );
		}
		else
		{
			$frameListArray[0] = 0;
		}
	}
	
	string $flags = "";
	if ( $exportCompressed ) $flags += " -c" ;
	if(`getAttr defaultArnoldRenderOptions.binaryAss` == 0) $flags += " -a";
	if(`getAttr defaultArnoldRenderOptions.outputAssBoundingBox`) $flags += " -bb";
	if(`getAttr defaultArnoldRenderOptions.expandProcedurals`) $flags += " -ep";
	if(`attributeExists exportAllShadingGroups defaultArnoldRenderOptions`&&`getAttr defaultArnoldRenderOptions.exportAllShadingGroups`) $flags += " -shg";
	
	for($frame in $frameListArray)
	{
		string $exportString = "arnoldExportAss";
		//If the startframe/endframe parameters are used when exporting arnold ass files then frame numbers are automatically added to the ass files.
		//If we are doing doing a single frame render and animations are turned off in the scene file then we do not want the frame number.
		// in these cases we modify the current frame to be the specified frame in our settings.
		if ( $regionRendering && $singleRegionRendering && !$isAnimated )
		{
			currentTime -e $frame;
		}
		else if( $isAnimated )
		{
			$exportString = $exportString +" -sf "+$frame+" -ef "+$frame;
		}
		eval ($exportString + $flags );
	}

	//Reset the settings we stored at the beginning
	if ( $regionRendering && $singleRegionRendering && !$isAnimated ) currentTime -e $currTime;
	if( $newProjectPath != "" ) setProject $oldProjectPath;
	if( $newImagePath != "" ) workspace -fr images $oldImagePath;

	editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
}

proc int SetupArnoldExportJob( string $renderer )
{
	global int $ArnoldExportJobType;

	int $submitCounter = 0;
	int $regionRendering = `checkBox -q -v frw_regionRendering`;
	int $submitDependentJob = `checkBox -q -v frw_submitArnoldJob`;
	int $exportLocal = `checkBox -q -v frw_exportArnoldLocal`;
	int $submitEachRenderLayer = IsRenderLayersOn() && ArnoldSubmitEachLayer();
	//If we are not submitting a dependent render job then we cannot do anything with region rendering and this is a pure export
	if($submitDependentJob == 0) $regionRendering = 0;
	string $jobId = "";
	
	// Figure out the camera to use (if specified).
	string $selectedCamera = `optionMenuGrp -q -v frw_camera`;
	string $cameraNames[] = {};
	string $renderLayers[] = {};
	if( $selectedCamera != " " )
	{
		stringArrayInsertAtIndex(size( $cameraNames ), $cameraNames, $selectedCamera );
	}
	else
	{
		$cameraNames  = deadlineGetRenderableCameras( false );
	}

	// Remember original render layer
	string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;

	if( $submitEachRenderLayer )
	{
		$renderLayers = getRenderableRenderLayers();
	}
	else
	{
		stringArrayInsertAtIndex(0, $renderLayers, $currentRenderLayer);
	}
	
	for( $renderLayer in $renderLayers )
	{
		if ( $submitEachRenderLayer ) {
			// Attempt to change the active render layer to the one we are trying to submit a job for (otherwise skip)
			if ( catch(`editRenderLayerGlobals -currentRenderLayer $renderLayer`) )
			{
				continue;
			}
		}
		if(!$exportLocal || !$submitDependentJob)
		{
			$jobId = WriteJobFilesAndSubmit( $renderer, 0, $regionRendering, $ArnoldExportJobType, "" );
			$submitCounter++;
		}
		else
		{
			exportArnoldLocally($regionRendering, $renderLayer );
		}

		if( $submitDependentJob )
		{
			for( $cameraName in $cameraNames )
			{
				if( !$regionRendering )
				{
					SetupArnoldKickJob($jobId, $cameraName, $renderLayer );
					$submitCounter++;
				}
				else
				{
					$submitCounter += SetupArnoldKickRegionJob($jobId, $cameraName, $renderLayer );
				}
			}
		}
	}

	// Restore previous render layer
	editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;

	return $submitCounter;
}

proc SetupRenderManJob( string $jobId, string $renderLayer, string $cameraName )
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	if( $renderLayer != "" )
		$jobName = $jobName + " - " + $renderLayer;

	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	string $outputFilePath = "";

	string $projectPath = `textFieldGrp -q -text frw_projectPath`;

	string $inputPath = "";
	
	string $renderer = GetCurrentRenderer();
	if( $renderer == "renderman22" )
	{
		$inputPath = CheckSlashes( GetRendermanRibDirectory( $renderLayer, $cameraName ) + "/" + GetRendermanRibPrefix( $renderLayer, $cameraName ) );
	}
	else
	{
		$outputFilePath =CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
		if( $renderLayer == "" )
			$inputPath = CheckSlashes( $projectPath + "/renderman/" + GetStrippedSceneFileName() + "/rib/0000/0000.rib\n" );
		else
			$inputPath = CheckSlashes( $projectPath + "/renderman/" + GetStrippedSceneFileName() + "/rib/0000/0000_" + $renderLayer + ".rib\n" );
	}
	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";

	string $jobUUID = GetDeadlineUUID( 10 );
	string $submitFilename = CheckSlashes( $tempDir + "/renderman_deadline_info_" + $jobUUID + ".job" );
	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	fprint $fileId ( "Plugin=RenderMan\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );
	fprint $fileId ( "BatchName=" + $batchName + "\n" );
	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineRendermanPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineRendermanSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_RendermanJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_RendermanOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_RendermanSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_RendermanMinSlaveTimeout` + "\n" );
	fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_RendermanAutoTaskTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_RendermanConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_RendermanGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_RendermanLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_RendermanLimitGroups` + "\n" );

	string $renderableCameras[] = deadlineGetRenderableCameras( false );
	if( $cameraName != "" )
	{
		$renderableCameras = {$cameraName};
	}
	
	string $renderElements[] = {};
	if( $renderer == "renderman22" )
		$renderElements = getRendermanElements();
		
	int $outputCount = 0;
	for( $camera in $renderableCameras )
	{
		for( $element in $renderElements )
		{
			if( $renderer == "renderman22" )
			{
				$outputFilePath = GetRendermanOutputDirectory( $renderLayer, $cameraName, $element );
			}
			
			$outputPrefix = GetOutputPrefix( 0, 0, $renderLayer, $camera, $element );
			fprint $fileId ( "OutputFilename" + $outputCount + "=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix)  + "\n" );
			$outputCount++;
		}
	}

	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=" + `checkBox -q -v frw_renderManFrameDependent` + "\n" ); // this can be enabled because renderman export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=1\n" );

	if( `checkBox -q -value frw_RendermanIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_RendermanMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_RendermanMachineList` + "\n" );


	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/renderman_deadline_job_" + $jobUUID + ".job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

	fprint $fileId ( "RibFile=" + $inputPath + "\n" );
	fprint $fileId ( "WorkingDirectory=" + CheckSlashes( $projectPath ) + "\n" );
	fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_rendermanThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_rendermanArgs` + "\n" );
	fclose $fileId;

	string $argList[];
	$argList[0] = $submitFilename;
	$argList[1] = $jobFilename;

	// Submit the job to Deadline
	ConcatenatePipelineSettingsToJob( $submitFilename, $jobName );
	string $submissionCommandFile = CreateArgumentsFile( $argList, $jobUUID );
	string $submitResults = CallDeadlineCommand( "\"" + $submissionCommandFile + "\"", true );

	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
}

proc int SetupRendermanExportJob( string $renderer )
{
	global int $RendermanExportJobType;

	int $submitCounter = 0;

	string $jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $RendermanExportJobType, "" );

	$submitCounter++;

	int $submitDependentJob = `checkBox -q -v frw_submitRenderManJob`;
	if( $submitDependentJob )
	{
		string $renderableCameras[] = deadlineGetRenderableCameras( false );
		for( $camera in $renderableCameras )
		{
			if (!IsRenderLayersOn())
			{
				SetupRenderManJob( $jobId, "", $camera );
				$submitCounter++;
			}
			else
			{

				// Loop through the render layers
				string $renderLayerList[] = getRenderableRenderLayers();
				
				for( $i = 0; $i < size( $renderLayerList ); $i++ )
				{
					string $renderLayer = GetRenderLayerDisplayName( $renderLayerList[$i] );
					SetupRenderManJob( $jobId, $renderLayer, $camera );
					$submitCounter++;
					
				}
			}
		}
	}

	return $submitCounter;
}

proc SetupRedshiftJob( string $jobId, string $renderLayer )
{
	string $jobName = `textFieldGrp -q -text frw_JobName`;
	string $batchName = `textFieldGrp -q -text frw_JobName`;
	string $frameList = `textFieldGrp -q -text frw_FrameList`;

	string $outputFilePath = GetBaseOutputDirectory("Redshift");

	string $projectPath = `textFieldGrp -q -text frw_projectPath`;

	string $redShiftFileName = GetStrippedSceneFileName();
	int $ignoreOutFormatControl = false;
	int $exportLocal = `checkBox -q -v frw_exportRedshiftLocal`;
	if( `getAttr "defaultRenderGlobals.animation"` )
	{
		int $paddingSize = 4; // Redshift export always sets up a padding size of 4
		string $padding = "";
		while( size($padding) < $paddingSize )
			$padding = "0" + $padding;

		int $periodInExt = `getAttr "defaultRenderGlobals.periodInExt"`;
		int $putFrameBeforeExt = `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;

		if( $periodInExt == 0 ) // name#.ext
		{
			$redShiftFileName += $padding;
		}
		else if( $periodInExt == 1 )
		{
			if( $putFrameBeforeExt ) // name.# or name.#.ext
			{
				$redShiftFileName += "." + $padding;
			}
			else // name.ext.#
			{
				$redShiftFileName += ".rs." + $padding;
				$ignoreOutFormatControl = true;
			}
		}
		else if( $periodInExt == 2 ) // name_#.ext
		{
			$redShiftFileName += "_" + $padding;
		}
	}

	if( !$ignoreOutFormatControl && `getAttr "defaultRenderGlobals.outFormatControl"` == 0 )
		$redShiftFileName += ".rs";


	string $inputPath = CheckSlashes( $projectPath + "/redshift/" );
	if(size($renderLayer))
	{
		$inputPath += $renderLayer + "/";
	}
	$inputPath += $redShiftFileName;

	string $tempDir = `getAttr defaultRenderGlobals.DeadlineUserHomeDir` + "/temp";

	string $jobUUID = GetDeadlineUUID( 10 );
	string $submitFilename = CheckSlashes( $tempDir + "/redshift_deadline_info_" + $jobUUID + ".job" );

	$fileId = `fopen $submitFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $submitFilename + "\n" );

	if( size($renderLayer) )
	{
		$jobName += " - " + $renderLayer;
	}

	fprint $fileId ( "Plugin=Redshift\n" );
	fprint $fileId ( "Name=" + $jobName + "\n" );

	if( !$exportLocal || size($renderLayer) )
	{
		fprint $fileId ( "BatchName=" + $batchName + "\n" );
	}

	fprint $fileId ( "Comment=" + `textFieldGrp -q -text frw_JobComment` + "\n" );
	fprint $fileId ( "Pool=" + `optionMenuGrp -q -value frw_deadlineRedshiftPool` + "\n" );
	fprint $fileId ( "SecondaryPool=" + `optionMenuGrp -q -value frw_deadlineRedshiftSecondaryPool` + "\n" );
	fprint $fileId ( "Priority=" + `intSliderGrp -q -v frw_RedshiftJobPriority` + "\n" );
	fprint $fileId ( "OnJobComplete=" + `optionMenuGrp -q -value frw_RedshiftOnComplete` + "\n" );
	fprint $fileId ( "TaskTimeoutMinutes=" + `intSliderGrp -q -v frw_RedshiftSlaveTimeout` + "\n" );
	fprint $fileId ( "MinRenderTimeMinutes=" + `intSliderGrp -q -v frw_RedshiftMinSlaveTimeout` + "\n" );
	fprint $fileId ( "EnableAutoTimeout=" + `checkBox -q -v frw_RedshiftAutoTaskTimeout` + "\n" );
	fprint $fileId ( "ConcurrentTasks=" + `intSliderGrp -q -v frw_RedshiftConcurrentTasks` + "\n" );
	fprint $fileId ( "Department=" + `textFieldGrp -q -text frw_Department` + "\n" );
	fprint $fileId ( "Group=" + `optionMenuGrp -q -value frw_RedshiftGroup` + "\n" );
	fprint $fileId ( "MachineLimit=" + `intSliderGrp -q -v frw_RedshiftLimitCount` + "\n" );
	fprint $fileId ( "LimitGroups=" + `textFieldGrp -q -text frw_RedshiftLimitGroups` + "\n" );

	$outputPrefix = GetOutputPrefix( 0, 0, $renderLayer, "", "" );
	fprint $fileId ( "OutputFilename0=" + CheckSlashes( $outputFilePath + "/" + $outputPrefix )  + "\n" );

	fprint $fileId ( "JobDependencies=" + $jobId + "\n" );
	fprint $fileId ( "IsFrameDependent=" + `checkBox -q -v frw_redshiftFrameDependent` + "\n" ); // this can be enabled because redshift export jobs can be done across multiple machines
	fprint $fileId ( "Frames=" + $frameList + "\n" );
	fprint $fileId ( "ChunkSize=" + `intSliderGrp -q -value frw_FrameGroup` + "\n" );
	
	// Add the asset files to the Redshift scene.
	string $assetPaths[] = FindAssetPaths();
	if( !`checkBox -q -value frw_submitMayaScene` )
	{
		stringArrayInsertAtIndex( size( $assetPaths ), $assetPaths, CheckSlashes( $inputPath ) );
	}
	WriteAssetPathsToJobFile( $assetPaths, $fileId );
	
	if( `checkBox -q -value frw_RedshiftIsBlacklist` )
		fprint $fileId ( "Blacklist=" + `textFieldGrp -q -text frw_RedshiftMachineList` + "\n" );
	else
		fprint $fileId ( "Whitelist=" + `textFieldGrp -q -text frw_RedshiftMachineList` + "\n" );

	fclose $fileId;

	string $jobFilename = CheckSlashes( $tempDir + "/redshift_deadline_job_" + $jobUUID + ".job" );
	$fileId = `fopen $jobFilename "w"`;
	if( $fileId == 0 )
		print( "Error in Deadline Submission Script: could not create " + $jobFilename + "\n" );

	fprint $fileId ( "SceneFile=" + $inputPath + "\n" );
	fprint $fileId ( "WorkingDirectory=" + CheckSlashes( $projectPath ) + "\n" );
	fprint $fileId ( "Threads=" + `intSliderGrp -q -v frw_redshiftThreads` + "\n" );
	fprint $fileId ( "CommandLineOptions=" + `textFieldGrp -q -text frw_redshiftArgs` + "\n" );
	fprint $fileId ( "ReplaceFrameNumber=" + IsAnimatedOn() + "\n" );
	fclose $fileId;

	// Submit the job to Deadline
	ConcatenatePipelineSettingsToJob( $submitFilename, $batchName );
	string $submissionCommand = "\"" + $submitFilename + "\" \"" + $jobFilename + "\"";
	string $submitResults = CallDeadlineCommand( $submissionCommand, true );
	
	// Show results
	print( "\n\nSubmission Results For Job " + $jobName + ":\n---------------------------------------------------------------------------\n" + $submitResults + "\n" );
	
	// Perform pre-cache
	int $doPrecaching = `getAttr defaultRenderGlobals.deadlinePrecacheAssetsForAWS`;
	// We have the job ID, now it's time to call the AWS Portal stuff
	if(size($assetPaths) > 0 && $doPrecaching)
	{
		string $jobId = parseJobIDFromSubmissionOutput( $submitResults );
		print( CallDeadlineCommand( "-AWSPortalPrecacheJob "+$jobId, true ) );
	}
}

proc int SetupRedshiftExportJob( string $renderer, string $layer )
{
	global int $RedshiftExportJobType;

	int $submitCounter = 0;

	string $jobId = "";

	int $submitDependentJob = `checkBox -q -v frw_submitRedshiftJob`;
	int $exportLocal = `checkBox -q -v frw_exportRedshiftLocal`;

	if( !$exportLocal || !$submitDependentJob )
	{
		$jobId = WriteJobFilesAndSubmit( $renderer, 0, 0, $RedshiftExportJobType, "" );
		$submitCounter++;
	}
	else
	{
		print("Running local Redshift export...\n");

		string $resultFile = `textFieldGrp -q -text frw_projectPath` + "/redshift/";

		if(size($layer)) // A render layer has been specified 
		{
			$resultFile += $layer + "/";
		}

		if(!`file -q -exists $resultFile`)
		{
			sysFile -makeDir $resultFile;
		}

		$resultFile = CheckSlashes($resultFile + basenameEx(`file -q -sceneName`));

		if(!IsAnimatedOn())
		{
			$resultFile += ".rs";
			rsProxy -fp $resultFile;
		}
		else
		{
			string $frameList = `textFieldGrp -q -text frw_FrameList`;
			int $frameListArray[];
			$frameListArray = GetFramesArray( $frameList );
			
			string $currFile; int $frameNum; string $paddedFrame;
			for($frame in $frameListArray)
			{
				$paddedFrame = "#";
				while( size($paddedFrame) < 4 )
				{
					$paddedFrame = "#" + $paddedFrame;
				}

				$currFile = $resultFile + "." + $paddedFrame + ".rs";
				rsProxy -fp $currFile -s $frame -e $frame -b 1;
			}
		}
	}

	if( $submitDependentJob )
	{
		SetupRedshiftJob( $jobId, $layer );
		$submitCounter++;
	}

	return $submitCounter;
}

global proc SetupSubmission()
{
	global string $DeadlineSubmitterWindow;
	global string $StartupScriptPathGrp;
	global int $MayaRenderJobType;
	global int $MentalRayExportJobType;
	global int $VRayExportJobType;
	global int $RendermanExportJobType;
	global int $ArnoldExportJobType;
	global int $MaxwellExportJobType;
	global int $BifrostSimulationJobType;
	global int $AlembicExportJobType;
	global int $MayaScriptJobType;
	global int $GeometryCachingJobType;
	global int $FluidCachingJobType;
	global int $RedshiftExportJobType;
	
	SavePersistentDeadlineOptions();
	print( "Submitting job to Deadline...\n" );
		
	// Get the current renderer
	string $renderer = GetCurrentRenderer();
	
	// Check if we are doing a mental ray export
	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;
	
	/*
	// Check that if the renderer is Gelato that we are using MayaBatch
	if( $renderer == "gelato" && `getAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin` != 1)
	{
		string $errorMessage = "The Maya plugin does not support the Gelato renderer.  Please select the checkbox to use the MayaBatch plugin.\n\n";
		string $result = `confirmDialog -title "Submission Error" -message ( $errorMessage ) -button "OK" -defaultButton "OK"`;
		return;
	}
	*/
	
	/*
	// Ensure that the scene is animated
	if( !IsAnimatedOn() )
	{
		string $errorMessage = "";
		if ( $renderer == "vray" )
		{
			if( IsOldVray() )
				$errorMessage = "Animation checkbox under Image File Output is not checked. Deadline requires that animation be enabled.\n\n";
			else
				$errorMessage = "Frame/Animation Ext in render globals is set for a single frame. Deadline requires that animation be enabled.\n\n";
		}
		else
			$errorMessage = "Frame/Animation Ext in render globals is set for a single frame. Deadline requires that animation be enabled.\n\n";
		
		string $result = `confirmDialog -title "Submission Error" -message ( $errorMessage ) -button "OK" -defaultButton "OK"`;
		return;
	}
	*/
	
	// Check all the paths for problems, and warn the user if any are found
	string $projectPath = CheckSlashes( `textFieldGrp -q -text frw_projectPath` );
	string $outputFilePath = CheckSlashes( `textFieldGrp -q -text frw_outputFilePath` );
	string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
	string $mentalRayFilename = CheckSlashes( `textFieldGrp -q -text frw_mentalRayFilePath` );
	string $vrayFilename = ForceRenderLayerToken( CheckSlashes( `textFieldGrp -q -text frw_vrayFilePath` ) );
	string $maxwellExportFilename = CheckSlashes( `textFieldGrp -q -text frw_maxwellScriptName` );
	
	int $submitMayaSceneFile = `checkBox -q -value frw_submitMayaScene`;

	string $message = "";
	string $errors = "";
	if( !$submitMayaSceneFile && IsLocalDrive( $sceneFilePath ) )
		$message = $message + "Maya Scene file, \"" + $sceneFilePath + "\" is on a local drive and is not being submitted.\nWorkers will not be able to access the scene file.\n\n";
	
	if( IsLocalDrive( $projectPath ) )
		$message = $message + "Project path, \"" + $projectPath + "\" is on a local drive.\nParticle caching and other Maya features will not be available.\n\n";
	
	int $exportDependentJob = false;
	if( $jobType == $MentalRayExportJobType )
	{
		$binary = false;
		if( catch( $binary = `radioButton -query -select MayatomrExport_Binary` ) )
		{
			string $result = `confirmDialog -parent $DeadlineSubmitterWindow -title "Error Reading Export Options" -message "Could not read in Mental Ray Export settings. Please ensure that the Mental Ray Export settings dialog is open when submitting the job to Deadline." -button "Export Settings..." -button "Cancel" -defaultButton "Export Settings..." -cancelButton "Cancel" `;
			if( $result == "Export Settings..." )
				OpenExportSettings();
			return;
		}
		
		string $mentalRayPath = dirname( $mentalRayFilename );
		if( ! `filetest -d $mentalRayPath` )
			$message = $message + "Mental Ray output path \"" + $mentalRayPath + "\" does not exist!  Your Mental Ray files will be lost!\n\n";
		else if( IsLocalDrive( $mentalRayFilename ) )
			$message = $message + "Mental Ray output file \"" + $mentalRayFilename + "\" is on a local drive.\nWorkers will not be able to copy the Mental Ray files to this drive.\n\n";
		else if( size( $mentalRayFilename ) == 0 )
			$message = $message + "Mental Ray output file is blank! Your Mental Ray files will be lost!\n\n";
		
		$exportDependentJob = `checkBox -q -v frw_submitMentalRayJob`;
	}
	else if( $jobType == $VRayExportJobType )
	{
		string $vrayPath = dirname( $vrayFilename );
		if( ! `filetest -d $vrayPath` )
			$errors = $errors + "VRay export path \"" + $vrayPath + "\" does not exist! Your VRay files will be lost!\n\n";
		else if( IsLocalDrive( $vrayFilename ) )
			$message = $message + "VRay output file \"" + $vrayFilename + "\" is on a local drive.\nWorkers will not be able to copy the exported VRay files to this drive.\n\n";
		else if( size( $vrayFilename ) == 0 )
			$message = $message + "VRay output file is blank! Your exported VRay files will be lost!\n\n";
		
		int $submitDependentJob = `checkBox -q -v frw_submitVRayJob`;
		if( $submitDependentJob && `getAttr( "vraySettings.misc_separateFiles" )` )
			$message = $message + "Dependent VRay standalone job option is not compatible with the 'Separate Files' option in the VRay Translator settings. No dependent jobs will be submitted.\n\n";
		
		string $userDefinedPrefix = `getAttr vraySettings.fileNamePrefix`;

		if( `isValidString $userDefinedPrefix ".*##.*"` )
		{
			if( `checkBox -q -v frw_submitVrimg2ExrJob` && $submitDependentJob  )
				$errors = $errors + "Output image path contains consecutive hash characters which is incompatible with vrimg2exr\n\n";
			else
				$message = $message + "Output image path contains consecutive hash characters. VRay will replace each one with the full frame number. This likely not desired and job output will not be accessible from the Deadline Monitor.\n\n";
		}
		else if( `isValidString $userDefinedPrefix ".*#.*#.*"` )
			$message = $message + "Output image path contains multiple hash characters. VRay will replace each on with the full frame number.\n\n";

		if( `checkBox -q -v frw_submitVrimg2ExrJob` )
		{
			if( `isValidString $userDefinedPrefix ".*#[^.].*"` )
			{
				// This is a current limitation of the Vrimg2exr plugin. We can remove this if it ever gets fixed.
				$errors = $errors + "The dependent vrimg2exr job requires that frame numbers appears before a period. Edit the \"File Name Prefix\" in the \"Image File Output\" section of your render settings to either end with a hash character (\"#\") or to contain no hash characters.\n\n";
			}
		}

		if( `isValidString $outputFilePath ".*#.*"` )
			$message = $message + "Output directory contains one or more hash characters. VRay will place your output files in dynamic directories based on the frame number, and job output cannot be shown in the Monitor.\n\n";

		if( `checkBox -q -v frw_submitVrimg2ExrJob` && $submitDependentJob )
		{
			if( getAttr( "vraySettings.imageFormatStr" ) != "vrimg" )
				$message = $message + "Dependent Vrimg2Exr job is enabled, but the output format is not vrimg!\n\n";
		}
		
		$exportDependentJob = `checkBox -q -v frw_submitVRayJob`;
	}
	else if( $jobType == $RendermanExportJobType )
	{
		$exportDependentJob = `checkBox -q -v frw_submitRenderManJob`;
	}
	else if( $jobType == $ArnoldExportJobType )
	{
		$exportDependentJob = `checkBox -q -v frw_submitArnoldJob`;
	}
	else if( $jobType == $MaxwellExportJobType )
	{
		string $maxwellExportDirectory = dirname( $maxwellExportFilename );
		if( size( $maxwellExportFilename ) == 0 )
			$message = $message + "Maxwell script name is blank! No maxwell script will be exported!\n\n";
		else if( !`filetest -d $maxwellExportDirectory` )
			$message = $message + "Maxwell export directory \"" + $maxwellExportDirectory + "\" does not exist!  No maxwell script will be exported!\n\n";
		else if( IsLocalDrive( $maxwellExportDirectory ) )
			$message = $message + "Maxwell export directory \"" + $maxwellExportDirectory + "\" is on a local drive.\nWorkers will not be able to copy the exported Maxwell Files to this drive.\n\n";
	}
	else if( $jobType == $RedshiftExportJobType )
	{
		$exportDependentJob = `checkBox -q -v frw_submitRedshiftJob`;
	}
	
	// If not an export job, or it is an export job with a dependent job, warn about the output.
	if( $jobType == $MayaRenderJobType || $exportDependentJob )
	{
		if( size( $outputFilePath ) == 0 )
			$message = $message + "Image Output Path is blank! Your final images will be lost!\n\n";
		
		if( ! `filetest -d $outputFilePath`  )
		{
			if( ! `filetest -d ( $projectPath + "/" + $outputFilePath)`  )
			{
				$message = $message + "Image Output Path \"" + $outputFilePath + "\" does not exist! Your final images will be lost!\n\n";
			}
			else if( IsLocalDrive( ( $projectPath + "/" + $outputFilePath) ) )
			{
				$message = $message + "Image Output Path \"" + ( $projectPath + "/" + $outputFilePath) + "\" is on a local drive.\nWorkers will not be able to copy images to this drive.\n\n";
			}
		}
		else
		{
			if( IsLocalDrive( $outputFilePath ) )
			{
				$message = $message + "Image Output Path \"" + $outputFilePath + "\" is on a local drive.\nWorkers will not be able to copy images to this drive.\n\n";
			}
		}
	}
	
	// If there is a startup script, make sure it exists and that it isn't local.
	if( `checkBox -q -v frw_useMayaBatchPlugin` )
	{
		string $startupScript = `textFieldButtonGrp -q -text $StartupScriptPathGrp`;
		$startupScript = `strip $startupScript`;
		if( $startupScript != "" )
		{
			if( ! `filetest -e $startupScript` )
				$message = $message + "Startup Script \"" + $startupScript + "\" does not exist!\n\n";
			else if( IsLocalDrive( $startupScript ) )
				$message = $message + "Startup Script \"" + $startupScript + "\" is on a local drive.\nWorkers will not be able to access it at render time.\n\n";
		}
	}
	
	int $submitEachRenderLayer = IsRenderLayersOn() ? `checkBox -q -value frw_submitEachRenderLayer` : false;
	
	int $regionRendering = `checkBox -q -value frw_regionRendering`;
	if( $regionRendering )
	{
		string $extension = fileExtension( GetOutputPrefix( 0, 0, "", "", "" ) );
		$extension = tolower( $extension );
		if( $extension != "bmp" && $extension != "dds" && $extension != "exr" && $extension != "jpg" && $extension != "png" && $extension != "sgi" && $extension != "tga" && $extension != "tif" )
			$message = $message + "The image format used is not compatible with the Tile Assembler, so you will have to assemble the final image manually.\nThe following formats are currently supported: bmp, dds, exr, jpg, png, sgi, tga, tif.\n\n";
	}

	if( $jobType == $GeometryCachingJobType )
	{
		string $geos[] = `listTransforms -geometry`;
		string $sels[] = `ls -sl`;

		string $selectedGeos[] = IntersectTwoStringArray($geos, $sels); // This is all of the selected Geometry

		if( !size( $selectedGeos ) )
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Geometry Found" -message "No Geometry from this scene were selected. Make sure to select at least one Geometry before submitting a Geometry cache job." -button "OK";
			return;
		}

		string $geoDir = `textFieldButtonGrp -q -text frw_GeometricCacheOutputDir`;
		if( ! `filetest -d $geoDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Geometry caching job may not be saved.\n\n";
		}
		
	}

	if( $jobType == $MayaScriptJobType ) // Make sure script file exists
	{
		string $mayaFile = `textFieldButtonGrp -q -text frw_mayaScriptJob`;
		if( ! `filetest -e $mayaFile` )
		{
			$message = $message + "The Script file specified does not exist. This script job may produce unexpected results.\n\n";
		}
	}

	if( $jobType == $AlembicExportJobType) // Make sure a file name has been specified
	{
		if( ! size(`ls -sl`) && `radioButtonGrp -q -select frw_AlembicExportSelection` == 2) // Chose to submit a custom selection, but nothing was selected
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Items Found" -message "Nothing in this scene has been selected. Please select at least one item or change the Export option to \"All\" " -button "OK";
			return;
		}

		string $alembicFile = `textFieldButtonGrp -q -text frw_alembicExportFile`;
		if( ! `filetest -e $alembicFile` )
		{
			$message = $message + "No file has been set for Alembic export. The file must be saved or the job may produce unexpected results.\n\n";
		}
	}

	if( $jobType == $BifrostSimulationJobType ) // Make sure directory exists
	{
		string $biFrostDir = `textFieldButtonGrp -q -text frw_bifrostCacheDir`;
		if( ! `filetest -d $biFrostDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Bifrost caching job may not be saved.\n\n";
		}
	}

	if( $jobType == $FluidCachingJobType ) // Make sure directory exists
	{
		string $fluids[] = `listTransforms "-type fluidShape"`;
		string $sels[] = `ls -sl`;

		print(size($fluids) + " " + size($sels) + " " + size(IntersectTwoStringArray($fluids, $sels) ) );

		if( !size( IntersectTwoStringArray( $fluids, $sels ) ) )
		{
			confirmDialog -parent $DeadlineSubmitterWindow -title "No Selected Fluids Found" -message "No Fluids from this scene were selected. Make sure to select at least one Fluid before submitting a Fluid cache job." -button "OK";
			return;
		}

		string $fluidDir = `textFieldButtonGrp -q -text frw_FluidCacheOutputDir`;
		if( ! `filetest -d $fluidDir` )
		{
			$message = $message + "No output directory has been specified. The results of this Fluid caching job may not be saved.\n\n";
		}
	}
	
	if ( $jobType == $ArnoldExportJobType && `getAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin` != 1 )
	{
		if ( `getAttr defaultRenderGlobals.deadlineExportArnoldCompressed` )
		{
			$message = $message + "Maya cmd does not support exporting compressed .ass files.\n\n";
		}
		
	}
	
	if( $jobType == $MayaRenderJobType )
	{
		$renderer = GetCurrentRenderer();
		if( $renderer == "redshift" )
		{
			int $concurrentTasks = `intSliderGrp -q -v frw_ConcurrentTasks`;
			int $gpusPerTask = `intSliderGrp -q -v frw_deadlineGPUsPerTask`;
			
			if( $concurrentTasks  > 1 && $gpusPerTask == 0 )
			{
				$message = $message + "Redshift does not support running multiple processes on the same GPU.\nPlease ensure that GPUs Per Task is set to a non-0 value or concurrent tasks is set to 1, otherwise Workers may run into unexpected issues.\n\n";
			}
		}
		else if( $renderer == "vray" )
		{
			string $userDefinedPrefix = `getAttr vraySettings.fileNamePrefix`;

			if( `isValidString $userDefinedPrefix ".*##.*"` )
				$message = $message + "Output image path contains consecutive hash characters. VRay will replace each one with the full frame number. This likely not desired and job output will not be accessible from the Deadline Monitor.\n\n";
			else if( `isValidString $userDefinedPrefix ".*#.*#.*"` )
				$message = $message + "Output image path contains multiple hash characters. VRay will replace each on with the full frame number.\n\n";
		}
	}

	if ( $renderer == "vray" && IsAnimatedOn() )
	{
		$vrayPadding = `getAttr vraySettings.fileNamePadding`;
		string $frameList = `textFieldGrp -q -text frw_FrameList`;
		int $frameRange[] = `GetFramesArray $frameList`;

		if( $vrayPadding == 0 && size($frameRange) > 1 )
		{
			$message = $message + "You have chose to render multiple frames, but V-Ray frame name padding is set to 0. Each frame will overwrite the same file.\n\n";
		}
	}
	
	// Display any error messages
	if( size( $errors ) > 0 )
	{
		$errors = $errors + "\nPlease fix the errors and try again.";
		confirmDialog -parent $DeadlineSubmitterWindow -title "Error!" -message ( $errors ) -button "Ok" -defaultButton "Ok" -cancelButton "Ok";
		return;
	}
		
	// Display any warning messages
	if( size( $message ) > 0 )
	{
		$message = $message + "\nAre you sure you want to submit this job?";
		string $result = `confirmDialog -parent $DeadlineSubmitterWindow -title "Confirm" -message ( $message ) -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
		if( $result == "No" )
			return;
	}
	
	// Save scene, if necessary
	if( `file -q -modified` )
	{
		print( "Maya scene has been modified, saving file\n" );
		file -save;
	}
	else
		print( "Maya scene has not been modified, skipping save\n" );
	
	int $overrideLayerSettings = `checkBox -q -value frw_overrideLayerSettings` && $submitEachRenderLayer && $jobType == $MayaRenderJobType;
	string $originalLayerList[] = getRenderableRenderLayers();
	if( $overrideLayerSettings )
	{
		string $fullLayerList[] = `listConnections renderLayerManager.renderLayerId`;
		for( $renderLayerName in $fullLayerList )
		{
			
			int $submitOverride = `checkBox -q -value ( "frw_SubmitLayer_" + $renderLayerName )`;
			setAttr( $renderLayerName + ".renderable" ) $submitOverride;
		}
	}
	
	// If this is not a mental ray export job, check if we need to submit each layer as a separate job.
	if( $jobType == $MayaRenderJobType && IsRenderLayersOn() && $submitEachRenderLayer )
	{
		int $submitCounter = 0;
		
		// Store the currently selected render layer
		string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
		string $renderLayerList[] = getRenderableRenderLayers();
		
		// Loop through the render layer if the checkbox is on
		for( $renderLayerName in $renderLayerList )
		{
			// Select the render layer to make sure the render settings are updated
			if( !catch(`editRenderLayerGlobals -currentRenderLayer $renderLayerName`) )
			{
				$renderer = GetCurrentRenderer();
				
				//Make sure the the options node for the specified renderer has been created.
				CreateOptionsNode( $renderer );
				
				// Check if we're submitting each camera as a separate job.
				if( `checkBox -q -v frw_submitEachCamera` )
				{
					int $ignoreDefaultCameras = `checkBox -q -v frw_ignoreDefaultCameras`;
					
					string $cameraNames[] = deadlineGetRenderableCameras( $ignoreDefaultCameras );;
					if( size($cameraNames) == 0 )
					{
						confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message "The scene contains no renderable non-default cameras." -button "Close";
						return;
					}
					for( $cameraName in $cameraNames )
					{
						// Set up a tile rendering job if necessary.
						if( $regionRendering && SupportsRegionRendering( $renderer ) )
							$submitCounter += SetupRegionRenderingJob( $renderer, $cameraName );
						else
						{
							WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, $cameraName );
							$submitCounter++;
						}
					}
				}
				else
				{
					// Set up a tile rendering job if necessary.
					if( $regionRendering && SupportsRegionRendering( $renderer ) )
						$submitCounter += SetupRegionRenderingJob( $renderer, "" );
					else
					{
						WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, "" );
						$submitCounter++;
					}
				}
			}
		}
		
		// Reselect the current render layer
		editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
		
		string $submitsResults = "Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.";
		confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message $submitsResults -button "Close";
	}
	else
	{
		if( $jobType == $MentalRayExportJobType )
		{
			int $submitCounter = SetupMentalRayExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $VRayExportJobType )
		{
			int $submitCounter = SetupVRayExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $RendermanExportJobType )
		{
			int $submitCounter = SetupRendermanExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $ArnoldExportJobType )
		{
			int $submitCounter = SetupArnoldExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $MaxwellExportJobType )
		{
			int $submitCounter = SetupMaxwellExportJob( $renderer );
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else if( $jobType == $RedshiftExportJobType )
		{
			// Render current layer or walk all layers 
			int $submitCounter = 0;
			if( `checkBox -q -v frw_redshiftLayerSubmission` )
			{
				string $origLayer = `editRenderLayerGlobals -q -crl`;
				for( $layer in `ls -type renderLayer`)
				{
					editRenderLayerGlobals -crl $layer;
					$submitCounter += SetupRedshiftExportJob( $renderer, $layer );
				}
				editRenderLayerGlobals -crl $origLayer;
			}
			else
			{
				string $layer = "";
				
				if( IsRenderLayersOn() )
				{
					$layer = `editRenderLayerGlobals -query -currentRenderLayer`;
				}
				$submitCounter = SetupRedshiftExportJob( $renderer, $layer );
			}
			confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
		}
		else
		{
			// Check if we're submitting each camera as a separate job.
			if( `checkBox -q -v frw_submitEachCamera` )
			{
				int $submitCounter = 0;
				int $ignoreDefaultCameras = `checkBox -q -v frw_ignoreDefaultCameras`;
				
				string $cameraNames[] = deadlineGetRenderableCameras( $ignoreDefaultCameras );
				if( size($cameraNames) == 0 )
				{
					confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message "The scene contains no renderable non-default cameras." -button "Close";
					return;
				}
				for( $cameraName in $cameraNames )
				{
					// Only setup a tile rendering job if it is enabled.
					if( $regionRendering && SupportsRegionRendering( $renderer ) )
						$submitCounter += SetupRegionRenderingJob( $renderer, $cameraName );
					else
					{
						WriteJobFilesAndSubmit( $renderer, 0, 0, $jobType, $cameraName );
						$submitCounter++;
					}
				}
				
				string $submitsResults = "Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.";
				confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message $submitsResults -button "Close";
			}
			else
			{
				// Only setup a tile rendering job if it is enabled.
				if( $regionRendering && SupportsRegionRendering( $renderer ) )
				{
					int $submitCounter = SetupRegionRenderingJob( $renderer, "" );
					confirmDialog -parent $DeadlineSubmitterWindow -title "Submission Results" -message ("Done submitting " + $submitCounter + " jobs.\nSee script history log for complete details.") -button "Close";
				}
				else
				{
					string $jobId = WriteJobFilesAndSubmit( $renderer, 1, 0, $jobType, "" );
				}
			}
		}
	}
	
	
	if( $overrideLayerSettings )
	{
		string $fullLayerList[] = `listConnections renderLayerManager.renderLayerId`;
		for( $renderLayerName in $fullLayerList )
		{
			int $wasRenderable = stringArrayContains( $renderLayerName, $originalLayerList);
			setAttr( $renderLayerName + ".renderable" ) $wasRenderable;
		}
		
	}
	
	if( `getAttr defaultRenderGlobals.deadlineCloseOnSubmission` )
	{
		deleteUI -window DeadlineSubmitWindow;
	}
	
}

global proc setDefaultFrameRange( string $layerName )
{
	string $fieldName = "frw_FrameList_" + $layerName;
	string $frameRange = `textFieldGrp -q -text frw_FrameList`;
	textFieldGrp -edit -text $frameRange $fieldName;
}

global proc LayerSettingsDialog()
{
	string $renderLayerList[] = `listConnections renderLayerManager.renderLayerId`;
	int $chunkSize = `intSliderGrp -q -v frw_FrameGroup`;
	string $jobName = `attributeExists deadlineJobName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobName` : GetStrippedSceneFileName();
	
	// Add controls to the submission dialog.
	int $windowWidth = 470;
	int $windowHeight = 500;
	
	int $labelWidth = 110;
	int $controlWidth = 320;
	
	// Get the dialog's formLayout.
	//
	string $form = `setParent -q`;
	formLayout -e -width ($windowWidth+8) -height $windowHeight $form;
	
	string $window = `formLayout -q -p $form`;
	print ($form + "\n");
	
	scrollLayout -width $windowWidth -horizontalScrollBarThickness 0 mainScrollLayout;
		columnLayout -adjustableColumn true -columnAttach "both" 0;
			
			// Store the currently selected render layer
			string $currentRenderLayer = `editRenderLayerGlobals -query -currentRenderLayer`;
			
			for( $layer in $renderLayerList )
			{
				if( !catch(`editRenderLayerGlobals -currentRenderLayer $layer`) )
				{
					int $frameRangeEnabled = IsAnimatedOn();
					string $frameRange = DeadlineGetFrameList();
					
					frameLayout -label $layer -labelVisible true -borderVisible false -collapsable true;
						columnLayout -adj true -columnAttach "both" 0 -rowSpacing 4;
						
							$layerJobName = $jobName + " - " + $layer;
							
							$FieldName = "frw_JobName_" + $layer;
							textFieldGrp -label "Job Name" -cl2 "left" "left" -cw2 $labelWidth 320 -text $layerJobName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the job" $FieldName;
							
							$FieldName = "frw_FrameList_" + $layer;
							textFieldGrp -label "Frame List" -en $frameRangeEnabled -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Enter a list of frames to render, separated by commas for separate frames, or dashes for continuous sequences of frames. e.g. 1, 5-10, 100" -text $frameRange $FieldName;

							rowLayout -numberOfColumns 4 -cw 1 290 -ct1 "right";
								$FieldName = "frw_SubmitLayer_" + $layer;
								checkBox -label "Submit Layer" -v ( getAttr( $layer + ".renderable" ) ) -annotation "Whether or not the layer should be submitted." $FieldName;

								text -label "";
								$FieldName = "frw_DefaultFramesButton_" + $layer;
								button -label "Use Default Frame Range" -c ("setDefaultFrameRange(\"" + $layer + "\")");
							setParent ..;
							
							$FieldName = "frw_FrameGroup_" + $layer;
							intSliderGrp -label "Task Size" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v $chunkSize -changeCommand SavePersistentDeadlineOptions -annotation "Each task for the job will consist of this many frames" $FieldName;
							
						setParent ..;
					setParent ..;
				}
			}
			
			// Reselect the current render layer
			editRenderLayerGlobals -currentRenderLayer $currentRenderLayer;
			
		setParent ..;
	setParent ..;
	
	columnLayout -adj true -columnAttach "both" 2 -rowSpacing 4 buttonColumnLayout;
		rowLayout -numberOfColumns 2 -cw2 ($windowWidth / 2) ($windowWidth / 2);
			button -label "Submit Job" -width ($windowWidth / 2 - 4) -height 26 -annotation "Submits this job to Deadline" -align "center" -c SetupSubmission;
			button -label "Close" -width ($windowWidth / 2 - 4)  -height 26 -annotation "Closes this window" -align "center" -c DismissLayoutDialog;
		setParent ..;
	setParent ..;
	
	formLayout -e
		-af buttonColumnLayout bottom 0
		-af buttonColumnLayout right 0
		-af buttonColumnLayout left 0
		-ac mainScrollLayout bottom 0 buttonColumnLayout
		-af mainScrollLayout top 0
		-af mainScrollLayout left 3
	$form;
}

proc FindAlembicPaths( string $outFilepaths[] )
{	
	//Retrieve the path to each Alembic File reference by the scene and add them to outFilepaths
	string $alembicNodes[] = `ls -type "AlembicNode"`;
	for( $node in $alembicNodes)
	{
		string $alembicPath = `getAttr ($node+".abc_File")`;
		if( size( $alembicPath ) > 0 )
		{
			$outFilepaths[size($outFilepaths)] = $alembicPath;
		}
	}
}

global proc string[] FindAssetPaths()
{
	string $renderer = GetCurrentRenderer();
	string $filepaths[0];
	string $cacheFilePaths[0];
	string $derivativeTxFiles[0];
	if( MayaVersion() >= 2014 )
	{
		string $scriptPath = CheckSlashes( CallDeadlineCommand( "-GetRepositoryFilepath plugins/MayaBatch/AssetTools.mel", false ) );
		if( `file -q -exists $scriptPath` )
		{
			print( "Searching for assets...\n" );
			eval( "source \"" + $scriptPath + "\";" );
			
			// Gets all basic assets, no special cases.
			$filepaths = find_asset_paths();
			
			// Get all Redshift cache files
			if( $renderer == "redshift" )
			{
				get_redshift_cache_files( $filepaths, $cacheFilePaths );
				$filepaths = `stringArrayCatenate $filepaths $cacheFilePaths`;
			}
			else if( $renderer == "arnold" )
			{
				int $autogenTX = `getAttr "defaultArnoldRenderOptions.autotx"`;
				int $useExistingTX = `getAttr "defaultArnoldRenderOptions.use_existing_tiled_textures"`;
				python( "import sys" );
				int $deadlineMayaPythonLoaded = python( "\"deadline_maya.textures\" in sys.modules" );
				if( ($autogenTX || $useExistingTX) && $deadlineMayaPythonLoaded )
				{
					// Attempt to find derivative TX files. If we fail to find the TX files for pre-caching
					// do not block submission
					if( !catch( $derivativeTxFiles = python("deadline_maya.textures.find_derivative_tx_files()") ) )
					{
						for ($derivativeTxFile in $derivativeTxFiles)
							print( "Found derivative TX Asset: " + $derivativeTxFile + "\n" );
						$filepaths = `stringArrayCatenate $filepaths $derivativeTxFiles`;
					}
				}
			}
		}
	}
	FindAlembicPaths( $filepaths );	
	return `stringArrayRemoveDuplicates( $filepaths )`;
}

global proc WriteAssetPathsToJobFile( string $filepaths[], int $fileid )
{
	int $numAssets = size( $filepaths );
	if( $numAssets > 0 )
	{
		int $i;
		for( $i = 0; $i < $numAssets; $i++ )
		{
			fprint $fileid( "AWSAssetFile" + $i + "=" + $filepaths[$i] + "\n" );
		}
	}
}

//---------------------------------------------------------
// Event handler functions.
//---------------------------------------------------------

global proc OpenJigsawWindow()
{
	string $path = `getAttr defaultRenderGlobals.DeadlineMayaRepoPath` + "/MayaJigsaw.py";
	if(catchQuiet(`python("jigsawThread.isAlive()")`))
	{
		python("execfile(\""+$path+"\")");
	}
	else
	{
		if(`python("jigsawThread.isAlive()")`)
		{
			confirmDialog -title "Jigsaw Rendering" -message "The Jigsaw window is already open." -button "OK" -defaultButton "OK";
			return;
		}
		else
		{
			python("execfile(\""+$path+"\")");
		}
	}
}

// Event when Submit Job button is pressed
global proc DeadlineSubmitterOnOk()
{
	global string $DeadlineSubmitterWindow;
	global int $MayaRenderJobType;

	// Source a CustomSanityChecks.mel file, if it exists. This file can be used to set some of the defaults
	// for the properties below if necessary.
	string $sanityScriptPath = `getAttr defaultRenderGlobals.DeadlineMayaRepoPath` + "/CustomPostSanityChecks.mel";
	if( `file -q -exists $sanityScriptPath` )
	{
		
		print( "sourcing custom post sanity check file: " + $sanityScriptPath + "\n" );
		eval( "source \"" + $sanityScriptPath + "\";" );
		if( !CustomPostSanityCheck() )
			return;
	}
	
	// Check if we are doing a mental ray export
	int $jobType = `optionMenuGrp -q -select frw_mayaJobType`;
	if( `checkBox -q -v frw_submitEachRenderLayer` && `checkBox -q -v frw_overrideLayerSettings` && $jobType == $MayaRenderJobType )
		layoutDialog -parent $DeadlineSubmitterWindow -title "Override Layer Job Settings" -ui "LayerSettingsDialog";
	else
		SetupSubmission();
}

global proc DismissLayoutDialog()
{
	layoutDialog -dismiss "";
}

global proc OnExit()
{
	python("jigThreadExists = True");
	python("try:\n\tjigThreadExists = jigsawThread.isAlive()\nexcept:\n\tjigThreadExists = False");
	int $exists = `python("jigThreadExists")`;
	if($exists)
	{
		python("jigsawThread.closeJigsaw()");
	}
}

//Fills the given key/value arrays with info retrieved by running the given script
global proc GetIntegrationInfo( string $scriptPath, string $additionalArgs, string $keyArray[], string $valueArray[] )
{
	$pmResults = CallDeadlineCommand( "-ExecuteScript \"" + $scriptPath + "\" " + $additionalArgs, false );

	string $tempInfo[];
	$tempInfo = stringToStringArray( $pmResults, "\n" );

	if( size($tempInfo) > 0 )
	{
		int $keyCount = 0;

		$cleared = false;

		for ( $i = 0; $i < size( $tempInfo ); $i++ )
		{
			if ( match( ".+=", $tempInfo[ $i ] ) != "" )
			{
				if ( !$cleared )
				{
					//Only clear lists once we're sure we have valid output
					clear $keyArray;
					clear $valueArray;
					$cleared = true;
				}

				string $tokens[];
				string $value = "";

				if ( tokenize( $tempInfo[ $i ], "=", $tokens ) > 1 )
					$value = $tokens[1];

				string $key = $tokens[0];

				$keyCount++;
				stringArrayInsertAtIndex( $keyCount, $keyArray, $key );
				stringArrayInsertAtIndex( $keyCount, $valueArray, $value );
			}
		}
	}
}

global proc OpenIntegrationWindow()
{
	string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
	if ( size( $sceneFilePath ) == 0 )
	{
		confirmDialog -message "The scene has not been saved yet. Please save the scene and try again." -title "Pipeline Tools Error";
		return;
	}
	$integrationDir = `getAttr defaultRenderGlobals.DeadlineIntegrationRepoPath`;
	string $IntegrationScriptPath = $integrationDir + "/IntegrationUIStandAlone.py";
	string $integrationOptions = "-v 2 Maya -d Shotgun FTrack NIM" + " --path \"" + $sceneFilePath + "\"";
	$statusMessage = CallDeadlineCommand( "-ExecuteScript \"" + $IntegrationScriptPath + "\" " + $integrationOptions, false );
	SetPipelineToolStatus( $statusMessage );
}

// Function for returning the status message for pipeline tools (Ex. Draft On, Shotgun off).
global proc string GetPipelineToolStatus()
{
	string $pipelineToolsDir = `getAttr defaultRenderGlobals.DeadlineIntegrationRepoPath`;
	string $jobWriterPath = $pipelineToolsDir + "/JobWriter.py";
	string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
	if($sceneFilePath == "" )
	{
		$sceneFilePath = "EmptyPath";
	}
	string $pipelineOptions = "Maya " + "--status "+ "--scene-path \"" + $sceneFilePath + "\"";
	$status = (CallDeadlineCommand( "-ExecuteScript \"" + $jobWriterPath + "\" " + $pipelineOptions, false ));
	if(startsWith($status,"Error"))
	{
		print($status);
		return "Pipeline Tools Error";
	}

	return $status;
}

// Function to be called before submission to deadline, concatenates pipeline tool settings to .job file.
global proc ConcatenatePipelineSettingsToJob( string $jobPath, string $batchName )
{
	string $pipelineToolsDir = `getAttr defaultRenderGlobals.DeadlineIntegrationRepoPath`;
	string $jobWriterPath = $pipelineToolsDir + "/JobWriter.py";
	string $sceneFilePath = CheckSlashes( `file -q -sceneName` );
	string $pipelineOptions = "Maya " + "--write "+ "--scene-path " + "\"" + $sceneFilePath + "\"" + " --job-path " + "\"" + $jobPath + "\"" + " --batch-name " + "\"" + $batchName + "\"";
	CallDeadlineCommand( "-ExecuteScript \"" + $jobWriterPath + "\" " + $pipelineOptions, false );
}

// Grabs all needed submitter options and stores them in our deadline node (deadlineGlobals)
global proc GetSubmissionInfo()
{
	print( "Grabbing submitter info...\n" );
	string $subInfoString = CallDeadlineCommand( "-JSON -GetSubmissionInfo Pools Groups MaxPriority TaskLimit UserHomeDir RepoDir:submission/Maya/Main RepoDir:submission/Integration/Main RepoDir:submission/TileRendering/Main", false );
	python( "import json; deadlineSubmissionInfo=json.loads('" + encodeString($subInfoString) + "')['result']" );

	AddStringAttribute( "DeadlinePools" );
	AddStringAttribute( "DeadlineGroups" );
	AddLongAttribute( "DeadlineMaxPriority" );
	AddLongAttribute( "DeadlineTaskLimit" );
	AddStringAttribute( "DeadlineUserHomeDir" );
	AddStringAttribute( "DeadlineMayaRepoPath" );
	AddStringAttribute( "DeadlineIntegrationRepoPath" );

	// Pools
	string $pools[] = python( "deadlineSubmissionInfo['Pools']" );
	string $poolsString = stringArrayToString( $pools, "\n" );
	setAttr defaultRenderGlobals.DeadlinePools -type "string" $poolsString;

	// Groups
	string $groups[] = python( "deadlineSubmissionInfo['Groups']" );
	string $groupsString = stringArrayToString( $groups, "\n" );
	setAttr defaultRenderGlobals.DeadlineGroups -type "string" $groupsString;

	// Max Priority
	int $maxPriority = python( "deadlineSubmissionInfo['MaxPriority']" );
	setAttr defaultRenderGlobals.DeadlineMaxPriority $maxPriority;

	// Task Limit
	int $taskLimit = python( "deadlineSubmissionInfo['TaskLimit']" );
	setAttr defaultRenderGlobals.DeadlineTaskLimit $taskLimit;

	// User Home Directory
	string $userHomeDir = CheckSlashes( python( "deadlineSubmissionInfo['UserHomeDir']" ) );
	setAttr defaultRenderGlobals.DeadlineUserHomeDir -type "string" $userHomeDir;

	// Repository Directories
	string $mayaRepoDir = CheckSlashes( python( "deadlineSubmissionInfo['RepoDirs']['submission/Maya/Main']" ) );
	setAttr defaultRenderGlobals.DeadlineMayaRepoPath -type "string" $mayaRepoDir;

	string $integrationRepoDir = CheckSlashes( python( "deadlineSubmissionInfo['RepoDirs']['submission/Integration/Main']" ) );
	setAttr defaultRenderGlobals.DeadlineIntegrationRepoPath -type "string" $integrationRepoDir;
	
	string $tileRenderingRepoDir = CheckSlashes( python( "deadlineSubmissionInfo['RepoDirs']['submission/TileRendering/Main']" ) );
	if( catch( python( "import sys; sys.path.append(deadlineSubmissionInfo['RepoDirs']['submission/TileRendering/Main']);import TileRendering" ) ) )
	{
		// We log the error but won't fail as we don't know if the user will actually be tile rendering. It will error out later on if the user attempts to use tile rendering.
		print( "Error: Unable to import the Tile Rendering python module, ensure it exists in your Deadline Repository in '" + $tileRenderingRepoDir + "'.\n" );
	}

}

proc TryImportDeadlineMaya()
{
	print( "Importing deadline_maya...\n" );

	string $mayaPath = `getAttr "defaultRenderGlobals.DeadlineMayaRepoPath"`;
	python( "import sys" );
	python( "if not \"" + $mayaPath + "\" in sys.path:\n\tsys.path.append(\"" + $mayaPath + "\")" );
	int $loadSucceeded = !catch( python( "import deadline_maya" ) );

	// We want to load the deadline_maya.renderman module when RenderMan v22+ is an available renderer
	string $renderersAvailable[] = `renderer -query -namesOfAvailableRenderers`;
	// "renderman" (all lowercase) is RenderMan 22+
	// "renderMan" is RenderMan prior to version 22
	if( $loadSucceeded && stringArrayContains( "renderman", $renderersAvailable ) )
	{
		python( "from deadline_maya import renderman as dlRenderman" );
	}
}

proc TryImportDeadlineSubmission()
{
	print( "Importing deadline_submission...\n" );

	string $integrationPath = `getAttr "defaultRenderGlobals.DeadlineIntegrationRepoPath"`;
	python( "import sys" );
	python( "if not \"" + $integrationPath + "\" in sys.path:\n\tsys.path.append(\"" + $integrationPath + "\")" );
	int $loadSucceeded = !catch( python( "import deadline_submission" ) );
}

// ===============================================================================================================
// The main function called by the Maya proxy script
// ===============================================================================================================

global proc SubmitJobToDeadline()
{
	global string $DeadlineSubmitterWindow;
	global string $ImageOutputPathGrp;
	global string $StartupScriptPathGrp;
	global string $ProjectPathGrp;
	global string $MentalRayFilenameGrp;
	global string $CompositeNamePathGrp;
	global string $VRayFilenameGrp;
	global string $LimitGroupGrp;
	global string $DependenciesGrp;
	global string $MachineListGrp;
	global string $JobNameGrp;
	
	global string $MayaRenderOptionsRollout;
	global string $MayaRenderOptionsArnoldRollout;
	global string $MayaRenderOptionsMentalRayRollout;
	global string $MayaRenderOptionsRedshiftRollout;
	global string $MayaRenderOptionsIRayRollout;
	global string $MayaRenderOptionsVRayRollout;
	global string $MayaRenderOptionsTileRollout;
	global string $MayaRenderOptionsJigsawRollout;
	global string $MentalRayExportRollout;
	global string $MentalRayExportRenderJobRollout;
	global string $VrayExportRollout;
	global string $VrayExportRenderJobRollout;
	global string $VrayExportVrimgJobRollout;
	global string $RendermanExportRollout;
	global string $RendermanExportRenderJobRollout;
	global string $ArnoldExportRollout;
	global string $ArnoldExportRenderJobRollout;
	global string $BifrostSimulationJobRollout;
	global string $AlembicExportJobRollout;
	global string $AlembicAdvancedOptionsJobRollout;
	global string $MayaScriptJobRollout;
	global string $FluidCachingJobRollout;
	global string $GeometryCachingJobRollout;
	global string $RedshiftExportRollout;
	global string $RedshiftExportRenderJobRollout;
	
	global string $MaxwellExportRollout;
	global string $MaxwellExportRenderJobRollout;
	global string $MaxwellExportCoopOptionsRollout;
	
	global string $openJigsawBtn;
	
	global int $PreviousImageCompType;
	global int $SelectedImageCompType;
	
	global string $VrayLimitGroupGrp;
	global string $VrayMachineListGrp;
	
	global string $MentalLimitGroupGrp;
	global string $MentalMachineListGrp;
	
	global string $RendermanLimitGroupGrp;
	global string $RendermanMachineListGrp;
	
	global string $ArnoldLimitGroupGrp;
	global string $ArnoldMachineListGrp;
	
	global string $MaxwellLimitGroupGrp;
	global string $MaxwellMachineListGrp;
	global string $MaxwellOutputScriptListGrp;

	global string $RedshiftLimitGroupGrp;
	global string $RedshiftMachineListGrp;
	
	global string $BifrostDirectoryButtonGrp;
	global string $BifrostFileButtonGrp;

	global string $MayaScriptButtonGrp;

	global string $AlembicFileButtonGrp;

	global string $GeometryCachingDirButtonGrp;
	global string $FluidCachingDirButtonGrp;

	global string $PipelineToolStatusLabel;
	
	
	// This is a workaround for what seems like a bug in Maya vector rendering. Without it, the
	// renderer would spit out "Error: No object matches name: defaultRenderGlobals.imageNamePrefix".
	AddStringAttribute( "imageNamePrefix" );

	GetSubmissionInfo();

	// Attempt to import the DeadlineSubmission python package
	TryImportDeadlineSubmission();
	// Attempt to import the DeadlineMaya python package
	TryImportDeadlineMaya();

	// Source a CustomSanityChecks.mel file, if it exists. This file can be used to set some of the defaults
	// for the properties below if necessary.
	string $sanityScriptPath = `getAttr defaultRenderGlobals.DeadlineMayaRepoPath` + "/CustomSanityChecks.mel";
	if( `file -q -exists $sanityScriptPath` )
	{
		print( "sourcing custom sanity check file: " + $sanityScriptPath + "\n" );
		eval( "source \"" + $sanityScriptPath + "\";" );
	}

	int $maximumPriority = `getAttr defaultRenderGlobals.DeadlineMaxPriority`;

	// Get the renderer.
	string $renderer = GetCurrentRenderer();
	// Get the initial property values.
	string $jobName = `attributeExists deadlineJobName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobName` : GetStrippedSceneFileName();	
	string $jobComment = `attributeExists deadlineJobComment defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobComment` : "";
	string $department = `attributeExists deadlineDepartment defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDepartment` : "";
	string $savedGroup = `attributeExists deadlineGroup defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineGroup` : "none";

	string $savedJobPool = `attributeExists deadlineJobPool defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobPool` : "none";
	string $savedJobSecondaryPool = `attributeExists deadlineJobSecondaryPool defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobSecondaryPool` : "";
	int $priority = `attributeExists deadlineJobPriority defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineJobPriority` : $maximumPriority / 2;
	int $limitCount = `attributeExists deadlineLimitCount defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLimitCount` : 0;
	int $concurrentTasks = `attributeExists deadlineConcurrentTasks defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineConcurrentTasks` : 1;
	int $SlaveTimeout = `attributeExists deadlineSlaveTimeout defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSlaveTimeout` : 0;
	int $MinSlaveTimeout = `attributeExists deadlineMinSlaveTimeout defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMinSlaveTimeout` : 0;
	int $AutoTaskTimeout = `attributeExists deadlineAutoTaskTimeout defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineAutoTaskTimeout` : false;
	string $limitGroups = `attributeExists deadlineLimitGroups defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLimitGroups` : "";
	string $dependencies = "";
	int $submitAsSuspended = `attributeExists deadlineSubmitAsSuspended defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitAsSuspended` : false;
	int $closeOnSubmission = `attributeExists deadlineCloseOnSubmission defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineCloseOnSubmission` : false;
	int $precacheForAWSPortal = `attributeExists deadlinePrecacheAssetsForAWS defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlinePrecacheAssetsForAWS` : false;
	int $conductorDepScan = `attributeExists deadlineConductorDepScan defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineConductorDepScan` : true;
	
	string $machineList = `attributeExists deadlineMachineList defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMachineList` : "";
	int $isBlacklist = `attributeExists deadlineIsBlacklist defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIsBlacklist` : false;
	
	int $chunkSize = `attributeExists deadlineChunkSize defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineChunkSize` : 1;
	int $submitMayaScene = `attributeExists deadlineSubmitMayaScene defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMayaScene` : false;
	int $submitEachRenderLayer = `attributeExists deadlineSubmitEachRenderLayer defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitEachRenderLayer` : true;
	int $overrideGlobalRange = `attributeExists deadlineOverrideGlobalRange defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineOverrideGlobalRange` : false;
	int $overrideLayerSettings = `attributeExists deadlineOverrideLayerSettings defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineOverrideLayerSettings` : false;
	int $submitEachCamera = `attributeExists deadlineSubmitEachCamera defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitEachCamera` : false;
	int $ignoreDefaultCameras = `attributeExists deadlineIgnoreDefaultCameras defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIgnoreDefaultCameras` : false;
	int $useMayaBatchPlugin = `attributeExists deadlineUseMayaBatchPlugin defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUseMayaBatchPlugin` : true;
	int $useLocalAssetCaching = `attributeExists deadlineUseLocalAssetCaching defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineUseLocalAssetCaching` : false;
	int $localRendering = `attributeExists deadlineLocalRendering defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineLocalRendering` : false;
	int $strictErrorChecking = `attributeExists deadlineStrictErrorChecking defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineStrictErrorChecking` : true;
	string $startupScript = `attributeExists deadlineStartupScript defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineStartupScript` : "";
	string $mayaArgs = `attributeExists deadlineMayaArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMayaArgs` : "";
	
	int $submitMentalRayJob = `attributeExists deadlineSubmitMentalRayJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMentalRayJob` : false;
	int $mentalRayThreads = `attributeExists deadlineMentalRayThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayThreads` : 0;
	int $mentalRayOffset = `attributeExists deadlineMentalRayOffset defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayOffset` : 0;
	int $mentalRayLocalRendering = `attributeExists deadlineMentalRayLocalRendering defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayLocalRendering` : false;
	string $mentalRayArgs = `attributeExists deadlineMentalRayArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayArgs` : "";
	
	string $savedOutputFilePath = GetImageDirectory();
	string $projectPath = `workspace -q -fullName`;
	
	string $pmIntegration = `attributeExists deadlineProjectManagement defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineProjectManagement` : "Shotgun";	
	
	int $overrideGlobalRangeEnable = false;
	int $overrideLayerSettingsEnable = false;
	int $tileRenderingEnable = true;
	int $jigsawRenderingEnable = true;
	int $regionRendering = false;
	int $tilesInX = `attributeExists deadlineTilesInX defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTilesInX` : 2;
	int $tilesInY = `attributeExists deadlineTilesInY defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTilesInY` : 2;
	int $tileSingleJob = `attributeExists deadlineTileSingleJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileSingleJob` : true;
	int $tileDependentJob = `attributeExists deadlineTileDependentJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileDependentJob` : true;
	int $tileCompositeOver = `attributeExists deadlineTileCompositeOver defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCompositeOver` : false;
	string $tileCompositeOverName = `attributeExists deadlineTileCompositeOverName defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCompositeOverName` : "";
	int $tileCleanupJob = `attributeExists deadlineTileCleanupJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineTileCleanupJob` : false;
	
	int $tileErrorOnMissing = `attributeExists tileErrorOnMissing defaultRenderGlobals` ? `getAttr defaultRenderGlobals.tileErrorOnMissing` : true;
	int $tileMissingBackground = `attributeExists tileMissingBackground defaultRenderGlobals` ? `getAttr defaultRenderGlobals.tileMissingBackground` : true;
	
	int $deadlineGPUsPerTask = `attributeExists deadlineGPUsPerTask defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineGPUsPerTask` : 0;
	string $deadlineGPUsSelectDevices = `attributeExists deadlineGPUsSelectDevices defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineGPUsSelectDevices` : "";
	
	int $irayUseCPUs = `attributeExists deadlineIRayUseCPUs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIRayUseCPUs` : 1;
	float $irayCPULoad = `attributeExists deadlineIRayCPULoad defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineIRayCPULoad` : 4.0;
	
	
	int $mentalRayAutoMemoryLimit = `attributeExists deadlineMentalRayAutoMemoryLimit defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayAutoMemoryLimit` : true;
	int $mentalRayMemoryLimit = `attributeExists deadlineMentalRayMemoryLimit defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayMemoryLimit` : 0;
	int $vrayAutoMemoryEnabled = `attributeExists deadlineVrayAutoMemoryEnabled defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVrayAutoMemoryEnabled` : false;
	int $vrayAutoMemoryBuffer = `attributeExists deadlineVrayAutoMemoryBuffer defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVrayAutoMemoryBuffer` : 500;
	
	string $mentalRayFilename = `attributeExists deadlineMentalRayFilename defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMentalRayFilename` : "";
	
	string $vrayFilename = `attributeExists deadlineVRayFilename defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVRayFilename` : "";
	int $submitVRayJob = `attributeExists deadlineSubmitVRayJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitVRayJob` : false;
	int $vrayThreads = `attributeExists deadlineVRayThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineVRayThreads` : 0;
	
	int $submitVrimg2ExrJob = `attributeExists deadlineSubmitVrimg2ExrJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitVrimg2ExrJob` : false;
	int $deleteVrimgFiles = `attributeExists deadlineDeleteVrimgFiles defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDeleteVrimgFiles` : false;
	
	int $exportRenderManThreads = `attributeExists deadlineExportRenderManThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportRenderManThreads` : 0;
	int $renderRenderManWithRis = `attributeExists deadlineRenderRenderManWithRis defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderRenderManWithRis` : true;
	int $submitRenderManJob = `attributeExists deadlineSubmitRenderManJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitRenderManJob` : false;
	int $renderManFrameDependent = `attributeExists deadlineRenderManFrameDependent defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManFrameDependent` : true;
	int $rendermanThreads = `attributeExists deadlineRenderManThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManThreads` : 0;
	string $rendermanArgs = `attributeExists deadlineRenderManArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRenderManArgs` : "";
	
	int $maxwellAutoMergeFiles = true;

	int $submitArnoldJob = `attributeExists deadlineSubmitArnoldJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitArnoldJob` : false;
	int $arnoldLayerSubmission = `attributeExists deadlineArnoldLayerSubmission defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineArnoldLayerSubmission` : false;
	int $exportArnoldLocal = `attributeExists deadlineExportArnoldLocal defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportArnoldLocal` : false;
	int $exportArnoldCompressed = `attributeExists deadlineExportArnoldCompressed defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportArnoldCompressed` : false;
	int $arnoldThreads = `attributeExists deadlineArnoldThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineArnoldThreads` : 0;
	string $arnoldArgs = `attributeExists deadlineArnoldArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineArnoldArgs` : "";

	int $submitMaxwellJob = `attributeExists deadlineSubmitMaxwellJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitMaxwellJob` : false;
	int $exportMaxwellLocal = `attributeExists deadlineExportMaxwellLocal defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportMaxwellLocal` : false;
	int $maxwellThreads = `attributeExists deadlineMaxwellThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMaxwellThreads` : 0;
	string $maxwellArgs = `attributeExists deadlineMaxwellArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineMaxwellArgs` : "";

	int $submitRedshiftJob = `attributeExists deadlineSubmitRedshiftJob defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineSubmitRedshiftJob` : false;
	int $exportRedshiftLocal = `attributeExists deadlineExportRedshiftLocal defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineExportRedshiftLocal` : false;
	int $redshiftFrameDependent = `attributeExists deadlineRedshiftFrameDependent defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftFrameDependent` : false;
	int $redshiftLayerSubmission = `attributeExists deadlineRedshiftLayerSubmission defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftLayerSubmission` : false;
	int $redshiftThreads = `attributeExists deadlineRedshiftThreads defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftThreads` : 0;
	string $redshiftArgs = `attributeExists deadlineRedshiftArgs defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineRedshiftArgs` : "";
	
	string $deadlinePools[] = stringToStringArray( `getAttr defaultRenderGlobals.DeadlinePools`, "\n" );
	string $deadlineGroups[] = stringToStringArray( `getAttr defaultRenderGlobals.DeadlineGroups`, "\n" );

	int $disableAutoCameraTag = `attributeExists deadlineDisableAutoCameraTag defaultRenderGlobals` ? `getAttr defaultRenderGlobals.deadlineDisableAutoCameraTag` : false;

	$PipelineToolStatus = GetPipelineToolStatus();
	
	CreateOptionsNode( $renderer );
	
	// Get the frame range.
	int $currTime = `currentTime -query`;
	string $frameRange = DeadlineGetFrameList();
	
	int $renderHalfFrames = DeadlineGetRenderHalfFrames();
	
	// Get the CPU count
	int $cpuEnabled = EnableCpuOption( $renderer );
	int $cpus = 0;
	if( $cpuEnabled )
		$cpus = GetCpuSetting( $renderer );
	
	// Get if layers are enabled
	$renderLayerEnabled = IsRenderLayersOn();
	
	// Delete any previous windows.
	if( `window -exists DeadlineSubmitWindow` )
		deleteUI -window DeadlineSubmitWindow;
	
	// Create a new submission dialog window.
	string $window = `window DeadlineSubmitWindow`;
	if( `windowPref -exists DeadlineSubmitWindow` )
		windowPref -remove DeadlineSubmitWindow; // reset preference
	
	// Get the location of the main window.
	global string $gMainWindow;
	int $mainTopLeft[] = `window -q -tlc $gMainWindow`;
	
	// Add controls to the submission dialog.
	int $windowWidth = 530;
	int $windowHeight = 780;
	
	int $labelWidth = 160;
	int $controlWidth = 330;
	
	string $maxwellScript = "";
	if( `attributeExists mxsPath maxwellRenderOptions` )
	{
		$maxwellScript = `getAttr maxwellRenderOptions.mxsPath`;
	}
	if( $maxwellScript == "" )
	{
		string $exportDir = `workspace -q -fre "translatorData"`;
		string $sceneName = GetStrippedSceneFileName();
		
		$maxwellScript = $projectPath +"/" + $exportDir + "/"+$sceneName + ".mxs";
		
	}
	
	$DeadlineSubmitterWindow = `window -e -resizeToFitChildren true -sizeable true -title "Submit Job To Deadline" -widthHeight ($windowWidth+24) $windowHeight -tlc ($mainTopLeft[0] + 50) ($mainTopLeft[1] + 50) DeadlineSubmitWindow`;
	formLayout -width ($windowWidth+16) -nd 100 mainFormLayout;
	
	//This is the main scrollable element for the dialog
	scrollLayout -width ($windowWidth+16) -horizontalScrollBarThickness 0 mainScrollLayout;
	
		//
			columnLayout -adj true -columnAttach "both" 4 mayaTabLayout;
			
				frameLayout -label "Job Description" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						$JobNameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Job Name" -buttonLabel "<" -text $jobName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the job (press '<' button to use the scene file name)" frw_JobName`;
						textFieldButtonGrp -e -bc SetJobName $JobNameGrp;
						
						textFieldGrp -label "Comment" -cl2 "left" "left" -cw2 $labelWidth 320 -text $jobComment -changeCommand SavePersistentDeadlineOptions -annotation "A brief comment about the job" frw_JobComment;
						textFieldGrp -label "Department" -cl2 "left" "left" -cw2 $labelWidth 320 -text $department -changeCommand SavePersistentDeadlineOptions -annotation "The department the job (or the job's user) belongs to" frw_Department;
					setParent ..;
				setParent ..;
			
				frameLayout -label "Job Scheduling" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						string $poolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlinePool`;
						for( $i = 0; $i < size($deadlinePools); ++$i )
						{ 
							menuItem -label $deadlinePools[$i];
							if( $deadlinePools[$i] == $savedJobPool )
								optionMenuGrp -e -select ($i+1) $poolsBox;
						}
						
						string $secondaryPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Workers" frw_deadlineSecondaryPool`;
						menuItem -label "";
						if( "" == $savedJobSecondaryPool )
							optionMenuGrp -e -select 1 $secondaryPoolsBox;
						
						for( $i = 0; $i < size($deadlinePools); ++$i )
						{ 
							menuItem -label $deadlinePools[$i];
							if( $deadlinePools[$i] == $savedJobSecondaryPool )
								optionMenuGrp -e -select ($i+2) $secondaryPoolsBox;
						}
							
						string $groupsBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_Group`;
						for( $i = 0; $i < size( $deadlineGroups ); ++$i )
						{ 
							menuItem -label $deadlineGroups[$i];
							if( $deadlineGroups[$i] == $savedGroup )
								optionMenuGrp -e -select ($i+1) $groupsBox;
						}
						
						intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_JobPriority;
						intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_LimitCount;
						intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a Worker can dequeue for this job simultaneously" frw_ConcurrentTasks;
						intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a Worker has to render an individual task before timing out (specify 0 for no limit)" frw_SlaveTimeout;
						intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a Worker should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MinSlaveTimeout;
						rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
							text -align "left" -label "" frw_dummySubmitSuspendedLabel;
							checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_AutoTaskTimeout;
						setParent ..;
						
						$LimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text $limitGroups -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_limitGroups`;
						textFieldButtonGrp -e -bc ("dlSetLimitGroups( \""+$LimitGroupGrp+"\"  )") $LimitGroupGrp;
							
						$DependenciesGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Dependencies" -buttonLabel "..." -text $dependencies -changeCommand SavePersistentDeadlineOptions -annotation "The jobs that this job is dependent on." frw_dependencies`;
						textFieldButtonGrp -e -bc ("dlSetDependencies( \""+$DependenciesGrp+"\")") $DependenciesGrp;
						
						$MachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text $machineList -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_machineList`;
						textFieldButtonGrp -e -bc ("dlSetMachineList( \""+$MachineListGrp+"\")") $MachineListGrp;
						
						rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
							string $onCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_onComplete`;
							menuItem -label "Nothing";
							menuItem -label "Archive";
							menuItem -label "Delete";
							optionMenuGrp -e -select (1) $onCompleteBox;
							
							checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_isBlacklist;
						setParent ..;
						
						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "" frw_dummySubmitSuspendedLabel;
							checkBox -label "Submit As Suspended" -v $submitAsSuspended -changeCommand SavePersistentDeadlineOptions -annotation "If checked, this job will be submitted in the suspended state" frw_submitAsSuspended;
							checkBox -label "Close on Submission" -v $closeOnSubmission -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the submitter will close after job submission is completed" frw_closeOnSubmission;
						setParent ..;						

						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "AWS Portal" frw_AWSPortaSettingsLabel;
							checkBox -label "Precache assets for AWS" -v $precacheForAWSPortal -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the scene's assets will be precached for rendering with AWS Portal" frw_precacheAssetsForAWS;
						setParent ..;
						
						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "Conductor" frw_ConductorSettingsLabel;
							checkBox -label "Scan forr Dependencies" -v $conductorDepScan -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the scene's dependencies will be written to a Conductor sidecar files (.cdepends) bel" frw_conductorDepScan;
						setParent ..;						
						
					setParent ..;
				setParent ..;
				
				frameLayout -label "Render Options" -labelVisible true -borderVisible false -collapsable true;
					columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
						int $framesEnabled = true;
						if( $renderLayerEnabled && $submitEachRenderLayer )
							$framesEnabled = $overrideLayerSettings;
						$framesEnabled = $framesEnabled && IsAnimatedOn();
						
						textFieldGrp -label "Frame List" -en $framesEnabled -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Enter a list of frames to render, separated by commas for separate frames, or dashes for continuous sequences of frames. e.g. 1, 5-10, 100" -text $frameRange frw_FrameList;
						intSliderGrp -label "Frames Per Task" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v $chunkSize -changeCommand SavePersistentDeadlineOptions -annotation "Each task for the job will consist of this many frames" frw_FrameGroup;
						
						frameLayout -label "Additional Frame Options" -labelVisible true -borderVisible false -collapsable true -collapse true;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								
								string $renderPreviewJobFirstBox = `checkBox -en $framesEnabled -label "Render Preview Job First" -changeCommand SavePersistentDeadlineOptions -annotation "When checked, two jobs will be submitted - a PREVIEW job with a fraction of the frames, and a REST job with all other frames.\n\nThe PREVIEW job can be submitted with slightly higher priority and will provide a glimpse into the final result.\n\nIf its output looks incorrect, you can suspend the REST job before wasting render time rendering a wrong submission." frw_renderPreviewJobFirst`;
								intSliderGrp -label "Priority Offset" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue $maximumPriority -v 5 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Priority Increase for the PREVIEW job.\n\nFor example if the Job Priority is set to 50 and this value is +5, the PREVIEW job will be submitted with Priority of 55 and the REST job with 50." frw_PreviewPriority;
								intSliderGrp -label "Number of Preview Frames" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v 5 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the number of frames to be submitted as a PREVIEW job.\n\nThe frames will be taken at equal intervals, for example a value of 2 will send the first and last frames, a value of 3 will send first, middle and last and so on." frw_PreviewFrames;
								checkBox -en $framesEnabled -label "Submit Dependent Job With Remaining Frames" -changeCommand SavePersistentDeadlineOptions -annotation "When checked, the [REST OF FRAMES] Job will be made dependent on the [PREVIEW FRAMES] Job.\n\nWhen unchecked, the [REST OF FRAMES] Job will use the same dependencies (none or custom) as the [PREVIEW FRAMES] Job." frw_dependent;
								
								rowLayout -numberOfColumns 1 -cw1 $labelWidth -ct1 "left";
									string $outOfOrderBox = `optionMenuGrp -label "Task Order" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Order in which the Task List will be processed." frw_taskOrder`;
									menuItem -label "First To Last (Forward)";
									menuItem -label "Every Nth, Then Forward";
									menuItem -label "Every Nth - Block Fill";
									menuItem -label "Every Nth - Half Raster Refine";
									menuItem -label "Last To First (Reverse)";
									menuItem -label "First And Last Frames First";
									menuItem -label "From Both Ends";
									menuItem -label "From Center";
									menuItem -label "From Both Ends And From Center";
									menuItem -label "Random";
									optionMenuGrp -e -select (1) $outOfOrderBox;
								setParent ..;
								
								intSliderGrp -label "Out Of Order Step" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 1000 -v 2 -changeCommand SavePersistentDeadlineOptions -annotation "Defines the Nth frame step to use for the Task List Order settings." frw_taskOrderStep;
						
							setParent..;
						setParent..;
						
						rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
							string $camerasBox = `optionMenuGrp -label "Camera" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "Leave blank to render using the default camera settings." frw_camera`;
							//string $cameraList[] = `ls -cameras`;
							menuItem -label " ";
							//int $i; for( $i = 0; $i < size($cameraList); ++$i )
							//	menuItem -label $cameraList[$i];
						
							string $cameraNames[] = `listTransforms -cameras`;
							for( $cameraName in $cameraNames )
								menuItem -label $cameraName;
						
							optionMenuGrp -e -select (1) $camerasBox;

							checkBox -enable ( `optionMenuGrp -q -value frw_camera` != " " ) -label "Disable Auto Camera Tag" -align "left" -v $disableAutoCameraTag -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the output files will not be placed into a subdirectory named after a camera unless specified in render settings" frw_disableAutoCameraTag;
						setParent ..;
						
						$ProjectPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Project Path" -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "Use this Maya project path to load the Maya scene" frw_projectPath`;
						textFieldButtonGrp -e -bc ("dlSetDirectory(\"" + $ProjectPathGrp + "\")") $ProjectPathGrp;
						
						$ImageOutputPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output Path" -buttonLabel "..." -text $savedOutputFilePath -changeCommand SavePersistentDeadlineOptions -annotation "The path to which the output files will be sent. Must be network accessible." frw_outputFilePath`;
						textFieldButtonGrp -e -bc ("dlSetDirectory(\"" + $ImageOutputPathGrp + "\")") $ImageOutputPathGrp;

						$mayaBuildEnabled = true;
						rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
							string $mayaBuildBox = `optionMenuGrp -en $mayaBuildEnabled -label "Maya Build" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Force Deadline to render using the specified build of Maya" frw_mayaBuild`;
							menuItem -label "None";
							menuItem -label "32bit";
							menuItem -label "64bit";
							if( $mayaBuildEnabled )
							{
								if( `about -macOS` )
									optionMenuGrp -e -select (1) $mayaBuildBox;
								else
								{
									if( `about -is64` )
										optionMenuGrp -e -select (3) $mayaBuildBox;
									else
										optionMenuGrp -e -select (2) $mayaBuildBox;
								}
							}
							else
								optionMenuGrp -e -select (1) $mayaBuildBox;
							
							string $submitMayaSceneBox = `checkBox -label "Submit Maya Scene File" -v $submitMayaScene -changeCommand SavePersistentDeadlineOptions -annotation "If unchecked, the Maya scene file should be network accessible. If checked, XGen files in the scene's directory will also be submitted." frw_submitMayaScene`;
						setParent ..;
							 
						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "" frw_dummyMayaBatchLabel;
							checkBox -label "Use MayaBatch Plugin" -align "left" -v $useMayaBatchPlugin -changeCommand SavePersistentDeadlineOptions -annotation "The MayaBatch plugin is a new Maya plugin which keeps the scene loaded between frames" frw_useMayaBatchPlugin;
							checkBox -enable (!$useMayaBatchPlugin) -label "Ignore Error Code 211" -align "left" -v 0 -annotation "Does not fail and requeue the render on an Exit Code of 211. Useful if the render actually succeeds and is still throwing this error." frw_ignoreError211;
						setParent ..;

						rowLayout -numberOfColumns 3 -cw3 $labelWidth 158 160 -ct3 "left" "left" "left";
							text -align "left" -label "" frw_dummyLocalAssetCachingLabel;
							checkBox -label "Strict Error Checking" -align "left" -v $strictErrorChecking -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Deadline will fail the render job if any error message is detected" frw_strictErrorChecking;
							checkBox -enable ($useMayaBatchPlugin) -label "Use Local Asset Caching" -align "left" -v $useLocalAssetCaching -changeCommand SavePersistentDeadlineOptions -annotation "If enabled, Workers for this job will attempt to copy all network assets* to their local cache* and\nremap those assets in the scene file to point to the local cache (file structure is preserved).\n\n*Options specified at the repository level" frw_useLocalAssetCaching;
						setParent ..;
						
						$StartupScriptPathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Startup Script" -buttonLabel "..." -text $startupScript -changeCommand SavePersistentDeadlineOptions -annotation "Maya will source the specified script file on startup" frw_startupScript`;
						textFieldButtonGrp -e -bc ( "dlSetLoadFilename( \"" + $StartupScriptPathGrp + "\", \"Melscript Files (*.mel);;Python Files (*.py);;All files (*)\" )" ) $StartupScriptPathGrp;
						
						textFieldGrp -enable (!$useMayaBatchPlugin) -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $mayaArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Maya" frw_mayaArgs;
						
						string $mayaJobTypeBox = `optionMenuGrp -label "Deadline Job Type" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand UpdateJobType -annotation "Select the type of job that you want to submit to Deadline" frw_mayaJobType`;
						menuItem -label "Maya Render Job";
						menuItem -label "Mental Ray Export Job";
						menuItem -label "VRay Export Job";
						menuItem -label "RenderMan Export Job";
						menuItem -label "Arnold Export Job";
						menuItem -label "Maxwell Export Job";
						menuItem -label "Bifrost Simulation Job";
						menuItem -label "Alembic Export Job";
						menuItem -label "Maya Script Job";
						menuItem -label "Fluid Caching Job";
						menuItem -label "Geometry Caching Job";
						menuItem -label "Redshift Export Job";

						optionMenuGrp -e -select (1) $mayaJobTypeBox;
						
						$MayaRenderOptionsRollout = `frameLayout -label "Maya Render Job" -labelVisible true -borderVisible false -collapsable true`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Renders a normal Maya job using the current Maya renderer." frw_tileLabel;
								setParent ..;
								
								intSliderGrp -en $cpuEnabled -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 64 -v $cpus -changeCommand SavePersistentDeadlineOptions -annotation  "The number of processors to use during rendering (specify 0 to use all processors available)" frw_MaxCPUs;
								
								int $frameNumberOffsetEnabled = IsAnimatedOn();
								intSliderGrp -label "Frame Number Offset" -en $frameNumberOffsetEnabled -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10000 -maxValue 10000 -v 0 -changeCommand SavePersistentDeadlineOptions -annotation  "Uses Maya's frame renumbering option to offset the frames that are rendered" frw_frameNumberOffset;
								
								if( $renderLayerEnabled )
								{
									$tileRenderingEnable = $submitEachRenderLayer; // use to submit as separate job value for the tile rendering enable
									$overrideGlobalRangeEnable = $submitEachRenderLayer;
									$overrideLayerSettingsEnable = $submitEachRenderLayer;
									if( !$submitEachRenderLayer )
										$regionRendering = false;
								}
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									string $submitEachRenderLayerBox = `checkBox -en $renderLayerEnabled -label "Submit Render Layers As Separate Jobs" -v $submitEachRenderLayer -changeCommand SavePersistentDeadlineOptions -annotation "Check this to submit each renderable Render Layer as a separate Deadline job. Note that the frame range will be pulled from the render globals for each layer." frw_submitEachRenderLayer`;
									checkBox -enable $overrideLayerSettingsEnable -label "Override Layer Job Settings" -v $overrideLayerSettings -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the job name, frame range, and task size can be set for each render layer when submitting a separate job for each layer" frw_overrideLayerSettings;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -label "Submit Cameras As Separate Jobs" -align "left" -v $submitEachCamera -changeCommand SavePersistentDeadlineOptions -annotation "Check this to submit each renderable Camera as a separate Deadline job." frw_submitEachCamera;
									checkBox -enable ($submitEachCamera) -label "Ignore Default Cameras" -align "left" -v $ignoreDefaultCameras -changeCommand SavePersistentDeadlineOptions -annotation "Check this to ignore default cameras (persp, top, etc) when submitting each renderable Camera as a separate Deadline job." frw_ignoreDefaultCameras;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -label "Enable Local Rendering" -align "left" -en ( $renderer != "renderman22" ) -v $localRendering -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the Workers will render locally, and then copy the images to the network output directory on completion" frw_localRendering;
									$halfFramesEnabled = ShowHalfFramesOption( $renderer );
									checkBox -en $halfFramesEnabled -label "Render Half Frames" -v $renderHalfFrames -changeCommand SavePersistentDeadlineOptions -annotation "If checked, frames will be split into two using a step of 0.5" frw_renderHalfFrames;
								setParent ..;
							setParent ..;
						setParent ..;
						
						$MayaRenderOptionsArnoldRollout = `frameLayout -label "Arnold Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "arnold")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								
								$arnoldVerboseEnabled = ( $renderer == "arnold" );
								int $mayaToArnoldVersion = GetPluginMajorVersion( "mtoa" );
								int $arnoldVerbosityDefault = 2;

								string $arnoldVerboseBox = `optionMenuGrp -en $arnoldVerboseEnabled -label "Arnold Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Arnold renders" frw_arnoldVerbose`;
								menuItem -label "0";
								menuItem -label "1";
								menuItem -label "2";
								
								// MtoA version 3.* changed the verbosity options. Need to add the new option and set a new default. //
								if( $mayaToArnoldVersion >= 3 )
								{
									menuItem -label "3";
									$arnoldVerbosityDefault = 3;
								}

								if( $arnoldVerboseEnabled )
									optionMenuGrp -e -select ($arnoldVerbosityDefault) $arnoldVerboseBox;
							setParent ..;
						setParent ..;
						
						$MayaRenderOptionsMentalRayRollout = `frameLayout -label "Mental Ray Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "mentalRay")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								
								$mentalRayVerboseEnabled = ( $renderer == "mentalRay" );
								string $mentalRayVerboseBox = `optionMenuGrp -en $mentalRayVerboseEnabled -label "Mental Ray Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Mental Ray renders" frw_mentalRayVerbose`;
								menuItem -label "No Messages";
								menuItem -label "Fatal Messages Only";
								menuItem -label "Error Messages";
								menuItem -label "Warning Messages";
								menuItem -label "Info Messages";
								menuItem -label "Progress Messages";
								menuItem -label "Detailed Messages (Debug)";
								if( $mentalRayVerboseEnabled )
									optionMenuGrp -e -select (6) $mentalRayVerboseBox;
								
								checkBox -label "Auto Memory Limit" -align "left" -v $mentalRayAutoMemoryLimit -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Mental Ray will automatically detect the optimal memory limit when rendering" frw_autoMemoryLimit;

								intSliderGrp -enable (!$mentalRayAutoMemoryLimit) -label "Memory Limit (MB)" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 100000 -v $mentalRayMemoryLimit -changeCommand SavePersistentDeadlineOptions -annotation  "Soft limit (in MB) for the memory used by Mental Ray (specify 0 for unlimited memory)" frw_memoryLimit;
								
							setParent ..;
						setParent ..;
						
						$MayaRenderOptionsRedshiftRollout = `frameLayout -label "Redshift Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "redshift")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								$redshiftVerboseEnabled = ( $renderer == "redshift" );
								string $redshiftVerboseBox = `optionMenuGrp -en $redshiftVerboseEnabled -label "Redshift Verbosity" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Set the verbosity level for Redshift renders" frw_redshiftVerbose`;
								menuItem -label "Errors and Warnings";
								menuItem -label "Detailed Info";
								menuItem -label "Debug";
								if( $redshiftVerboseEnabled )
									optionMenuGrp -e -select (3) $redshiftVerboseBox;
							setParent ..;
						setParent ..;
												
						$MayaRenderOptionsIRayRollout = `frameLayout -label "IRay Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "ifmIrayPhotoreal")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Render Using CPUs" -v $irayUseCPUs -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, then the CPUs will be used as part of the render." frw_irayUseCPUs;
								floatSliderGrp -enable ( $irayUseCPUs ) -label "CPU Load" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1.0 -maxValue 8.0 -v $irayCPULoad -changeCommand SavePersistentDeadlineOptions -annotation  "The maximum CPU load each task can use." frw_irayCPULoad;

							setParent ..;
						setParent ..;
								
						$MayaRenderOptionsVRayRollout = `frameLayout -label "VRay Options" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "vray")`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -enable $useMayaBatchPlugin -label "Auto Memory Limit Detection (Requires the MayaBatch Plugin)" -align "left" -v $vrayAutoMemoryEnabled -changeCommand SavePersistentDeadlineOptions -annotation "If checked, Deadline will automatically detect the dynamic memory limit for VRay prior to rendering." frw_vrayAutoMemoryEnabled;
								
								intSliderGrp -enable ($useMayaBatchPlugin && $vrayAutoMemoryEnabled) -label "Memory Buffer (MB)" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 100000 -v $vrayAutoMemoryBuffer -changeCommand SavePersistentDeadlineOptions -annotation  "Deadline subtracts this value from the system's unused memory to determine the dynamic memory limit for VRay." frw_vrayAutoMemoryBuffer;
								
							setParent ..;
						setParent ..;
						
						$MentalRayExportRollout = `frameLayout -label "Mental Ray Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Mental Ray to export mi files instead of rendering." frw_tileLabel;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 320 -ct2 "left" "right";
									$MentalRayFilenameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output File" -buttonLabel "..." -text $mentalRayFilename -changeCommand SavePersistentDeadlineOptions -annotation "The full filename of the Mental Ray files that will be exported (padding is handled automatically by the exporter)" frw_mentalRayFilePath`;
									textFieldButtonGrp -e -bc ("dlSetSaveFilename(\""+$MentalRayFilenameGrp+"\", \"Mental Ray Files (*.mi);;All Files (*)\")") $MentalRayFilenameGrp;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 110 290 -ct2 "left" "left";
									button -label "Export Settings..." -width 100 -c OpenExportSettings -height 26 -annotation "Opens the Export Settings dialog";
									text -label "(This dialog must be open when submitting the job)";
								setParent ..;
							setParent ..;
						setParent ..;
						
						$MentalRayExportRenderJobRollout = `frameLayout -label "Mental Ray Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Mental Ray Standalone Render Job" -align "left" -v $submitMentalRayJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a Mental Ray Standalone job that is dependent on the export job will also be submitted" frw_submitMentalRayJob;
								
								string $mentalPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineMentalPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $mentalPoolsBox;
								}
								
								string $secondaryMentalPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Workers" frw_deadlineMentalSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryMentalPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryMentalPoolsBox;
								}
									
								string $groupsMentalBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_MentalGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsMentalBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_MentalJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_MentalLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a Worker can dequeue for this job simultaneously" frw_MentalConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a Worker has to render an individual task before timing out (specify 0 for no limit)" frw_MentalSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a Worker should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MentalMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_MentalAutoTaskTimeout;
								setParent ..;
								
								$MentalLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_MentalLimitGroups`;
								textFieldButtonGrp -e -bc ("dlSetLimitGroups( \""+$MentalLimitGroupGrp+"\"  )") $MentalLimitGroupGrp;
								
								$MentalMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_MentalMachineList`;
								textFieldButtonGrp -e -bc ("dlSetMachineList( \""+$MentalMachineListGrp+"\")") $MentalMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $MentalOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_MentalOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $MentalOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_MentalIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $mentalRayThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_mentalRayThreads;
								
								intSliderGrp -label "Frame Offset" -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10000 -maxValue 10000 -v $mentalRayOffset -changeCommand SavePersistentDeadlineOptions -annotation  "The value to offset the frame numbers by when rendering separate mi files per frame" frw_mentalRayOffset;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $mentalRayBuildBox = `optionMenuGrp -label "Mental Ray Build" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Force Deadline to render using the specified build of Maya" frw_mentalRayBuild`;
									menuItem -label "None";
									menuItem -label "32bit";
									menuItem -label "64bit";
									if( $mayaBuildEnabled )
									{
										if( `about -is64` )
											optionMenuGrp -e -select (3) $mentalRayBuildBox;
										else
											optionMenuGrp -e -select (2) $mentalRayBuildBox;
									}
									else
										optionMenuGrp -e -select (1) $mentalRayBuildBox;
									
									checkBox -label "Enable Local Rendering" -v $mentalRayLocalRendering -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the Workers will render locally, and then copy the images to the network output directory on completion" frw_mentalRayLocalRendering;
								setParent ..;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $mentalRayArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to mental ray" frw_mentalRayArgs;
							setParent ..;
						setParent ..;
						
						$VrayExportRollout = `frameLayout -label "VRay Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses VRay to export vrscene files instead of rendering." frw_tileLabel;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 320 -ct2 "left" "right";
									$VRayFilenameGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Output File" -buttonLabel "..." -text $vrayFilename -changeCommand SavePersistentDeadlineOptions -annotation "The full filename of the VRay files that will be exported (padding is handled automatically by the exporter)" frw_vrayFilePath`;
									textFieldButtonGrp -e -bc ("dlSetSaveFilename(\"" + $VRayFilenameGrp + "\", \"VRay Scene Files (*.vrscene);;All Files (*)\")") $VRayFilenameGrp;
								setParent ..;
							setParent ..;
						setParent ..;
							
						$VrayExportRenderJobRollout = `frameLayout -label "VRay Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent VRay Standalone Render Job" -align "left" -v $submitVRayJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a VRay Standalone job that is dependent on the export job will also be submitted" frw_submitVRayJob;
								string $vrayPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineVrayPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $vrayPoolsBox;
								}
								
								string $secondaryVrayPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Workers" frw_deadlineVraySecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryVrayPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryVrayPoolsBox;
								}
									
								string $groupsVrayBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_VrayGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsVrayBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_VrayJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_VrayLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a Worker can dequeue for this job simultaneously" frw_VrayConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a Worker has to render an individual task before timing out (specify 0 for no limit)" frw_VraySlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a Worker should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_VrayMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_VrayAutoTaskTimeout;
								setParent ..;
								
								
								$VrayLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_VrayLimitGroups`;
								textFieldButtonGrp -e -bc ("dlSetLimitGroups( \""+$VrayLimitGroupGrp+"\"  )") $VrayLimitGroupGrp;
								
								$VrayMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_VrayMachineList`;
								textFieldButtonGrp -e -bc ("dlSetMachineList( \""+$VrayMachineListGrp+"\")") $VrayMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $VrayOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_VrayOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $VrayOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_VrayIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $vrayThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_vrayThreads;
								
							setParent ..;
						setParent ..;
						
						$MayaRenderOptionsGPURollout = `frameLayout -label "GPU Affinity Overrides" -labelVisible true -borderVisible false -collapsable true -visible ($renderer == "redshift" || $renderer == "ifmIrayPhotoreal" || $renderer == "OctaneRender" )`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								intSliderGrp -enable (strcmp($deadlineGPUsSelectDevices, "") == 0) -label "GPUs Per Task" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 16 -v $deadlineGPUsPerTask -changeCommand SavePersistentDeadlineOptions -annotation  "The number of GPUs to use per task. If set to 0, the default number of GPUs will be used." frw_deadlineGPUsPerTask;

								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									textFieldGrp -enable ($deadlineGPUsPerTask == 0) -label "Select GPU Devices" -cl2 "left" "left" -cw2 $labelWidth 320 -text $deadlineGPUsSelectDevices -textChangedCommand SavePersistentDeadlineOptions -annotation "A comma separated list of the GPU devices to use specified by device Id. 'GPUs Per Task' will be ignored." frw_deadlineGPUsSelectDevices;

									// the "placeholderText" parameter did not exist until Maya 2013 Extension Pack
									if ( getApplicationVersionAsFloat() > 2013)
									{
										textFieldGrp -e -placeholderText "Enter Valid GPU Device Id(s): 0 or 1 or 0,2 or 0,3,4 etc" frw_deadlineGPUsSelectDevices;
									}
								setParent ..;
							setParent ..;
						setParent ..;
						
						int $vrimg2ExrEnabled = $submitVRayJob;
						$VrayExportVrimgJobRollout = `frameLayout -label "Vrimg2Exr Conversion Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -enable $vrimg2ExrEnabled -label "Convert vrimg Files To exr With Dependent Job" -align "left" -v $submitVrimg2ExrJob -changeCommand SavePersistentDeadlineOptions -annotation "Enable this option to submit a dependent job that converts the vrimg output files to exr files" frw_submitVrimg2ExrJob;
								checkBox -enable $vrimg2ExrEnabled -label "Delete Input vrimg Files After Conversion" -align "left" -v $deleteVrimgFiles -changeCommand SavePersistentDeadlineOptions -annotation "Enable this option to delete the input vrimg file after the conversion has finished." frw_deleteVrimgFiles;
							setParent ..;
						setParent ..;
						
						$RendermanExportRollout = `frameLayout -label "RenderMan Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses RenderMan to export rib files instead of rendering." frw_exportRenderManLabel;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $exportRenderManThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during exporting (specify 0 to use all processors available)" frw_exportRenderManThreads;
								
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 158 -ct2 "left" "left";
									text -align "left" -label "" frw_dummyRenderWithRisLabel;
									checkBox -label "Render With RIS" -v $renderRenderManWithRis -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the exported RIB files will have RIS set as the renderer instead of REYES" frw_renderRenderManWithRis;
								setParent ..;
							setParent ..;
						setParent ..;
						
						$RendermanExportRenderJobRollout = `frameLayout -label "RenderMan Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent RenderMan Standalone Render Job" -align "left" -v $submitRenderManJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a RenderMan Standalone job that is dependent on the export job will also be submitted" frw_submitRenderManJob;
								checkBox -label "Enable RenderMan Frame Dependencies" -align "left" -v $renderManFrameDependent -changeCommand SavePersistentDeadlineOptions -annotation "If Checked, the RenderMan Job will have Frame Dependencies. If your scene contains static content, do not use!" frw_renderManFrameDependent;
								string $rendermanPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineRendermanPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $rendermanPoolsBox;
								}
								
								string $secondaryRendermanPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Workers" frw_deadlineRendermanSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryRendermanPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryRendermanPoolsBox;
								}
									
								string $groupsRendermanBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_RendermanGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsRendermanBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_RendermanJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_RendermanLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a Worker can dequeue for this job simultaneously" frw_RendermanConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a Worker has to render an individual task before timing out (specify 0 for no limit)" frw_RendermanSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a Worker should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_RendermanMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_RendermanAutoTaskTimeout;
								setParent ..;
						
								$RendermanLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_RendermanLimitGroups`;
								textFieldButtonGrp -e -bc ("dlSetLimitGroups( \""+$RendermanLimitGroupGrp+"\"  )") $RendermanLimitGroupGrp;
								
								$RendermanMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_RendermanMachineList`;
								textFieldButtonGrp -e -bc ("dlSetMachineList( \""+$RendermanMachineListGrp+"\")") $RendermanMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $RendermanOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_RendermanOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $RendermanOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_RendermanIsBlacklist;
								setParent ..;
								
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $rendermanThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_rendermanThreads;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $rendermanArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to RenderMan" frw_rendermanArgs;
							setParent ..;
						setParent ..;
						
						$ArnoldExportRollout = `frameLayout -label "Arnold Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Arnold to export ass files instead of rendering." frw_exportArnoldLabel;
								setParent ..;

								// Drop-down to select the render layer setting - one of:
								//    Active Layer At Submission Time
								//    All Render Layers (Separate Jobs)
								string $arnoldRenderLayers = `optionMenuGrp -label "Render Layers" -en $renderLayerEnabled -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "Which render layers to submit" frw_deadlineArnoldRenderLayers`;
								menuItem -label "Active Layer At Submission Time" -annotation "The active layer at the time of submission";
								menuItem -label "All Render Layers (Separate Jobs)" -annotation "All renderable layers are submitted a separate jobs";
								// Restore the sticky setting. Menu group indices are 1-based and the persisted value is 0-based
								if( !$renderLayerEnabled )
								{
									optionMenuGrp -e -select 1 $arnoldRenderLayers;
								}
								else
								{
									optionMenuGrp -e -select ($arnoldLayerSubmission + 1) $arnoldRenderLayers;
								}
							setParent ..;
						setParent ..;
						
						$ArnoldExportRenderJobRollout = `frameLayout -label "Arnold Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Arnold Standalone Render Job" -align "left" -v $submitArnoldJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, an Arnold Standalone job that is dependent on the export job will also be submitted" frw_submitArnoldJob;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									checkBox -label "Local Export to Arnold" -align "left" -v $exportArnoldLocal -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the arnold ass file will be exported locally" frw_exportArnoldLocal;
									checkBox -label "Export Compressed" -align "left" -v $exportArnoldCompressed -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the exported ass file will be compressed" frw_exportArnoldCompressed;
								setParent ..;
								
								string $arnoldPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineArnoldPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $arnoldPoolsBox;
								}
								
								string $secondaryArnoldPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Workers" frw_deadlineArnoldSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryArnoldPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryArnoldPoolsBox;
								}
									
								string $groupsArnoldBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_ArnoldGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsArnoldBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_ArnoldJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_ArnoldLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a Worker can dequeue for this job simultaneously" frw_ArnoldConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a Worker has to render an individual task before timing out (specify 0 for no limit)" frw_ArnoldSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a Worker should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_ArnoldMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_ArnoldAutoTaskTimeout;
								setParent ..;
								
								$ArnoldLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_ArnoldLimitGroups`;
								textFieldButtonGrp -e -bc ("dlSetLimitGroups( \""+$ArnoldLimitGroupGrp+"\"  )") $ArnoldLimitGroupGrp;
								
								$ArnoldMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_ArnoldMachineList`;
								textFieldButtonGrp -e -bc ("dlSetMachineList( \""+$ArnoldMachineListGrp+"\")") $ArnoldMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $ArnoldOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_ArnoldOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $ArnoldOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_ArnoldIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $arnoldThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_arnoldThreads;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $arnoldArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Arnold" frw_arnoldArgs;
							setParent ..;
						setParent ..;
						
						$MaxwellExportRollout = `frameLayout -label "Maxwell Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Maxwell to export MXS files instead of rendering." frw_exportMaxwellLabel;
								setParent ..;
								$MaxwellOutputScriptListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Maxwell Script Name" -buttonLabel "..." -text $maxwellScript -annotation "The Maxwell scene file to export to." frw_maxwellScriptName`;
								textFieldButtonGrp -e -bc ("dlSetSaveFilename(\""+ $MaxwellOutputScriptListGrp + "\", \"Maxwell Files (*.mxs)\" )") $MaxwellOutputScriptListGrp;
								checkBox -label "Resume From MXI File If It Exists  (requires Maxwell 2.5.1 or later)" -changeCommand SavePersistentDeadlineOptions -v false -annotation "Requires Maxwell 2.5.1. If enabled, Maxwell will use the specified MXI file to resume the render if it exists. If you suspend the job in Deadline, it will pick up from where it left off when it resumes." frw_maxwellMXIResume;
							setParent ..;
						setParent ..;
						
						$MaxwellExportRenderJobRollout = `frameLayout -label "Maxwell Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Maxwell Standalone Render Job" -align "left" -v $submitMaxwellJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a Maxwell Standalone job that is dependent on the export job will also be submitted" frw_submitMaxwellJob;
								checkBox -label "Local Export to Maxwell" -align "left" -v $exportMaxwellLocal -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the Maxwell mxs file will be exported locally" frw_exportMaxwellLocal;
								
								string $maxwellPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineMaxwellPool`;
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $maxwellPoolsBox;
								}
								
								string $secondaryMaxwellPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Workers" frw_deadlineMaxwellSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryMaxwellPoolsBox;
								
								for( $i = 0; $i < size($deadlinePools); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryMaxwellPoolsBox;
								}
									
								string $groupsMaxwellBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_MaxwellGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsMaxwellBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_MaxwellJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_MaxwellLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a Worker can dequeue for this job simultaneously" frw_MaxwellConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a Worker has to render an individual task before timing out (specify 0 for no limit)" frw_MaxwellSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a Worker should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_MaxwellMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_MaxwellAutoTaskTimeout;
								setParent ..;
								
								$MaxwellLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_MaxwellLimitGroups`;
								textFieldButtonGrp -e -bc ("dlSetLimitGroups( \""+$MaxwellLimitGroupGrp+"\"  )") $MaxwellLimitGroupGrp;
								
								$MaxwellMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_MaxwellMachineList`;
								textFieldButtonGrp -e -bc ("dlSetMachineList( \""+$MaxwellMachineListGrp+"\")") $MaxwellMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $MaxwellOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_MaxwellOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $MaxwellOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_MaxwellIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $maxwellThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_maxwellThreads;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $maxwellArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Maxwell" frw_maxwellArgs;
							setParent ..;
						setParent ..;

						$MaxwellExportCoopOptionsRollout = `frameLayout - label "Maxwell Cooperative Rendering" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								int $frameRangeEnabled = !IsAnimatedOn();

								rowLayout -numberOfColumns 2 -cw 1 200 -ct1 "left";
									checkBox -label "Cooperative Rendering" -changeCommand SavePersistentDeadlineOptions -v true -annotation "If enabled, multiple jobs will be submitted to Deadline, each with a different seed. You can then use Maxwell to combine the resulting output after rendering has completed." frw_maxwellCooperativeRendering;
									checkBox -en $frameRangeEnabled -label "Split Co-op Renders Into Separate Jobs" -changeCommand SavePersistentDeadlineOptions -v true -annotation "If enabled, co-op renders will be split up into separate jobs. This is required if rendering an animation instead of a single Maxwell file." frw_maxwellCoopSeparateJobs;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw 1 200 -ct1 "left";
									text -label "Number Of Co-op Renders" frw_maxwellNumCoopRendersLabel;
									intField -changeCommand SavePersistentDeadlineOptions -minValue 2 -maxValue 1000000 -v 2 -annotation "The number of co-op renders to submit to Deadline." frw_maxwellNumCoopRenders;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw 1 200 -ct1 "left";
									checkBox -label "Auto-Merge Files" -changeCommand SavePersistentDeadlineOptions -v $maxwellAutoMergeFiles -annotation "Enable if you want Deadline to use Maxwell to merge the results from the co-op jobs." frw_maxwellAutoMergeFiles;
									checkBox -en $maxwellAutoMergeFiles -label "Fail On Missing Intermediate Files" -changeCommand SavePersistentDeadlineOptions -v true -annotation "Enable to have the merge job fail if there are co-op job results that are missing." frw_maxwellMissingIntermediate;
								setParent ..;

								rowLayout -numberOfColumns 2 -cw 1 200 -ct1 "right";
									text -label "";
									checkBox -en $maxwellAutoMergeFiles -label "Delete Intermediate Files" -changeCommand SavePersistentDeadlineOptions -v false -annotation "Enable to have Deadline delete the individual co-op job results after merging the final result." frw_maxwellDeleteIntermediate;
								setParent ..;
							setParent ..;
						setParent ..;
						
						$MayaRenderOptionsTileRollout = `frameLayout -label "Region Rendering" -labelVisible true -borderVisible false -collapsable true -collapse true`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "For arnold, mayaSoftware, mentalRay, redshift, renderMan, finalRender, turtle, vray, and arnold export\njobs only. If you have multiple layers, this only works if you submit each layer as a separate job." frw_tileLabel;
								setParent ..;
								
								string $regionRenderTypeTypeBox = `optionMenuGrp -label "Region Render Type" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand UpdateRegionRenderType -annotation "Select the method of region rendering" frw_regionRenderType`;
								menuItem -label "Jigsaw Rendering";
								menuItem -label "Tile Rendering";
								optionMenuGrp -e -select (1) $regionRenderTypeTypeBox;
								
								rowLayout -numberOfColumns 1 -cw 1 $labelWidth -ct1 "left";
									checkBox -enable $tileRenderingEnable -label "Enable Region Rendering" -changeCommand SavePersistentDeadlineOptions -v $regionRendering -annotation "Tile rendering splits up a frame between multiple machines (the assembly is done automatically for bmp, exr, jpg, png, tga, and tif)" frw_regionRendering;
								setParent ..;
								
								columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4 frw_tileRenderLayout;
									rowLayout -numberOfColumns 1 -cw 1 (310 + $labelWidth) -ct1 "right";
										intSliderGrp -enable $regionRendering -label "Tiles In X" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 200 -v $tilesInX -changeCommand SavePersistentDeadlineOptions -annotation "The number of tiles in the X direction" frw_tilesInX;
									setParent ..;
									
									rowLayout -numberOfColumns 1 -cw 1 (310 + $labelWidth) -ct1 "right";
										intSliderGrp -enable $regionRendering -label "Tiles In Y" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 200 -v $tilesInY -changeCommand SavePersistentDeadlineOptions -annotation "The number of tiles in the Y direction" frw_tilesInY;
									setParent ..;
								setParent ..;
								string $tileRenderingSingleJob = `checkBox -en $regionRendering -align "left" -label "Submit All Tiles As A Single Job" -v $tileSingleJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this to combine all tiles into a single job." frw_submitTileSingleJob`;
								
								rowLayout -numberOfColumns 1 -cw 1 (320 + $labelWidth) -ct1 "right";
									intSliderGrp -enable $regionRendering -label "Single Job Frame" -cal 1 "left" -cw 1 $labelWidth -field true -minValue -100000 -maxValue 100000 -v $currTime -changeCommand SavePersistentDeadlineOptions -annotation "The single frame to render." frw_tileSingleFrame;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 260 -ct2 "left" "left" frw_jigsawRenderLayout;
									$OpenJigsawBtn = `button -label "Open Jigsaw Panel" -width 105 -height 26 -annotation "Opens the Jigsaw panel" -c OpenJigsawWindow frw_openJigsaw`;
									text -align "left" -label "Jigsaw Panel must be open during submission." frw_jigsawLabel;
								setParent ..;
								
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Submit Dependent Assembly Job" -v $tileDependentJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this submit an assembly job that is dependent on the first job." frw_submitTileDependentJob;
									checkBox -en $regionRendering -align "left" -label "Error on Missing Tiles" -v $tileErrorOnMissing -changeCommand SavePersistentDeadlineOptions -annotation "Check this force the render to fail on a missing tile" frw_submitTileErrorOnMissing;
									setParent ..;
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Cleanup Tiles After Assembly" -v $tileCleanupJob -changeCommand SavePersistentDeadlineOptions -annotation "Check this to delete all tiles after the assembly job completes." frw_submitTileCleanupJob;
								setParent ..;
								rowLayout -numberOfColumns 2 -cw2 260 160 -ct2 "left" "left";
									string $compositeTypeBox = `optionMenuGrp -label "Assemble over" -cl2 "left" "left" -cw2 $labelWidth 130 -changeCommand UpdateCompositeType -annotation "Select the image to composite over" frw_compositeType`;
									menuItem -label "Blank Image";
									menuItem -label "Previous Output";
									menuItem -label "Selected Image";
									optionMenuGrp -e -select (1) $compositeTypeBox;
								setParent ..;
								rowLayout -numberOfColumns 1 -cw2 260 160 -ct2 "left" "left" frw_compLayout;
									$CompositeNamePathGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Background Image File" -buttonLabel "..." -text $tileCompositeOverName -changeCommand SavePersistentDeadlineOptions -annotation "The name of the file to Assemble over" frw_submitTileCompositeOverName`;
									textFieldButtonGrp -e -bc ("dlSetLoadFilename(\"" + $CompositeNamePathGrp + "\", \"All files (*)\")") $CompositeNamePathGrp;
								setParent ..;
								rowLayout -numberOfColumns 1 -cw2 260 160 -ct2 "left" "left";
									checkBox -en $regionRendering -align "left" -label "Error on Missing Background" -v $tileMissingBackground -changeCommand SavePersistentDeadlineOptions -annotation "Check this to have the assemble fail if the background file is missing." frw_submitTileErrorOnMissingBackground;
								setParent ..;
								
							setParent ..;
						setParent ..;

						$BifrostSimulationJobRollout = `frameLayout -label "Bifrost Simulation Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Caches all bifrost containers.";
								setParent..;

								$BifrostDirectoryButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Bifrost Cache Directory" -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The directory where the Bifrost cache will be sent." frw_bifrostCacheDir`;
								textFieldButtonGrp -e -bc ("dlSetDirectory( \"" + $BifrostDirectoryButtonGrp + "\" )") $BifrostDirectoryButtonGrp;

								if(IntMayaVersion() >= 2016) // Maya 2016 and beyond: Add options for format and compression index
								{
									optionMenuGrp -label "Compression Format" -cl2 "left" "left" -cw2 $labelWidth 160 -annotation "Select the Compression Format to use" frw_biFrostCompressionFormat;
									menuItem -label "Simple (lossless, least compression)";
									menuItem -label "Float (lossless)";
									menuItem -label "Quantization (lossy)";
							
								}
							setParent ..;
						setParent ..;
						
						$AlembicExportJobRollout = `frameLayout -label "Alembic Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Export scene or selection to Alembic format (.abc).";
								setParent ..;

								$AlembicFileButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Alembic Output File" -buttonLabel "..." -changeCommand SavePersistentDeadlineOptions -annotation "The file that Alembic will write to." frw_alembicExportFile`;
								textFieldButtonGrp -e -bc ("dlSetSaveFilename( \"" + $AlembicFileButtonGrp + "\", \"Alembic Files (*.abc)\" )") $AlembicFileButtonGrp;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Export:" -labelArray2 "All" "Selection" -cw3 $labelWidth 160 160 -select 1 frw_AlembicExportSelection;

							setParent ..;
						setParent ..;

						$AlembicAdvancedOptionsJobRollout = `frameLayout -label "Advanced Options" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
								setParent ..;
																
								checkBox -label "Subframe Samples" -align "left" -changeCommand SavePersistentDeadlineOptions frw_abcSubFrameCheck;
								floatSliderGrp -label "Low" -enable false -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10 -maxValue 10 -v -0.2 -changeCommand SavePersistentDeadlineOptions frw_abcLowSubFrameCheck;
								floatSliderGrp -label "High" -enable false -cal 1 "left" -cw 1 $labelWidth -field true -minValue -10 -maxValue 10 -v 0.2 -changeCommand SavePersistentDeadlineOptions frw_abcHighSubFrameCheck;
								
								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -annotation "The list of geometric attributes to write out. Separated by commas." -label "Attributes: " frw_abcDynamicAttributes;
								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -annotation "The list of Prefix filter for determining which geometric attributes to write out. Separated by commas." -label "Attribute Prefixes: " frw_abcDynamicAttributePrefix;
								
								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Verbose" -align "left" -changeCommand SavePersistentDeadlineOptions frw_verboseCheck;
									checkBox -label "No Normals" -align "left" -changeCommand SavePersistentDeadlineOptions frw_noNormalsCheck;
									checkBox -label "Renderable Only" -changeCommand SavePersistentDeadlineOptions frw_renderableOnlyCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Strip Namespaces" -align "left" -changeCommand SavePersistentDeadlineOptions frw_stripNamespacesCheck;
									checkBox -label "UV Write" -align "left" -changeCommand SavePersistentDeadlineOptions frw_uvWriteCheck;
									checkBox -label "Write Color Sets" -changeCommand SavePersistentDeadlineOptions frw_writeColorSetsCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Write Face Sets" -align "left" -changeCommand SavePersistentDeadlineOptions frw_writeFaceSetsCheck;
									checkBox -label "Whole Frame Geo" -align "left" -changeCommand SavePersistentDeadlineOptions frw_wholeFrameGeoCheck;
									checkBox -label "World Space" -changeCommand SavePersistentDeadlineOptions frw_worldSpaceCheck;
								setParent ..;

								rowLayout -numberOfColumns 3 -cw3 160 160 160 -ct3 "left" "left" "left";
									checkBox -label "Write Visibility" -align "left" -changeCommand SavePersistentDeadlineOptions frw_writeVisibilityCheck;
									checkBox -label "Filter Euler Rotations" -align "left" -changeCommand SavePersistentDeadlineOptions frw_filterEulerRotationsCheck;
									checkBox -label "Write Creases" -changeCommand SavePersistentDeadlineOptions frw_writeCreasesCheck;
								setParent ..;
								optionMenuGrp -label "Alembic Format" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_alembicFormat;
								menuItem -label "HDF5 - Maya 2014 Extension 1 and Legacy";
								menuItem -label "Ogawa - Maya 2014 Extension 1";
								
							setParent ..;
						setParent ..;

							

						$MayaScriptJobRollout = `frameLayout -label "Maya Script Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Python or Melscript to run a custom Maya script.";
								setParent ..;
								$MayaScriptButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Script File Name" -buttonLabel "..." -annotation "The custom script to run." frw_mayaScriptJob`;
								textFieldButtonGrp -e -bc ("dlSetLoadFilename(\"" + $MayaScriptButtonGrp + "\", \"Melscript Files (*.mel);;Python FIles (*.py)\" )") $MayaScriptButtonGrp;
							setParent ..;
						setParent ..;

						$FluidCachingJobRollout = `frameLayout -label "Fluid Caching Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Runs a Fluid Caching Job on selected fluids.";
								setParent ..;

								$FluidCachingDirButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Cache Output Directory: " -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The folder that the cache will be saved in." frw_FluidCacheOutputDir`;
								textFieldButtonGrp -e -bc ("dlSetDirectory(\"" + $FluidCachingDirButtonGrp + "\")") $FluidCachingDirButtonGrp;
								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -label "Cache Prefix Name: " frw_FluidCacheFileName;
								optionMenuGrp -label "Cache Format: " -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_FluidCacheFormat;
								menuItem -label "mcc";
								menuItem -label "mcx";

								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "File Distribution:" -labelArray2 "One File Per Frame" "Only One File" -cw3 $labelWidth 160 160 -select 1 -vr frw_FluidCacheFileDistRadio;
								checkBox -label "One Cache Per Fluid" -changeCommand SavePersistentDeadlineOptions frw_FluidCacheSplitCheck;			

							setParent ..;
						setParent ..;

						$GeometryCachingJobRollout = `frameLayout -label "Geometry Caching Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Runs a Geometry caching job on selected geometry.";
								setParent ..;

								$GeometryCachingDirButtonGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Cache Output Directory: " -buttonLabel "..." -text $projectPath -changeCommand SavePersistentDeadlineOptions -annotation "The folder that the cache will be saved in." frw_GeometricCacheOutputDir`;
								textFieldButtonGrp -e -bc ("dlSetDirectory(\"" + $GeometryCachingDirButtonGrp + "\")") $GeometryCachingDirButtonGrp;

								textFieldGrp -cal 1 "left"  -cw 1 $labelWidth -cw 2 300 -label "Cache Prefix Name: " frw_GeoCacheFileName;

								optionMenuGrp -label "Cache Format: " -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions frw_GeoCacheFormat;
								menuItem -label "mcc";
								menuItem -label "mcx";

								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "File Distribution:" -labelArray2 "One File Per Frame" "Only One File" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheFileDistRadio;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Store Points As:" -labelArray2 "Double" "Float" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheDblOrFltRadio;
								radioButtonGrp -cl2 "left" "left" -numberOfRadioButtons 2 -label "Store Points In:" -labelArray2 "Local" "World" -cw3 $labelWidth 160 160 -select 1 -vr frw_GeometricCacheLocOrWldRadio;			
								checkBox -label "One Cache Per Geometry" -changeCommand SavePersistentDeadlineOptions frw_GeometricCacheSplitCheck;		
							setParent ..;
						setParent ..;

						$RedshiftExportRollout = `frameLayout -label "Redshift Export Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								rowLayout -numberOfColumns 1 -cw 1 400 -ct1 "left";
									text -align "left" -label "Uses Redshift to export .rs files instead of rendering." frw_exportRedshiftLabel;
								setParent ..;
							setParent ..;
						setParent ..;

						$RedshiftExportRenderJobRollout = `frameLayout -label "Redshift Render Job" -labelVisible true -borderVisible false -collapsable true -visible false`;
							columnLayout -adj true -columnAttach "both" 4 -rowSpacing 4;
								checkBox -label "Submit Dependent Redshift Standalone Render Job" -align "left" -v $submitRedshiftJob -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, a Redshift Standalone job that is dependent on the export job will also be submitted" frw_submitRedshiftJob;
								checkBox -label "Local Export to Redshift" -align "left" -v $exportRedshiftLocal -changeCommand SavePersistentDeadlineOptions -annotation "If this option is set to true, the redshift rs file will be exported locally" frw_exportRedshiftLocal;
								checkBox -label "Enable Redshift Frame Dependencies" -align "left" -v $redshiftFrameDependent -changeCommand SavePersistentDeadlineOptions -annotation "If Checked, the Redshift Job will have Frame Dependencies. If your scene contains static content, do not use!" frw_redshiftFrameDependent;
								checkBox -en $renderLayerEnabled -label "Submit Render Layers As Separate Jobs" -align "left" -v $redshiftLayerSubmission -changeCommand SavePersistentDeadlineOptions -annotation "Check this to submit each renderable Render Layer as a separate Deadline job. Note that the frame range will be pulled from the render globals for each layer." frw_redshiftLayerSubmission;

								string $redshiftPoolsBox = `optionMenuGrp -label "Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The pool the job belongs to" frw_deadlineRedshiftPool`;
								for( $i = 0; $i < size( $deadlinePools ); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobPool )
										optionMenuGrp -e -select ($i+1) $redshiftPoolsBox;
								}
								
								string $secondaryRedshiftPoolsBox = `optionMenuGrp -label "Secondary Pool" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "The secondary pool lets you specify a Pool to use if the primary Pool does not have any available Workers" frw_deadlineRedshiftSecondaryPool`;
								menuItem -label "";
								if( "" == $savedJobSecondaryPool )
									optionMenuGrp -e -select 1 $secondaryRedshiftPoolsBox;
								
								for( $i = 0; $i < size( $deadlinePools ); ++$i )
								{ 
									menuItem -label $deadlinePools[$i];
									if( $deadlinePools[$i] == $savedJobSecondaryPool )
										optionMenuGrp -e -select ($i+2) $secondaryRedshiftPoolsBox;
								}
								
								string $groupsRedshiftBox = `optionMenuGrp -label "Group" -cl2 "left" "left" -cw2 $labelWidth 320 -changeCommand SavePersistentDeadlineOptions -annotation "The group the job belongs to" frw_RedshiftGroup`;
								for( $i = 0; $i < size( $deadlineGroups ); ++$i )
								{ 
									menuItem -label $deadlineGroups[$i];
									if( $deadlineGroups[$i] == $savedGroup )
										optionMenuGrp -e -select ($i+1) $groupsRedshiftBox;
								}
								
								intSliderGrp -label "Priority" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue $maximumPriority -v $priority -changeCommand SavePersistentDeadlineOptions -annotation "The job's priority (0 is the lowest, 100 is the highest)" frw_RedshiftJobPriority;
								intSliderGrp -label "Machine Limit" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 1000 -v $limitCount -changeCommand SavePersistentDeadlineOptions -annotation "Limit the number of machines that can render this job concurrently (specify 0 for no machine limit)" frw_RedshiftLimitCount;
								intSliderGrp -label "Concurrent Tasks" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 1 -maxValue 16 -v $concurrentTasks -changeCommand SavePersistentDeadlineOptions -annotation "The number of tasks a Worker can dequeue for this job simultaneously" frw_RedshiftConcurrentTasks;
								intSliderGrp -label "Task Timeout" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $SlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The number of minutes a Worker has to render an individual task before timing out (specify 0 for no limit)" frw_RedshiftSlaveTimeout;
								intSliderGrp -label "Minimum Task Time" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 5000 -v $MinSlaveTimeout -changeCommand SavePersistentDeadlineOptions -annotation "The minimum number of minutes a Worker should render a task for, otherwise an error will be reported (specify 0 for no minimum)" frw_RedshiftMinSlaveTimeout;
								rowLayout -numberOfColumns 2 -cw2 $labelWidth 160 -ct2 "left" "left";
									text -align "left" -label "" frw_dummySubmitSuspendedLabel;
									checkBox -label "Enable Auto Task Timeout" -v $AutoTaskTimeout -changeCommand SavePersistentDeadlineOptions -annotation "If the Auto Task Timeout is properly configured in the Repository Options, then enabling this will allow a task timeout to be automatically calculated based on the render times of previous frames for the job" frw_RedshiftAutoTaskTimeout;
								setParent ..;
								
								$RedshiftLimitGroupGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Limit Groups" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The limit groups that this job requires." frw_RedshiftLimitGroups`;
								textFieldButtonGrp -e -bc ("dlSetLimitGroups( \""+$RedshiftLimitGroupGrp+"\"  )") $RedshiftLimitGroupGrp;
								
								$RedshiftMachineListGrp = `textFieldButtonGrp -cal 1 "left" -cw 1 $labelWidth -cw 2 300 -label "Machine List" -buttonLabel "..." -text "" -changeCommand SavePersistentDeadlineOptions -annotation "The whitelist or blacklist for the job." frw_RedshiftMachineList`;
								textFieldButtonGrp -e -bc ("dlSetMachineList( \""+$RedshiftMachineListGrp+"\")") $RedshiftMachineListGrp;
								
								rowLayout -numberOfColumns 2 -cw2 (160 + $labelWidth) 160 -ct2 "left" "left";
									string $RedshiftOnCompleteBox = `optionMenuGrp -label "On Complete" -cl2 "left" "left" -cw2 $labelWidth 160 -changeCommand SavePersistentDeadlineOptions -annotation "What to do with the job after it completes." frw_RedshiftOnComplete`;
									menuItem -label "Nothing";
									menuItem -label "Archive";
									menuItem -label "Delete";
									optionMenuGrp -e -select (1) $RedshiftOnCompleteBox;
									
									checkBox -label "Machine List is a Blacklist" -v $isBlacklist -changeCommand SavePersistentDeadlineOptions -annotation "If checked, the machine list will be a blacklist. Otherwise, it is a whitelist." frw_RedshiftIsBlacklist;
								setParent ..;
								
								intSliderGrp -label "Threads" -cal 1 "left" -cw 1 $labelWidth -field true -minValue 0 -maxValue 256 -v $redshiftThreads -changeCommand SavePersistentDeadlineOptions -annotation  "The number of threads to use during rendering (specify 0 to use all processors available)" frw_redshiftThreads;
								
								textFieldGrp -label "Command Line Args" -cl2 "left" "left" -cw2 $labelWidth 320 -text $redshiftArgs -changeCommand SavePersistentDeadlineOptions -annotation "Additional command line options to pass to Redshift" frw_redshiftArgs;
							setParent ..;
						setParent ..;
					setParent ..;
				setParent ..;
			setParent ..;
		//
	setParent ..;
	//bottom buttons
	columnLayout -adj true -columnAttach "both" 0 -rowSpacing 2 buttonColumnLayout;
		separator -width 525;
		rowLayout -numberOfColumns 3 -cw3 150 10 295; //ADDS to 525??
			columnLayout -adj true -columnAttach "both" 4 -rowSpacing 2;
				button -label "Render Globals" -width 150 -height 15 -c unifiedRenderGlobalsWindow -annotation "Opens the Maya Render Globals Dialog";
				button -label "Edit Project" -width 150 -height 15 -c ProjectWindow -annotation "Opens the Maya Edit Project Dialog";
				button -label "Online Help" -width 150 -c OnlineHelp -height 15 -annotation "Opens the Online Help page in the Default Web Browser";
			setParent ..;
			text -label "";
			columnLayout -adj true -columnAttach "both" 4 -rowSpacing 2;
				rowLayout -numberOfColumns 3 -cw2 105 230;
					$PipelineToolStatusLabel = `text -label $PipelineToolStatus -width 150 -height 40 -ww true `;
					button -label "Pipeline Tools" -width 100 -height 30 -annotation "Opens the Pipeline Tools Dialog" -c OpenIntegrationWindow;
					button -label "Submit Job" -width 100 -height 30 -annotation "Submits this job to Deadline" -c DeadlineSubmitterOnOk;
				setParent ..;
				progressBar -width 210 -height 15 -minValue 0 -maxValue 100 -annotation "Deadline Submission Progress" frw_progBar;
			setParent ..;
		setParent ..;
	setParent ..;
	
	//this ties the scroll layout and the bottom buttons together
	formLayout -e
		-af buttonColumnLayout bottom 5
		-af buttonColumnLayout left 5
		-ac mainScrollLayout bottom 5 buttonColumnLayout
		-af mainScrollLayout top 5
		-af mainScrollLayout left 5
	mainFormLayout;
	
	UpdateRegionRenderType();
	UpdateCompositeType();
	
	scriptJob -uiDeleted $DeadlineSubmitterWindow OnExit;
	scriptJob -e "quitApplication" OnExit;
	// Show the submission dialog window.
	showWindow DeadlineSubmitWindow;
}
